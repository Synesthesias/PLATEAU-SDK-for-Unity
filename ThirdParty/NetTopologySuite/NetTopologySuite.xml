<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetTopologySuite</name>
    </assembly>
    <members>
        <member name="T:NetTopologySuite.Algorithm.AngleUtility">
            <summary>
            Utility functions for working with angles.
            Unless otherwise noted, methods in this class express angles in radians.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.AngleUtility.PiTimes2">
            <summary>
            Value of 2 * Pi
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.AngleUtility.PiOver2">
            <summary>
            Value of Pi / 2
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.AngleUtility.PiOver4">
            <summary>
            Value of Pi / 4
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.ToDegrees(System.Double)">
            <summary>
            Converts from radians to degrees.
            </summary>
            <param name="radians">An angle in radians</param>
            <returns>The angle in degrees</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.ToRadians(System.Double)">
            <summary>
            Converts from degrees to radians.
            </summary>
            <param name="angleDegrees">An angle in degrees</param>
            <returns>The angle in radians</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Angle(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the angle of the vector from p0 to p1, relative to the positive X-axis.
            </summary>
            <remarks>The angle is normalized to be in the range [ -Pi, Pi ].</remarks>
            <param name="p0">The initial point of the vector.</param>
            <param name="p1">The terminal point of the vector.</param>
            <returns>The normalized angle (in radians) that p0-p1 makes with the positive X-axis</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Angle(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the angle of the vector from (0,0) to p, relative to the positive X-axis.
            </summary>
            <remarks>
            The angle is normalized to be in the range ( -Pi, Pi ].
            </remarks>
            <param name="p">The terminal point of the vector.</param>
            <returns>The normalized angle (in radians) that (0,0)-p makes with the positive X-axis.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.IsAcute(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the angle between p0-p1-p2 is acute.
            </summary>
            <remarks>
            <para>An angle is acute if it is less than 90 degrees.</para>
            <para>Note: this implementation is not precise (deterministic) for angles very close to 90 degrees.</para>
            </remarks>
            <param name="p0">An endpoint of the angle</param>
            <param name="p1">The base of the angle</param>
            <param name="p2">Another endpoint of the angle</param>
            <returns><see langword="true"/> if the angle is acute.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.IsObtuse(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the angle between p0-p1-p2 is obtuse
            </summary>
            <remarks>
            <para>An angle is obtuse if it is greater than 90 degrees.</para>
            <para>Note: this implementation is not precise (deterministic) for angles very close to 90 degrees.</para>
            </remarks>
            <param name="p0">An endpoint of the angle</param>
            <param name="p1">The base of the angle</param>
            <param name="p2">Another endpoint of the angle</param>
            <returns><see langword="true"/> if the angle is obtuse.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.AngleBetween(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the unoriented smallest angle between two vectors.
            </summary>
            <remarks>
            The computed angle will be in the range [0, Pi).
            </remarks>
            <param name="tip1">The tip of one vector</param>
            <param name="tail">The tail of each vector</param>
            <param name="tip2">The tip of the other vector</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.AngleBetweenOriented(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the oriented smallest angle between two vectors.
            The computed angle will be in the range (-Pi, Pi].
            A positive result corresponds to a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/> rotation (CCW) from v1 to v2;
            a negative result corresponds to a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/> (CW) rotation;
            a zero result corresponds to no rotation.
            </summary>
            <param name="tip1">The tip of v1</param>
            <param name="tail">The tail of each vector</param>
            <param name="tip2">The tip of v2</param>
            <returns>The angle between v1 and v2, relative to v1</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Bisector(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the angle of the unoriented bisector
            of the smallest angle between two vectors.
            </summary>
            <remarks>The computed angle will be in the range (-Pi, Pi].</remarks>
            <param name="tip1">The tip of v1</param>
            <param name="tail">The tail of each vector</param>
            <param name="tip2">The tip of v2</param>
            <returns>The angle of the bisector between v1 and v2</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.InteriorAngle(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the interior angle between two segments of a ring.
            The ring is assumed to be oriented in a clockwise direction.
            </summary>
            <remarks>The computed angle will be in the range [0, 2Pi]</remarks>
            <param name="p0">A point of the ring</param>
            <param name="p1">The next point of the ring</param>
            <param name="p2">The next point of the ring</param>
            <returns>The interior angle based at <paramref name="p1"/></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.GetTurn(System.Double,System.Double)">
            <summary>
            Returns whether an angle must turn clockwise or counterclockwise to overlap another angle.
            </summary>
            <param name="ang1">An angle (in radians)</param>
            <param name="ang2">An angle (in radians)</param>
            <returns>Whether a1 must turn <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/>, <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/> or <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.None"/> to overlap a2.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Normalize(System.Double)">
            <summary>
            Computes the normalized value of an angle, which is the equivalent angle in the range ( -Pi, Pi ].
            </summary>
            <param name="angle">The angle to normalize</param>
            <returns>An equivalent angle in the range (-Pi, Pi]</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.NormalizePositive(System.Double)">
            <summary>
            Computes the normalized positive value of an angle, which is the equivalent angle in the range [ 0, 2*Pi ).
            <para/>
            E.g.
            <list type="table">
            <listheader><term>Function call</term><description>Result</description></listheader>
            <item><term>NormalizePositive(0.0)</term><description>0.0</description></item>
            <item><term>NormalizePositive(-PI)</term><description><see cref="F:System.Math.PI"/></description></item>
            <item><term>NormalizePositive(-2PI)</term><description>0.0</description></item>
            <item><term>NormalizePositive(-3PI)</term><description><see cref="F:System.Math.PI"/></description></item>
            <item><term>NormalizePositive(-4PI)</term><description>0.0</description></item>
            <item><term>NormalizePositive(PI)</term><description><see cref="F:System.Math.PI"/></description></item>
            <item><term>NormalizePositive(2PI)</term><description>0.0</description></item>
            <item><term>NormalizePositive(3PI)</term><description><see cref="F:System.Math.PI"/></description></item>
            <item><term>NormalizePositive(4PI)</term><description>0.0</description></item>
            </list>
            </summary>
            <remarks></remarks>
            <param name="angle">The angle to normalize, in radians.</param>
            <returns>An equivalent positive angle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Diff(System.Double,System.Double)">
            <summary>
            Computes the unoriented smallest difference between two angles.
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>The angles are assumed to be normalized to the range [-Pi, Pi].</description></item>
            <item><description>The result will be in the range [0, Pi].</description></item>
            </list>
            </remarks>
            <param name="ang1">The angle of one vector (in [-Pi, Pi] )</param>
            <param name="ang2">The angle of the other vector (in range [-Pi, Pi] )</param>
            <returns>The angle (in radians) between the two vectors (in range [0, Pi] )</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.AngleUtility.Project(NetTopologySuite.Geometries.Coordinate,System.Double,System.Double)">
            <summary>
            Projects a point by a given angle and distance.
            </summary>
            <param name="p">The point to project</param>
            <param name="angle">The angle at which to project</param>
            <param name="dist">The distance to project</param>
            <returns>The projected point</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Area">
            <summary>
            Functions for computing area.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Area.OfRing(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the area for a ring.
            </summary>
            <param name="ring">The coordinates forming the ring</param>
            <returns>The area of the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Area.OfRing(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes the area for a ring.
            </summary>
            <param name="ring">The coordinates forming the ring</param>
            <returns>The area of the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Area.OfRingSigned(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the signed area for a ring. The signed area is positive if the
            ring is oriented CW, negative if the ring is oriented CCW, and zero if the
            ring is degenerate or flat.
            </summary>
            <param name="ring">The coordinates forming the ring</param>
            <returns>The signed area of the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Area.OfRingSigned(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes the signed area for a ring. The signed area is positive if the
            <list type="table">
            <listheader>
            <term>value</term>
            <description>meaning</description>
            </listheader>
            <item><term>&gt; 0</term>
            <description>The ring is oriented clockwise (CW)</description></item>
            <item><term>&lt; 0</term>
            <description>The ring is oriented counter clockwise (CCW)</description></item>
            <item><term>== 0</term>
            <description>The ring is degenerate or flat</description></item>
            </list>
            ring is oriented CW, negative if the ring is oriented CCW, and zero if the
            ring is degenerate or flat.
            </summary>
            <param name="ring">The coordinates forming the ring</param>
            <returns>The signed area of the ring</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IBoundaryNodeRule">
            <summary>
            An interface for rules which determine whether node points
            which are in boundaries of <see cref="T:NetTopologySuite.Geometries.ILineal"/> geometry components
            are in the boundary of the parent geometry collection.
            The SFS specifies a single kind of boundary node rule,
            the <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule"/> rule.
            However, other kinds of Boundary Node Rules are appropriate
            in specific situations (for instance, linear network topology
            usually follows the <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule"/>.)
            Some JTS operations
            (such as <see cref="T:NetTopologySuite.Operation.Relate.RelateOp"/>, <see cref="T:NetTopologySuite.Operation.BoundaryOp"/> and <see cref="T:NetTopologySuite.Operation.Valid.IsSimpleOp"/>)
            allow the BoundaryNodeRule to be specified,
            and respect the supplied rule when computing the results of the operation.
            <para/>
            An example use case for a non-SFS-standard Boundary Node Rule is
            that of checking that a set of <see cref="T:NetTopologySuite.Geometries.LineString"/>s have
            valid linear network topology, when turn-arounds are represented
            as closed rings.  In this situation, the entry road to the
            turn-around is only valid when it touches the turn-around ring
            at the single (common) endpoint.  This is equivalent
            to requiring the set of <tt>LineString</tt>s to be
            <b>simple</b> under the <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule"/>.
            The SFS-standard <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule"/> is not
            sufficient to perform this test, since it
            states that closed rings have <b>no</b> boundary points.
            <para/>
            This interface and its subclasses follow the <tt>Strategy</tt> design pattern.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Operation.Relate.RelateOp"/>
            <seealso cref="T:NetTopologySuite.Operation.BoundaryOp"/>
            <seealso cref="T:NetTopologySuite.Operation.Valid.IsSimpleOp"/>
            <seealso cref="T:NetTopologySuite.Algorithm.PointLocator"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IBoundaryNodeRule.IsInBoundary(System.Int32)">
            <summary>
            Tests whether a point that lies in <c>boundaryCount</c>
            geometry component boundaries is considered to form part of the boundary
            of the parent geometry.
            </summary>
            <param name="boundaryCount">boundaryCount the number of component boundaries that this point occurs in</param>
            <returns>true if points in this number of boundaries lie in the parent boundary</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.BoundaryNodeRules">
            <summary>
            Provides access to static instances of common <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>s.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryRule">
            <summary>
            The Mod-2 Boundary Node Rule (which is the rule specified in the OGC SFS).
            </summary>
            <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule"/>
        </member>
        <member name="F:NetTopologySuite.Algorithm.BoundaryNodeRules.EndpointBoundaryRule">
            <summary>The Endpoint Boundary Node Rule.</summary>
            <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule"/>
        </member>
        <member name="F:NetTopologySuite.Algorithm.BoundaryNodeRules.MultivalentEndpointBoundaryRule">
            <summary>The MultiValent Endpoint Boundary Node Rule.</summary>
            <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.MultiValentEndPointBoundaryNodeRule"/>
        </member>
        <member name="F:NetTopologySuite.Algorithm.BoundaryNodeRules.MonoValentEndpointBoundaryRule">
            <summary>The Monovalent Endpoint Boundary Node Rule.</summary>
            <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.MonoValentEndPointBoundaryNodeRule"/>
        </member>
        <member name="F:NetTopologySuite.Algorithm.BoundaryNodeRules.OgcSfsBoundaryRule">
            <summary>
            The Boundary Node Rule specified by the OGC Simple Features Specification,
            which is the same as the Mod-2 rule.
            </summary>
            <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule"/>
        </member>
        <member name="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule">
            <summary>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> specifies that points are in the
            boundary of a lineal geometry if
            the point lies on the boundary of an odd number
            of components.
            Under this rule <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s and closed
            <see cref="T:NetTopologySuite.Geometries.LineString"/>s have an empty boundary.
            </summary>
            <remarks>
            This is the rule specified by the <i>OGC SFS</i>,
            and is the default rule used in JTS.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule">
            <summary>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule" /> which specifies that any points which are endpoints
            of lineal components are in the boundary of the
            parent geometry.
            This corresponds to the "intuitive" topological definition
            of boundary.
            Under this rule <see cref="T:NetTopologySuite.Geometries.LinearRing" />s have a non-empty boundary
            (the common endpoint of the underlying LineString).
            </summary>
            <remarks>
            This rule is useful when dealing with linear networks.
            For example, it can be used to check
            whether linear networks are correctly noded.
            The usual network topology constraint is that linear segments may touch only at endpoints.
            In the case of a segment touching a closed segment (ring) at one point,
            the Mod2 rule cannot distinguish between the permitted case of touching at the
            node point and the invalid case of touching at some other interior (non-node) point.
            The EndPoint rule does distinguish between these cases,
            so is more appropriate for use.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Algorithm.BoundaryNodeRules.MultiValentEndPointBoundaryNodeRule">
            <summary>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> which determines that only
            endpoints with valency greater than 1 are on the boundary.
            This corresponds to the boundary of a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>
            being all the "attached" endpoints, but not
            the "unattached" ones.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Algorithm.BoundaryNodeRules.MonoValentEndPointBoundaryNodeRule">
            <summary>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> which determines that only
            endpoints with valency of exactly 1 are on the boundary.
            This corresponds to the boundary of a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>
            being all the "unattached" endpoints.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Centroid">
            <summary>
            Computes the centroid of a <see cref="T:NetTopologySuite.Geometries.Geometry"/> of any dimension.
            For collections the centroid is computed for the collection of
            non-empty elements of highest dimension.
            The centroid of an empty geometry is <c>null</c>
            </summary>
            <remarks>
            <h3>Algorithm</h3>
            <list type="bullet">
            <item><description><b>Dimension 2</b> - the centroid ic computed
            as a weighted sum of the centroids
            of a decomposition of the area into (possibly overlapping) triangles.
            Holes and multipolygons are handled correctly.
            See <c>http://www.faqs.org/faqs/graphics/algorithms-faq/</c>
            for further details of the basic approach.</description></item>
            <item><description><b>Dimension 1</b> - Computes the average of the midpoints
            of all line segments weighted by the segment length.
            Zero-length lines are treated as points.
            </description></item>
            <item><description><b>Dimension 0</b> - Compute the average coordinate over all points.
            Repeated points are all included in the average
            </description></item>
            </list>
            If the input geometries are empty, a <c>null</c> Coordinate is returned.
            </remarks>
            <see cref="T:NetTopologySuite.Algorithm.InteriorPoint"/>
            <see cref="T:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle"/>
            <see cref="T:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle"/>
            <version>1.7</version>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.GetCentroid(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the centroid point of a geometry.
            </summary>
            <param name="geom">The geometry to use</param>
            <returns>
            The centroid point, or null if the geometry is empty
            </returns>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Centroid._areaBasePt">
            <summary>
            the point all triangles are based at
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Centroid._triangleCent3">
            <summary>
            temporary variable to hold centroid of triangle
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Centroid._areasum2">
            <summary>
            Partial area sum
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Centroid._cg3">
            <summary>
            partial centroid sum
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new instance for computing the centroid of a geometry
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to the centroid total.
            </summary>
            <param name="geom">>The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.GetCentroid">
            <summary>
            Gets the computed centroid.
            </summary>
            <returns>The computed centroid, or null if the input is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.Centroid3(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes three times the centroid of the triangle p1-p2-p3.
            The factor of 3 is
            left in to permit division to be avoided until later.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.Area2(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns twice the signed area of the triangle p1-p2-p3.
            The area is positive if the triangle is oriented CCW, and negative if CW.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.AddLineSegments(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Adds the line segments defined by an array of coordinates
            to the linear centroid accumulators.
            </summary>
            <param name="pts">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Centroid.AddPoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds a point to the point centroid accumulator.
            </summary>
            <param name="pt">A <see cref="T:NetTopologySuite.Geometries.Coordinate"/></param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CGAlgorithms3D">
            <summary>
            Basic computational geometry algorithms
            for geometry and coordinates defined in 3-dimensional Cartesian space.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms3D.Distance(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the distance between the points <paramref name="p0"/> and
            <paramref name="p1"/> in 3D space
            </summary>
            <param name="p0">The first point</param>
            <param name="p1">The second point</param>
            <returns>The distance between the two points</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms3D.DistancePointSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the distance between the point <paramref name="p"/> and the
            segment from <paramref name="A"/> to <paramref name="B"/> in 3D space
            </summary>
            <param name="p">The point</param>
            <param name="A">The start point of the segment</param>
            <param name="B">The end point of the segment</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms3D.DistanceSegmentSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the distance between two 3D segments.</summary>
            <param name="A">The start point of the first segment</param>
            <param name="B">The end point of the first segment</param>
            <param name="C">The start point of the second segment</param>
            <param name="D">The end point of the second segment</param>
            <returns>The distance between the segments</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CGAlgorithmsDD">
            <summary>
            Implements basic computational geometry algorithms using <seealso cref="T:NetTopologySuite.Mathematics.DD"/> arithmetic.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.OrientationIndex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the index of the direction of the point <c>q</c> relative to
            a vector specified by <c>p1-p2</c>.
            </summary>
            <param name="p1">The origin point of the vector</param>
            <param name="p2">The final point of the vector</param>
            <param name="q">the point to compute the direction to</param>
            <returns>
            <list type="bullet">
            <item><description><c>1</c> if q is counter-clockwise (left) from p1-p2</description></item>
            <item><description><c>-1</c> if q is clockwise (right) from p1-p2</description></item>
            <item><description><c>0</c> if q is collinear with p1-p2</description></item></list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.OrientationIndex(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the index of the direction of the point <c>q</c> relative to
            a vector specified by <c>p1-p2</c>.
            </summary>
            <param name="p1x">The x-ordinate of the origin point of the vector</param>
            <param name="p1y">The y-ordinate of the origin point of the vector</param>
            <param name="p2x">The x-ordinate of the final point of the vector</param>
            <param name="p2y">The y-ordinate of the final point of the vector</param>
            <param name="qx">The x-ordinate of the point to compute the direction to</param>
            <param name="qy">The y-ordinate of the point to compute the direction to</param>
            <returns>
            <list type="bullet">
            <item><description><c>1</c> if q is counter-clockwise (left) from p1-p2</description></item>
            <item><description><c>-1</c> if q is clockwise (right) from p1-p2</description></item>
            <item><description><c>0</c> if q is collinear with p1-p2</description></item></list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.SignOfDet2x2(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Computes the sign of the determinant of the 2x2 matrix
            with the given entries.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns>
            <list type="bullet">
            <item><description>-1 if the determinant is negative,</description></item>
            <item><description>1 if the determinant is positive,</description></item>
            <item><description>0 if the determinant is 0.</description></item>
            </list>
            </returns>
        </member>
        <member name="F:NetTopologySuite.Algorithm.CGAlgorithmsDD.DoublePrecisionSafeEpsilon">
            <summary>
            A value which is safely greater than the
            relative round-off error in double-precision numbers
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.OrientationIndexFilter(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            A filter for computing the orientation index of three coordinates.
            <para/>
            If the orientation can be computed safely using standard DP
            arithmetic, this routine returns the orientation index.
            Otherwise, a value i > 1 is returned.
            In this case the orientation index must
            be computed using some other more robust method.
            The filter is fast to compute, so can be used to
            avoid the use of slower robust methods except when they are really needed,
            thus providing better average performance.
            <para/>
            Uses an approach due to Jonathan Shewchuk, which is in the public domain.
            </summary>
            <param name="pax">The x-ordinate of point A</param>
            <param name="pay">The y-ordinate of point A</param>
            <param name="pbx">The x-ordinate of point B</param>
            <param name="pby">The y-ordinate of point B</param>
            <param name="pcx">The x-ordinate of point C</param>
            <param name="pcy">The y-ordinate of point C</param>
            <returns>
            <list type="bullet">
            <item><description>The orientation index if it can be computed safely</description></item>
            <item><description>&gt; 1 if the orientation index cannot be computed safely</description></item>>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes an intersection point between two lines
            using DD arithmetic.
            If the lines are parallel (either identical
            or separate) a null value is returned.
            </summary>
            <param name="p1">An endpoint of line segment 1</param>
            <param name="p2">An endpoint of line segment 1</param>
            <param name="q1">An endpoint of line segment 2</param>
            <param name="q2">An endpoint of line segment 2</param>
            <returns>An intersection point if one exists, or <c>null</c> if lines are parallel.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle">
            <summary>
            Constructs the Largest Empty Circle for a set
            of obstacle geometries, up to a specified tolerance.
            The obstacles are point and line geometries.
            <para/>
            The Largest Empty Circle is the largest circle which
            has its center in the convex hull of the obstacles (the <i>boundary</i>),
            and whose interior does not intersect with any obstacle.
            The circle center is the point in the interior of the boundary
            which has the farthest distance from the obstacles (up to tolerance).
            The circle is determined by the center point
            and a point lying on an obstacle indicating the circle radius.
            <para/>
            The implementation uses a successive-approximation technique
            over a grid of square cells covering the obstacles and boundary.
            The grid is refined using a branch-and-bound algorithm.
            Point containment and distance are computed in a performant
            way by using spatial indexes.
            <para/>
            <h3>Future Enhancements</h3>
            <list type="bullet">
            <item><description>Support polygons as obstacles</description></item>
            <item><description>Support a client-defined boundary polygon</description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
            <see cref="T:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle"/>
            <see cref="T:NetTopologySuite.Algorithm.InteriorPoint"/>
            <see cref="T:NetTopologySuite.Algorithm.Centroid"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.GetCenter(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the center point of the Largest Empty Circle
            within a set of obstacles, up to a given tolerance distance.
            </summary>
            <param name="obstacles">A geometry representing the obstacles (points and lines)</param>
            <param name="tolerance">The distance tolerance for computing the center point</param>
            <returns>The center point of the Largest Empty Circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.GetRadiusLine(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a radius line of the Largest Empty Circle
            within a set of obstacles, up to a given distance tolerance.
            </summary>
            <param name="obstacles">A geometry representing the obstacles (points and lines)</param>
            <param name="tolerance">The distance tolerance for computing the center point</param>
            <returns>A line from the center of the circle to a point on the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.#ctor(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates a new instance of a Largest Empty Circle construction.
            </summary>
            <param name="obstacles">A geometry representing the obstacles (points and lines)</param>
            <param name="tolerance">The distance tolerance for computing the center point</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.SetBoundary(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets the area boundary as the convex hull
            of the obstacles.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.GetCenter">
            <summary>
            Gets the center point of the Largest Empty Circle
            (up to the tolerance distance).
            </summary>
            <returns>The center point of the Largest Empty Circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.GetRadiusPoint">
            <summary>
            Gets a point defining the radius of the Largest Empty Circle.
            This is a point on the obstacles which is
            nearest to the computed center of the Largest Empty Circle.
            The line segment from the center to this point
            is a radius of the constructed circle, and this point
            lies on the boundary of the circle.
            </summary>
            <returns>A point defining the radius of the Largest Empty Circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.GetRadiusLine">
            <summary>
            Gets a line representing a radius of the Largest Empty Circle.
            </summary>
            <returns>A line from the center of the circle to a point on the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.DistanceToConstraints(NetTopologySuite.Geometries.Point)">
            <summary>
            Computes the signed distance from a point to the constraints
            (obstacles and boundary).
            Points outside the boundary polygon are assigned a negative distance.
            Their containing cells will be last in the priority queue
            (but will still end up being tested since they may be refined).
            </summary>
            <param name="p">The point to compute the distance for</param>
            <returns>The signed distance to the constraints (negative indicates outside the boundary)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.MayContainCircleCenter(NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.Cell)">
            <summary>
            Tests whether a cell may contain the circle center,
            and thus should be refined (split into subcells
            to be investigated further.)
            </summary>
            <param name="cell">The cell to test</param>
            <returns><c>true</c> if the cell might contain the circle center</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.CreateInitialGrid(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Utilities.PriorityQueue{NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.Cell})">
            <summary>
            Initializes the queue with a grid of cells covering
            the extent of the area.
            </summary>
            <param name="env">The area extent to cover</param>
            <param name="cellQueue">The queue to initialize</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.Cell">
            <summary>
            A square grid cell centered on a given point
            with a given side half-length,
            and having a given distance from the center point to the constraints.
            The maximum possible distance from any point in the cell to the
            constraints can be computed.
            This is used as the ordering and upper-bound function in
            the branch-and-bound algorithm. 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle">
            <summary>
            Constructs the Maximum Inscribed Circle for a
            polygonal <see cref="T:NetTopologySuite.Geometries.Geometry"/>, up to a specified tolerance.
            The Maximum Inscribed Circle is determined by a point in the interior of the area
            which has the farthest distance from the area boundary,
            along with a boundary point at that distance.
            <para/>
            In the context of geography the center of the Maximum Inscribed Circle
            is known as the <b>Pole of Inaccessibility</b>.
            A cartographic use case is to determine a suitable point
            to place a map label within a polygon.
            <para/>
            The radius length of the Maximum Inscribed Circle is a
            measure of how "narrow" a polygon is. It is the
            distance at which the negative buffer becomes empty.
            <para/>
            The class supports polygons with holes and multipolygons.
            <para/>
            The implementation uses a successive-approximation technique
            over a grid of square cells covering the area geometry.
            The grid is refined using a branch-and-bound algorithm.
            Point containment and distance are computed in a performant
            way by using spatial indexes.
            <h3>Future Enhancements</h3>
            <list type="bullet">
            <item><description>Support a polygonal constraint on placement of center</description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
            <see cref="T:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle"/>
            <see cref="T:NetTopologySuite.Algorithm.InteriorPoint"/>
            <see cref="T:NetTopologySuite.Algorithm.Centroid"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.GetCenter(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the center point of the Maximum Inscribed Circle
            of a polygonal geometry, up to a given tolerance distance.
            </summary>
            <param name="polygonal">A polygonal geometry</param>
            <param name="tolerance">The distance tolerance for computing the center point</param>
            <returns>The center point of the maximum inscribed circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.GetRadiusLine(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a radius line of the Maximum Inscribed Circle
            of a polygonal geometry, up to a given tolerance distance.
            </summary>
            <param name="polygonal">A polygonal geometry</param>
            <param name="tolerance">The distance tolerance for computing the center point</param>
            <returns>A line from the center to a point on the circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.#ctor(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates a new instance of a Maximum Inscribed Circle computation.
            </summary>
            <param name="polygonal">An areal geometry</param>
            <param name="tolerance">The distance tolerance for computing the centre point
            (must be positive)</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the tolerance is non-positive</exception>
            <exception cref="T:System.ArgumentException">Thrown if the input geometry is non-polygonal or empty</exception>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.GetCenter">
            <summary>
            Gets the center point of the maximum inscribed circle
            (up to the tolerance distance).</summary>
            <returns>The center point of the maximum inscribed circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.GetRadiusPoint">
            <summary>
            Gets a point defining the radius of the Maximum Inscribed Circle.
            This is a point on the boundary which is
            nearest to the computed center of the Maximum Inscribed Circle.
            The line segment from the center to this point
            is a radius of the constructed circle, and this point
            lies on the boundary of the circle.
            </summary>
            <returns>A point defining the radius of the Maximum Inscribed Circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.GetRadiusLine">
            <summary>
            Gets a line representing a radius of the Largest Empty Circle.
            </summary>
            <returns>A line from the center of the circle to a point on the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.DistanceToBoundary(NetTopologySuite.Geometries.Point)">
            <summary>
            Computes the signed distance from a point to the area boundary.
            Points outside the polygon are assigned a negative distance.
            Their containing cells will be last in the priority queue
            (but may still end up being tested since they may need to be refined).
            </summary>
            <param name="p">The point to compute the distance for</param>
            <returns>The signed distance to the area boundary (negative indicates outside the area)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.CreateInitialGrid(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Utilities.PriorityQueue{NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.Cell})">
            <summary>
            Initializes the queue with a grid of cells covering
            the extent of the area.
            </summary>
            <param name="env">The area extent to cover</param>
            <param name="cellQueue">The queue to initialize</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.Cell">
            <summary>
            A square grid cell centered on a given point
            with a given side half-length,
            and having a given distance from the center point to the constraints.
            The maximum possible distance from any point in the cell to the
            constraints can be computed.
            This is used as the ordering and upper-bound function in
            the branch-and-bound algorithm. 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.ConvexHull">
            <summary>
            Computes the convex hull of a <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            The convex hull is the smallest convex Geometry that contains all the
            points in the input Geometry.
            Uses the Graham Scan algorithm.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.Create(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Computes the convex hull for the given sequence of <see cref="T:NetTopologySuite.Geometries.Geometry"/> instances.
            </summary>
            <param name="geoms">
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> instances whose convex hull to compute.
            </param>
            <returns>
            The convex hull of <paramref name="geoms"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Create a new convex hull construction for the input <c>Geometry</c>.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create a new convex hull construction for the input <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array.
            </summary>
            <param name="pts"></param>
            <param name="geomFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.GetConvexHull">
            <summary>
            Returns a <c>Geometry</c> that represents the convex hull of the input point.
            The point will contain the minimal number of points needed to
            represent the convex hull.  In particular, no more than two consecutive
            points will be collinear.
            </summary>
            <returns>
            If the convex hull contains 3 or more points, a <c>Polygon</c>;
            2 points, a <c>LineString</c>;
            1 point, a <c>Point</c>;
            0 points, an empty <c>GeometryCollection</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.Reduce(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Uses a heuristic to reduce the number of points scanned to compute the hull.
            The heuristic is to find a polygon guaranteed to
            be in (or on) the hull, and eliminate all points inside it.
            A quadrilateral defined by the extremal points
            in the four orthogonal directions
            can be used, but even more inclusive is
            to use an octilateral defined by the points in the 8 cardinal directions.
            Note that even if the method used to determine the polygon vertices
            is not 100% robust, this does not affect the robustness of the convex hull.
            <para>
            To satisfy the requirements of the Graham Scan algorithm,
            the returned array has at least 3 entries.
            </para>
            </summary>
            <param name="pts">The coordinates to reduce</param>
            <returns>The reduced array of coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.PreSort(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Pre sorts the coordinates
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.GrahamScan(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.IsBetween(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="c1"></param>
             <param name="c2"></param>
             <param name="c3"></param>
             <returns>
             Whether the three coordinates are collinear
             and c2 lies between c1 and c3 inclusive.
             </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.ComputeOctRing(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.ComputeOctPts(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.LineOrPolygon(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="coordinates"> The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
             <returns>A 2-vertex <c>LineString</c> if the vertices are collinear;
             otherwise, a <c>Polygon</c> with unnecessary (collinear) vertices removed. </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.CleanRing(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="original">The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
             <returns>The coordinates with unnecessary (collinear) vertices removed.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.ConvexHull.RadialComparator">
            <summary>
            Compares <see cref="T:NetTopologySuite.Geometries.Coordinate" />s for their angle and distance
            relative to an origin.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.RadialComparator.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.ConvexHull.RadialComparator"/> class.
            </summary>
            <param name="origin"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.RadialComparator.Compare(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull.RadialComparator.PolarCompare(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <param name="p"></param>
             <param name="q"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.DistanceComputer">
            <summary>
            Functions to compute distance between basic geometric structures.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.DistanceComputer.SegmentToSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the distance from a line segment AB to a line segment CD
            <para/>
            Note: NON-ROBUST!
            </summary>
            <param name="A">The first point of the first line</param>
            <param name="B">The second point of the first line (must be different to A)</param>
            <param name="C">The first point of the second line</param>
            <param name="D">The second point of the second line (must be different to C)</param>
            <returns>The distance from a line segment AB to a line segment CD</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.DistanceComputer.PointToSegmentString(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the distance from a point to a sequence of line segments.
            </summary>
            <param name="p">A point</param>
            <param name="line">A sequence of contiguous line segments defined by their vertices</param>
            <returns>The minimum distance between the point and the line segments</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.DistanceComputer.PointToSegmentString(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes the distance from a point to a sequence of line segments.
            </summary>
            <param name="p">A point</param>
            <param name="line">A sequence of contiguous line segments defined by their vertices</param>
            <returns>The minimum distance between the point and the line segments</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.DistanceComputer.PointToSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the distance from a point p to a line segment AB
            <para/>
            Note: NON-ROBUST!
            </summary>
            <param name="p">The point to compute the distance for</param>
            <param name="A">The first point of the first line</param>
            <param name="B">The second point of the first line (must be different to A)</param>
            <returns>The distance from p to line segment AB</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.DistanceComputer.PointToLinePerpendicular(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the perpendicular distance from a point p to the (infinite) line
            containing the points AB
            </summary>
            <param name="p">The point to compute the distance for</param>
            <param name="A">The first point of the first line</param>
            <param name="B">The second point of the first line (must be different to A)</param>
            <returns>The perpendicular distance from p to line segment AB</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance">
            <summary>
            The Frchet distance is a measure of similarity between curves. Thus, it can
            be used like the Hausdorff distance.
            <para/>
            An analogy for the Frchet distance taken from
            <a href="http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf">
            Computing Discrete Frchet Distance</a>:
            <pre>
            A man is walking a dog on a leash: the man can move
            on one curve, the dog on the other; both may vary their
            speed, but backtracking is not allowed.
            </pre>
            </summary>
            <remarks>
            Its metric is better than the Hausdorff distance
            because it takes the directions of the curves into account.
            It is possible that two curves have a small Hausdorff but a large
            Frchet distance.
            <para/>
            This implementation is based on the following optimized Frchet distance algorithm:
            <pre>Thomas Devogele, Maxence Esnault, Laurent Etienne. Distance discrte de Frchet optimise. Spatial
            Analysis and Geomatics (SAGEO), Nov 2016, Nice, France. hal-02110055</pre>
            <para/>
            Several matrix storage implementations are provided
            <para/>
            Additional information:
            <list type="bullet">
            <item><description><a href="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">Frchet distance</a></description></item>
            <item><description><a href="http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf">Computing Discrete Frchet Distance</a></description></item>
            <item><description><a href="https://hal.archives-ouvertes.fr/hal-02110055/document">Distance discrte de Frchet optimise</a></description></item>
            <item><description><a href="https://towardsdatascience.com/fast-discrete-fr%C3%A9chet-distance-d6b422a8fb77">Fast Discrete Frchet Distance</a></description></item></list>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the Discrete Frchet Distance between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            using a cartesian distance computation function.
            </summary>
            <param name="g0">The 1st geometry</param>
            <param name="g1">The 2nd geometry</param>
            <returns>The cartesian distance between <paramref name="g0"/> and <paramref name="g1"/></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an instance of this class using the provided geometries.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.Distance">
            <summary>
            Computes the <c>Discrete Frchet Distance</c> between the input geometries
            </summary>
            <returns>The Discrete Frchet Distance</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CreateMatrixStorage(System.Int32,System.Int32)">
            <summary>
            Creates a matrix to store the computed distances
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <returns>A matrix storage</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.Coordinates">
            <summary>
            Gets the pair of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s at which the distance is obtained.
            </summary>
            <returns>The pair of <c>Coordinate</c>s at which the distance is obtained</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.ComputeFrechet(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[],System.Int32[],NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage,System.Collections.Generic.Dictionary{System.Double,System.Int32[]})">
            <summary>
            Computes the Frchet Distance for the given distance matrix.
            </summary>
            <param name="coords0">An array of <c>Coordinate</c>s</param>
            <param name="coords1">An array of <c>Coordinate</c>s</param>
            <param name="diagonal">An array of alternating col/row index values for the diagonal of the distance matrix</param>
            <param name="distances">The distance matrix</param>
            <param name="distanceToPair">A lookup for coordinate pairs based on a distance</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.GetMinDistanceAtCorner(NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage,System.Int32,System.Int32)">
            <summary>
            Returns the minimum distance at the corner (<paramref name="i"/>, <paramref name="j"/>}).
            </summary>
            <param name="matrix">A (sparse) matrix</param>
            <param name="i">The row index</param>
            <param name="j">The column index</param>
            <returns>The minimum distance</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.ComputeCoordinateDistances(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[],System.Int32[],NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage,System.Collections.Generic.Dictionary{System.Double,System.Int32[]})">
            <summary>
            Computes relevant distances between pairs of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s for the
            computation of the <c>Discrete Frchet Distance</c>.
            </summary>
            <param name="coords0">An array of <c>Coordinate</c>s</param>
            <param name="coords1">An array of <c>Coordinate</c>s</param>
            <param name="diagonal">An array of alternating col/row index values for the diagonal of the distance matrix</param>
            <param name="distances">The distance matrix</param>
            <param name="distanceToPair">A lookup for coordinate pairs based on a distance</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.BresenhamDiagonal(System.Int32,System.Int32)">
            <summary>
            Computes the indices for the diagonal of a <c>numCols x numRows</c> grid
            using the <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">
            Bresenham's line algorithm</a>.
            </summary>
            <param name="numCols">The number of columns</param>
            <param name="numRows">The number of rows</param>
            <returns>A packed array of column and row indices.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage">
            <summary>
            Abstract base class for storing 2d matrix data
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.NumRows">
            <summary>
            Gets a value indicating the number of rows
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.NumCols">
            <summary>
            Gets a value indicating the number of columns
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.DefaultValue">
            <summary>
            Gets a value indicating the default value
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>Creates an instance of this class</summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <param name="defaultValue">A default value</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a value for the cell <paramref name="i"/>, <paramref name="j"/>
            </summary>
            <param name="i">The row index</param>
            <param name="j">The column index</param>
            <returns>The value of the cell <paramref name="i"/>, <paramref name="j"/></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.IsValueSet(System.Int32,System.Int32)">
            <summary>
            Gets a flag indicating if the matrix has a set value, e.g. one that is different
            than <see cref="P:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.MatrixStorage.DefaultValue"/>.
            </summary>
            <returns>A flag indicating if the matrix has a set value</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.RectMatrix">
            <summary>Straight forward implementation of a rectangular matrix</summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.RectMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Creates an instance of this matrix using the given number of rows and columns.
            A default value can be specified.
            </summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <param name="defaultValue">A default value</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CsrMatrix">
            <summary>
            A matrix implementation that adheres to the
            <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)">
            Compressed sparse row format</a>.<br/>
            Note: Unfortunately not as fast as expected.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CsrMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Creates an instance of this matrix using the given number of rows and columns.
            A default value can be specified.
            </summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <param name="defaultValue">A default value</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CsrMatrix.#ctor(System.Int32,System.Int32,System.Double,System.Int32)">
            <summary>
            Creates an instance of this matrix using the given number of rows and columns.
            A default value can be specified as well as the number of values expected.
            </summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <param name="defaultValue">A default value</param>
            <param name="expectedValues">The amount of expected values</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CsrMatrix.ExpectedValuesHeuristic(System.Int32,System.Int32)">
            <summary>
            Computes an initial value for the number of expected values
            </summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <returns>The expected number of values in the sparse matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.CsrMatrix.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the column index vector (ci) and value vector (v) are sufficiently large.
            </summary>
            <param name="required">The number of items to store in the matrix</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.HashMapMatrix">
            <summary>
            A sparse matrix based on <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.HashMapMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Creates an instance of this matrix using the given number of rows and columns.
            A default value can be specified.
            </summary>
            <param name="numRows">The number of rows</param>
            <param name="numCols">The number of columns</param>
            <param name="defaultValue">A default value</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance">
             <summary>
             An algorithm for computing a distance metric
             which is an approximation to the Hausdorff Distance
             based on a discretization of the input <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
             </summary>
             <remarks>
             <para>
             The algorithm computes the Hausdorff distance restricted to discrete points
             for one of the geometries.
             The points can be either the vertices of the geometries (the default),
             or the geometries with line segments densified by a given fraction.
             Also determines two points of the Geometries which are separated by the computed distance.
             </para>
             <para>
             This algorithm is an approximation to the standard Hausdorff distance.
             Specifically,
             <code>
             for all geometries a, b:    DHD(a, b) &lt;= HD(a, b)
             </code>
             The approximation can be made as close as needed by densifying the input geometries.
             In the limit, this value will approach the true Hausdorff distance:
             <code>
             DHD(A, B, densifyFactor) -> HD(A, B) as densifyFactor -> 0.0
             </code>
             The default approximation is exact or close enough for a large subset of useful cases.
             </para>
             <para>
             Examples of these are:
             <list type="bullet">
             <item><description>
             computing distance between <c>Linestring</c>s that are roughly parallel to each other,
             and roughly equal in length.  This occurs in matching linear networks.
             </description></item>
             <item><description>Testing similarity of geometries.</description></item>
             </list>
             </para>
             <para>
             An example where the default approximation is not close is:
             <code>
             A = LINESTRING (0 0, 100 0, 10 100, 10 100)
             B = LINESTRING (0 100, 0 10, 80 10)
            
             DHD(A, B) = 22.360679774997898
             HD(A, B) ~= 47.8
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the Discrete Hausdorff Distance of two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
            <returns>The Discrete Hausdorff Distance</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the Discrete Hausdorff Distance of two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
            <param name="densifyFraction">The densify fraction. A value of 0 indicates, that no densification should take place</param>
            <returns>The Discrete Hausdorff Distance</returns>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance._densifyFrac">
            <summary>
            Value of 0.0 indicates that no densification should take place
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an instance of this class using the provided geometries
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">Another geometry</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.DensifyFraction">
            <summary>
            Gets or sets the fraction by which to densify each segment.
            </summary>
            <remarks>
            Each segment will be (virtually) split into a number of equal-length
            sub-segments, whose fraction of the total length is closest
            to the given fraction.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.Distance">
            <summary>
            Computes the discrete hausdorff distance between the two assigned geometries.
            </summary>
            <returns>The discrete hausdorff distance</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.OrientedDistance">
            <summary>
            Computes the discrete hausdorff distance between the 1st and the 2nd assigned geometry
            </summary>
            <returns>The discrete hausdorff distance.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.Coordinates">
            <summary>
            Gets a value indicating the 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter">
            <summary>
            A coordinate filter that computes the maximum <see cref="T:NetTopologySuite.Algorithm.Distance.PointPairDistance"/> between points of
            an assigned <c>Geometry</c> and all filtered geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="geom">A geometry</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.ICoordinateFilter.Filter(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.MaxPointDistance">
            <summary>
            Gets a value indicating the maximum distance between
            an assigned <c>Geometry</c> and the filtered one.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter">
            <summary>
            A coordinate filter that computes the maximum <see cref="T:NetTopologySuite.Algorithm.Distance.PointPairDistance"/> between points of
            an assigned <c>Geometry</c> and all filtered geometries. The filtered geometries' line segments
            are 
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.#ctor(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates an instance of this filter class
            </summary>
            <param name="geom">The geometry to densify</param>
            <param name="fraction">The densification fraction</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.ICoordinateSequenceFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)"/>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.GeometryChanged">
            <inheritdoc cref="P:NetTopologySuite.Geometries.ICoordinateSequenceFilter.GeometryChanged"/>
            <returns>As this filter does not change the geometry, the return value is always <c>false</c></returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.Done">
            <inheritdoc cref="P:NetTopologySuite.Geometries.ICoordinateSequenceFilter.Done"/>
            <returns>As this filter does not end prematurely, the return value is always <c>false</c></returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.MaxPointDistance">
            <summary>
            Gets a value indicating the maximum distance between p
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.DistanceToPoint">
            <summary>
            Computes the Euclidean distance (L2 metric) from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> to a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <remarks>
            Also computes two points on the geometry which are separated by the distance found.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DistanceToPoint.ComputeDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Computes the Euclidean distance (L2 metric) from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> to a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The geometry</param>
            <param name="pt">The Point</param>
            <param name="ptDist">The <c>PointPairDistance</c></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DistanceToPoint.ComputeDistance(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Computes the Euclidean distance (L2 metric) from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> to a <see cref="T:NetTopologySuite.Geometries.LineString"/>.
            </summary>
            <param name="line">The <c>LineString</c></param>
            <param name="pt">The Point</param>
            <param name="ptDist">The <c>PointPairDistance</c></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DistanceToPoint.ComputeDistance(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Computes the Euclidean distance (L2 metric) from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> to a <see cref="T:NetTopologySuite.Geometries.LineSegment"/>.
            </summary>
            <param name="segment">The <c>LineSegment</c></param>
            <param name="pt">The Point</param>
            <param name="ptDist">The <c>PointPairDistance</c></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DistanceToPoint.ComputeDistance(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Computes the Euclidean distance (L2 metric) from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> to a <see cref="T:NetTopologySuite.Geometries.Polygon"/>.
            </summary>
            <param name="poly">The <c>Polygon</c></param>
            <param name="pt">The Point</param>
            <param name="ptDist">The <c>PointPairDistance</c></param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Distance.PointPairDistance">
            <summary>
            Contains a pair of points and the distance between them.
            </summary>
            <remarks>
            Provides methods to update with a new point pair with either maximum or minimum distance.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.Initialize">
            <summary>
            Initializes this instance to null.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.Initialize(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Initializes the points, computing the distance between them.
            </summary>
            <param name="p0">1st coordinate</param>
            <param name="p1">2nd coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.Initialize(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Initializes the points, avoiding recomputing the distance.
            </summary>
            <param name="p0">1st coordinate</param>
            <param name="p1">2nd coordinate</param>
            <param name="distance">the distance between <see paramref="p0"/> and <see paramref="p1"/></param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Distance">
            <summary>
            The distance between the paired coordinates
            </summary>
            <returns>The distance between the paired coordinates</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Coordinates">
            <summary>
            Gets a value indicating the paired coordinates.
            </summary>
            <returns>An array containing the paired points</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Item(System.Int32)">
            <summary>
            Gets the value of one of the paired points
            </summary>
            <param name="i">An index, valid are [0, 1].</param>
            <returns>The <c>Coordinate</c> at index <c>i</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.SetMaximum(NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Updates <c>this</c> <c>PointPairDistance</c> if <paramref name="ptDist"/>
            has greater <see cref="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Distance"/> than <c>this</c> instance.
            </summary>
            <param name="ptDist">The <c>PointPairDistance</c> to test.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.SetMaximum(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Updates <c>this</c> <c>PointPairDistance</c> if the distance between
            <paramref name="p0"/> and <paramref name="p1"/> is greater than the
            <see cref="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Distance"/> of <c>this</c> instance.
            </summary>
            <param name="p0">The 1st point's coordinate</param>
            <param name="p1">The 2nd point's coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.SetMinimum(NetTopologySuite.Algorithm.Distance.PointPairDistance)">
            <summary>
            Updates <c>this</c> <c>PointPairDistance</c> if <paramref name="ptDist"/>
            has a smaller <see cref="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Distance"/> than <c>this</c> instance.
            </summary>
            <param name="ptDist">The <c>PointPairDistance</c> to test.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.SetMinimum(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Updates <c>this</c> <c>PointPairDistance</c> if the distance between
            <paramref name="p0"/> and <paramref name="p1"/> is smaller than the
            <see cref="P:NetTopologySuite.Algorithm.Distance.PointPairDistance.Distance"/> of <c>this</c> instance.
            </summary>
            <param name="p0">The 1st point's coordinate</param>
            <param name="p1">The 2nd point's coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.PointPairDistance.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Algorithm.HCoordinate">
            <summary>
            Represents a homogeneous coordinate in a 2-D coordinate space.
            In NTS <see cref="T:NetTopologySuite.Algorithm.HCoordinate"/>s are used as a clean way
            of computing intersections between line segments.
            </summary>
            <author>David Skea</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the (approximate) intersection point between two line segments using homogeneous coordinates.
            </summary>
            <remarks>
            Note that this algorithm is
            not numerically stable; i.e. it can produce intersection points which
            lie outside the envelope of the line segments themselves.  In order
            to increase the precision of the calculation input points should be normalized
            before passing them to this routine.
            </remarks>
            <param name="p1">1st Coordinate of 1st linesegment</param>
            <param name="p2">2nd Coordinate of 1st linesegment</param>
            <param name="q1">1st Coordinate of 2nd linesegment</param>
            <param name="q2">2nd Coordinate of 2nd linesegment</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.OldIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the (approximate) intersection point between two line segments
            using homogeneous coordinates.
            Note that this algorithm is
            not numerically stable; i.e. it can produce intersection points which
            lie outside the envelope of the line segments themselves.  In order
            to increase the precision of the calculation input points should be normalized
            before passing them to this routine.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor(System.Double,System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <param name="y"></param>
             <param name="w"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor(NetTopologySuite.Algorithm.HCoordinate,NetTopologySuite.Algorithm.HCoordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.GetX">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.GetY">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.HCoordinate.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a homogeneous coordinate which is the intersection of the lines <see cref="P:NetTopologySuite.Algorithm.HCoordinate.Coordinate"/>s.
            define by the homogeneous coordinates represented by two
            </summary>
            <param name="p1">A coordinate</param>
            <param name="p2">A coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.HCoordinate.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Hull.ConcaveHull">
            <summary>
            Constructs a concave hull of a set of points.
            A concave hull is a possibly non-convex polygon containing all the input points.
            A given set of points has a sequence of hulls of increasing concaveness,
            determined by a numeric target parameter.
            <para/>
            The concave hull is constructed by removing the longest outer edges
            of the Delaunay Triangulation of the points,
            until the target criterion parameter is reached.
            <para/>
            The target criteria are:
            <list type="table">
            <item><term>Maximum Edge Length Ratio</term><description>the length of the longest edge of the hull is no larger
            than this value.</description></item>
            <item><term>Maximum Edge Length Factor</term><description>determine the Maximum Edge Length
            as a fraction of the difference between the longest and shortest edge lengths
            in the Delaunay Triangulation.
            This normalizes the <b>Maximum Edge Length</b> to be scale-free.
            A value of 1 produces the convex hull; a value of 0 produces maximum concaveness.</description></item>
            </list>
            The preferred criterion is the <b>Maximum Edge Length Ratio</b>, since it is
            scale-free and local(so that no assumption needs to be made about the
            total amount of concaveness present).
            Other length criteria can be used by setting the Maximum Edge Length directly.
            For example, use a length relative to the longest edge length
            in the Minimum Spanning Tree of the point set.
            Or, use a length derived from the <see cref="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.UniformGridEdgeLength(NetTopologySuite.Geometries.Geometry)"/> value.
            <para/>
            The computed hull is always a single connected <see cref="T:NetTopologySuite.Geometries.Polygon"/>
            (unless it is degenerate, in which case it will be a <see cref="T:NetTopologySuite.Geometries.Point"/> or a <see cref="T:NetTopologySuite.Geometries.LineString"/>).
            This constraint may cause the concave hull to fail to meet the target criteria.
            <para/>
            Optionally the concave hull can be allowed to contain holes.
            Note that when using the area-based criterion
            this may result in substantially slower computation.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.UniformGridEdgeLength(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the approximate edge length of
            a uniform square grid having the same number of
            points as a geometry and the same area as its convex hull.
            This value can be used to determine a suitable length threshold value
            for computing a concave hull.
            A value from 2 to 4 times the uniform grid length
            seems to produce reasonable results.
            </summary>
            <param name="geom">A geometry</param>
            <returns>The approximate uniform grid length</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.ConcaveHullByLength(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the concave hull of the vertices in a geometry
            using the target criterion of maximum edge length.
            </summary>
            <param name="geom">The input geometry</param>
            <param name="maxLength">The target maximum edge length</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.ConcaveHullByLength(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean)">
            <summary>
            Computes the concave hull of the vertices in a geometry
            using the target criterion of maximum edge length,
            and optionally allowing holes.
            </summary>
            <param name="geom">The input geometry</param>
            <param name="maxLength">The target maximum edge length</param>
            <param name="isHolesAllowed">A flag whether holes are allowed in the result</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.ConcaveHullByLengthRatio(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the concave hull of the vertices in a geometry
            using the target criterion of maximum edge length ratio.
            The edge length ratio is a fraction of the length difference
            between the longest and shortest edges
            in the Delaunay Triangulation of the input points. 
            </summary>
            <param name="geom">The input geometry</param>
            <param name="lengthRatio">The target edge length ratio</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.ConcaveHullByLengthRatio(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean)">
            <summary>
            Computes the concave hull of the vertices in a geometry
            using the target criterion of maximum edge length ratio,
            and optionally allowing holes.
            The edge length factor is a fraction of the length difference
            between the longest and shortest edges
            in the Delaunay Triangulation of the input points. 
            </summary>
            <param name="geom">The input geometry</param>
            <param name="lengthRatio">The target edge length ratio</param>
            <param name="isHolesAllowed">A flag whether holes are allowed in the result</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new instance for a given geometry.
            </summary>
            <param name="geom">The input geometry</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHull.MaximumEdgeLength">
            <summary>Gets or sets the target maximum edge length for the concave hull.
            The length value must be zero or greater.
            <list type="bullet">
            <item><description>The value 0.0 produces the concave hull of smallest area
            that is still connected.</description></item>
            <item><description>Larger values produce less concave results.
            A value equal or greater than the longest Delaunay Triangulation edge length
            produces the convex hull.</description></item>
            </list>
            The <see cref="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.UniformGridEdgeLength(NetTopologySuite.Geometries.Geometry)"/> value may be used as
            the basis for estimating an appropriate target maximum edge length.
            </summary>
            <seealso cref="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.UniformGridEdgeLength(NetTopologySuite.Geometries.Geometry)"/>
            <returns>The target maximum edge length for the concave hull</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHull.MaximumEdgeLengthRatio">
            <summary>
            Gets or sets the target maximum edge length ratio for the concave hull.
            The edge length ratio is a fraction of the difference
            between the longest and shortest edge lengths
            in the Delaunay Triangulation of the input points.
            It is a value in the range 0 to 1.
            <list type="bullet">
            <item><description>The value 0.0 produces a concave hull of minimum area
            that is still connected.</description></item>
            <item><description>The value 1.0 produces the convex hull.</description></item>
            </list> 
            </summary>
            <returns>The target maximum edge length factor for the concave hull</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHull.HolesAllowed">
            <summary>
            Gets or sets whether holes are allowed in the concave hull polygon.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.GetHull">
            <summary>
            Gets the computed concave hull.
            </summary>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.ComputeHull(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>Computes the concave hull using edge length as the target criteria.
            </summary>
            <remarks>
            The erosion is done in two phases: first the border, then any
            internal holes (if required).
            This allows an fast connection check to be used
            when eroding holes,
            which makes this much more efficient than the area-based algorithm.
            </remarks>
            <param name="triList">The triangulation</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.AddBorderTri(NetTopologySuite.Algorithm.Hull.HullTri,NetTopologySuite.Utilities.PriorityQueue{NetTopologySuite.Algorithm.Hull.HullTri})">
            <summary>
            Adds a Tri to the queue.
            Only add tris with a single border edge,
            sice otherwise that would risk isolating a vertex.
            Sets the ordering size to the length of the border edge.
            </summary>
            <param name="tri">The Tri to add</param>
            <param name="queue">The priority queue to add to</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.FindCandidateHoles(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri},System.Double)">
            <summary>
            Finds tris which may be the start of holes.
            </summary>
            <remarks>
            Only tris which have a long enough edge and which do not touch the current hull
            boundary are included.<br/>
            This avoids the risk of disconnecting the result polygon.
            The list is sorted in decreasing order of edge length.
            </remarks>
            <param name="triList">The triangulation</param>
            <param name="minEdgeLen">The minimum length of edges to consider</param>
            <returns>A list of candidate tris that may start a hole</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHull.RemoveHole(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri},NetTopologySuite.Algorithm.Hull.HullTri)">
            <summary>
            Erodes a hole starting at a given triangle,
            and eroding all adjacent triangles with boundary edge length above target.
            </summary>
            <param name="triList">The triangulation</param>
            <param name="triHole">A tri which is a hole</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons">
            <summary>
            Constructs a concave hull of a set of polygons, respecting
            the polygons as constraints.
            A concave hull is a possibly non-convex polygon containing all the input polygons.
            A given set of polygons has a sequence of hulls of increasing concaveness,
            determined by a numeric target parameter.
            The computed hull "fills the gap" between the polygons,
            and does not intersect their interior.
            <para/>
            The concave hull is constructed by removing the longest outer edges
            of the Delaunay Triangulation of the space between the polygons,
            until the target criterion parameter is reached.
            <para/>
            The target criteria are:
            <list type="bullet">
            <item><term>Maximum Edge Length</term><description>the length of the longest edge between the polygons is no larger
            than this value.</description></item>
            <item><term>Maximum Edge Length Ratio</term><description>determine the Maximum Edge Length
            as a fraction of the difference between the longest and shortest edge lengths
            between the polygons.
            This normalizes the <b>Maximum Edge Length</b> to be scale-free.
            A value of 1 produces the convex hull; a value of 0 produces the original polygons.</description></item>
            </list>
            The preferred criterion is the <b>Maximum Edge Length Ratio</b>, since it is
            scale-free and local (so that no assumption needs to be made about the
            total amount of concaveness present).
            <para/>
            Optionally the concave hull can be allowed to contain holes, via
            <see cref="P:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.HolesAllowed"/>.
            <para/>
            The hull can be specified as being "tight", which means it follows the outer boundaries
            of the input polygons.
            <para/>
            The input polygons must form a valid MultiPolygon
            (i.e.they must be non - overlapping).
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveHullByLength(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a concave hull of set of polygons
            using the target criterion of maximum edge length.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="maxLength">The target maximum edge length</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveHullByLength(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Computes a concave hull of set of polygons
            using the target criterion of maximum edge length,
            and allowing control over whether the hull boundary is tight
            and can contain holes.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="maxLength">The target maximum edge length</param>
            <param name="isTight">A flag indicating if the hull should be tight to the outside of the polygons</param>
            <param name="isHolesAllowed">A flag indicating if holes are allowed in the hull polygon</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveHullByLengthRatio(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a concave hull of set of polygons
            using the target criterion of maximum edge length ratio.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="lengthRatio">The target maximum edge length ratio</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveHullByLengthRatio(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Computes a concave hull of set of polygons
            using the target criterion of maximum edge length ratio,
            and allowing control over whether the hull boundary is tight
            and can contain holes.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="lengthRatio">The target maximum edge length ratio</param>
            <param name="isTight">A flag indicating if the hull should be tight to the outside of the polygons</param>
            <param name="isHolesAllowed">A flag indicating if holes are allowed in the hull polygon</param>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveFillByLength(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a concave fill area between a set of polygons,
            using the target criterion of maximum edge length.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="maxLength">The target maximum edge length</param>
            <returns>The concave fill</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.ConcaveFillByLengthRatio(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes a concave fill area between a set of polygons,
            using the target criterion of maximum edge length ratio.
            </summary>
            <param name="polygons">The input polygons</param>
            <param name="lengthRatio">The target maximum edge length ratio</param>
            <returns>The concave fill</returns>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons._borderEdgeMap">
            <summary>
            Records the edge index of the longest border edge for border tris,
            so it can be tested for length and possible removal.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new instance for a given geometry.
            </summary>
            <param name="polygons">The input geometry</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.MaximumEdgeLength">
            <summary>
            Gets or sets the target maximum edge length for the concave hull.
            The length value must be zero or greater.
            <list type="bullet">
            <item><description>The value 0.0 produces the input polygons.</description></item>
            <item><description>Larger values produce less concave results.</description></item>
            <item><description>Above a certain large value the result is the convex hull of the input.</description></item>
            </list>
            <para/>
            The edge length ratio provides a scale-free parameter which
            is intended to produce similar concave results for a variety of inputs.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.MaximumEdgeLengthRatio">
            <summary>Gets or sets the target maximum edge length ratio for the concave hull.
            The edge length ratio is a fraction of the difference
            between the longest and shortest edge lengths
            in the Delaunay Triangulation of the area between the input polygons.
            (Roughly speaking, it is a fraction of the difference between
            the shortest and longest distances between the input polygons.)
            It is a value in the range 0 to 1.
            <list type="bullet">
            <item><description>The value 0.0 produces the original input polygons.</description></item>
            <item><description>The value 1.0 produces the convex hull.</description></item>
            </list> 
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.HolesAllowed">
            <summary>
            Gets or sets a flag indicating whether holes are allowed in the concave hull polygon.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.Tight">
            <summary>
            Gets or sets a flag indicating whether the boundary of the hull
            polygon is kept tight to the outer edges of the input polygons.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.GetHull">
            <summary>
            Gets the computed concave hull.
            </summary>
            <returns>The concave hull</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.GetFill">
            <summary>
            Gets the concave fill, which is the area between the input polygons,
            subject to the concaveness control parameter.
            </summary>
            <returns>The concave fill</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.VertexIndex(NetTopologySuite.Triangulate.Tri.Tri,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Get the tri vertex index of some point in a list,
            or -1 if none are vertices.
            </summary>
            <param name="tri">The tri to test for containing a point</param>
            <param name="pts">The points to test</param>
            <returns>The vertex index of a point, or -1</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.IsTouchingSinglePolygon(NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Tests whether a triangle touches a single polygon at all vertices.
            If so, it is a candidate for removal if the hull polygon
            is being kept tight to the outer boundary of the input polygons.
            Tris which touch more than one polygon are called "bridging".
            </summary>
            <param name="tri"></param>
            <returns><c>true</c> if the tri touches a single polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.AddBorderTri(NetTopologySuite.Triangulate.Tri.Tri,System.Int32)">
            <summary>
            Adds an adjacent tri to the current border.
            The adjacent edge is recorded as the border edge for the tri.
            Note that only edges adjacent to another tri can become border edges.
            Since constraint-adjacent edges do not have an adjacent tri,
            they can never be on the border and thus will not be removed
            due to being shorter than the length threshold.
            The tri containing them may still be removed via another edge, however. 
            </summary>
            <param name="tri">The tri adjacent to the tri to be added to the border</param>
            <param name="index">The index of the adjacent tri</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.CreateFrame(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.LinearRing[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a rectangular "frame" around the input polygons,
            with the input polygons as holes in it.
            The frame is large enough that the constrained Delaunay triangulation
            of it should contain the convex hull of the input as edges.
            The frame corner triangles can be removed to produce a
            triangulation of the space around and between the input polygons.
            </summary>
            <param name="polygonsEnv"></param>
            <param name="polygonRings"></param>
            <param name="geomFactory"></param>
            <returns>The frame polygon</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Hull.HullTri">
            <summary>
            Tris which are used to form a concave hull.
            If a Tri has an edge (or edges) with no adjacent tri
            the tri is on the boundary of the triangulation.
            The edge is a boundary edge.
            The union of those edges
            forms the (linear) boundary of the triangulation.
            The triangulation area may be a Polygon or MultiPolygon, and may or may not contain holes.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTri.SetSizeToBoundary">
            <summary>
            Sets the size to be the length of the boundary edges.
            This is used when constructing hull without holes,
            by erosion from the triangulation boundary.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.HullTri.BoundaryIndex">
            <summary>
            Gets an index of a boundary edge, if there is one.
            </summary>
            <returns>A boundary edge index, or -1</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.HullTri.BoundaryIndexCCW">
            <summary>
            Gets the most CCW boundary edge index.
            This assumes there is at least one non-boundary edge.
            </summary>
            <returns>The CCW boundary edge index</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.HullTri.BoundaryIndexCW">
            <summary>
            Gets the most CW boundary edge index.
            This assumes there is at least one non-boundary edge.
            </summary>
            <returns>The CW boundary edge index</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.HullTri.IsConnecting">
            <summary>
            Tests if this tri is the only one connecting its 2 adjacents.
            Assumes that the tri is on the boundary of the triangulation
            and that the triangulation does not contain holes
            </summary>
            <returns><c>true</c> if the tri is the only connection</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTri.Adjacent2VertexIndex">
            <summary>
            Gets the index of a vertex which is adjacent to two other tris (if any).
            </summary>
            <returns>The vertex index or -1</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTri.IsolatedVertexIndex(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Tests whether some vertex of this Tri has degree = 1.
            In this case it is not in any other Tris.
            </summary>
            <param name="triList">The triangulation</param>
            <returns><c>true</c> if any vertex of this tri has a degree of 1</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTri.CompareTo(NetTopologySuite.Algorithm.Hull.HullTri)">
            <summary>
            PriorityQueues sort in ascending order.
            To sort with the largest at the head,
            smaller sizes must compare as greater than larger sizes.
            (i.e. the normal numeric comparison is reversed).
            If the sizes are identical (which should be an infrequent case),
            the areas are compared, with larger areas sorting before smaller.
            (The rationale is that larger areas indicate an area of lower point density,
            which is more likely to be in the exterior of the computed shape.)
            This improves the determinism of the queue ordering. 
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Hull.HullTri.HasBoundaryTouch">
            <summary>
            Tests if this tri has a vertex which is in the boundary,
            but not in a boundary edge.
            </summary>
            <returns><c>true</c> if the tri touches the boundary at a vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTri.IsConnected(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri},NetTopologySuite.Algorithm.Hull.HullTri)">
            <summary>
            Tests if a triangulation is edge-connected, if a triangle is removed.<br/>
            NOTE: this is a relatively slow operation.
            </summary>
            <param name="triList">The triangulation</param>
            <param name="exceptTri">The triangle to remove</param>
            <returns><c>true</c> if the triangulation is still connected</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Hull.HullTriangulation">
            <summary>
            Functions to operate on triangulations represented as
            lists of <see cref="T:NetTopologySuite.Algorithm.Hull.HullTri"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTriangulation.Union(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a polygonal geometry representing the area of a triangulation
            which may be disconnected or contain holes.
            </summary>
            <param name="triList">The triangulation</param>
            <param name="geomFactory">The geometry factory</param>
            <returns>The area polygonal geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTriangulation.TraceBoundaryPolygon(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a Polygon representing the area of a triangulation
            which is connected and contains no holes.
            </summary>
            <param name="triList">The triangulation</param>
            <param name="geomFactory">The geometry factory to use</param>
            <returns>The area polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Hull.HullTriangulation.TraceBoundary(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Extracts the coordinates of the edgees along the boundary of a triangulation,
            by tracing CW around the border triangles.<br/>
            Assumption: there are at least 2 tris, they are connected,
            and there are no holes.
            So each tri has at least one non-border edge, and there is only one border.
            </summary>
            <param name="triList">The triangulation</param>
            <returns>The border of the triangulation</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPoint">
            <summary>
            Computes an interior point of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            An interior point is guaranteed to lie in the interior of the Geometry,
            if it possible to calculate such a point exactly.
            For collections the interior point is computed for the collection of
            non-empty elements of highest dimension.
            Otherwise, the point may lie on the boundary of the geometry.
            <para/>
            The interior point of an empty geometry is <c>POINT EMPTY</c>.
            <h2>Algorithm</h2>
            The point is chosen to be "close to the center" of the geometry.
            The location depends on the dimension of the input:
            <list type="bullet">
            <item><term>Dimension 2</term><description>the interior point is constructed in the middle of the longest interior segment
            of a line bisecting the area.</description></item>
            <item><term>Dimension 1</term><description>the interior point is the interior or boundary vertex closest to the centroid.</description></item>
            <item><term>Dimension 0</term><description>the point is the point closest to the centroid.</description></item>
            </list>
            <see cref="T:NetTopologySuite.Algorithm.Centroid"/>
            <see cref="T:NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle"/>
            <see cref="T:NetTopologySuite.Algorithm.Construct.LargestEmptyCircle"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPoint.GetInteriorPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a location of an interior point in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            <para/>
            Handles all geometry types.
            </summary>
            <param name="geom">A geometry in which to find an interior point</param>
            <returns>the location of an interior point, or <c>POINT EMPTY</c> if the input is empty
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPoint.GetInteriorCoord(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a location of an interior point in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            <para/>
            Handles all geometry types.
            </summary>
            <remarks>
            This function is called <c>GetInteriorPoint</c> in JTS.
            It has been renamed to <c>GetInteriorCoord</c> to prevent a breaking change.</remarks>
            <param name="geom">A geometry in which to find an interior point</param>
            <returns>the location of an interior point, or <c>null</c> if the input is empty
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointArea">
            <summary>
            Computes a point in the interior of an areal geometry.
            The point will lie in the geometry interior
            in all except certain pathological cases.
            </summary>
            <remarks>
            <h2>Algorithm:</h2>
            For each input polygon:
            <list type="bullet">
            <item><description>
            Determine a horizontal scan line on which the interior
            point will be located.
            To increase the chance of the scan line
            having non-zero-width intersection with the polygon
            the scan line Y ordinate is chosen to be near the centre of the polygon's
            Y extent but distinct from all of vertex Y ordinates.
            </description></item>
            <item><description>
            Compute the sections of the scan line
            which lie in the interior of the polygon.
            </description></item>
            <item><description>
            Choose the widest interior section
            and take its midpoint as the interior point.
            </description></item>
            </list>
            The final interior point is chosen as
            the one occurring in the widest interior section.
            <para>
            This algorithm is a tradeoff between performance
            and point quality (where points further from the geometry
            boundary are considered to be higher quality)
            Priority is given to performance.
            This means that the computed interior point
            may not be suitable for some uses
            (such as label positioning).
            </para>
            <para>
            The algorithm handles some kinds of invalid/degenerate geometry,
            including zero-area and self-intersecting polygons.
            </para>
            <para>
            Empty geometry is handled by returning a <see langword="null"/> point.
            </para>
            <h3>KNOWN BUGS</h3>
            <list type="bullet">
            <item><description>
            If a fixed precision model is used,
            in some cases this method may return a point
            which does not lie in the interior.
            </description></item>
            <item><description>
            If the input polygon is <i>extremely</i> narrow the computed point
            may not lie in the interior of the polygon.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.GetInteriorPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes an interior point for the
            polygonal components of a Geometry.
            </summary>
            <param name="geom">The geometry to compute.</param>
            <returns>
            The computed interior point,
            or <see langword="null"/> if the geometry has no polygonal components.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.Avg(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new interior point finder
            for an areal geometry.
            </summary>
            <param name="g">An areal geometry</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPoint">
            <summary>
            Gets the computed interior point
            or <see langword="null"/> if the input geometry is empty.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.Process(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Processes a geometry to determine
            the best interior point for
            all component polygons.
            </summary>
            <param name="geom">The geometry to process.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.ProcessPolygon(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Computes an interior point of a component Polygon
            and updates current best interior point
            if appropriate.
            </summary>
            <param name="polygon">The polygon to process.</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon">
            <summary>
            Computes an interior point in a single <see cref="T:NetTopologySuite.Geometries.Polygon"/>,
            as well as the width of the scan-line section it occurs in
            to allow choosing the widest section occurrence.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.#ctor(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon"/> class.
            </summary>
            <param name="polygon">The polygon to test.</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.InteriorPoint">
            <summary>
            Gets the computed interior point,
            or <see langword="null"/> if the input geometry is empty.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.Width">
            <summary>
            Gets the width of the scanline section containing the interior point.
            Used to determine the best point to use.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.Process">
            <summary>
            Compute the interior point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.FindBestMidpoint(System.Collections.Generic.List{System.Double})">
            <summary>
            Finds the midpoint of the widest interior section.
            Sets the <see cref="F:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon._interiorPoint"/> location and the
            <see cref="F:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon._interiorSectionWidth"/>
            </summary>
            <param name="crossings">The list of scan-line X ordinates</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.IsEdgeCrossingCounted(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Tests if an edge intersection contributes to the crossing count.
            Some crossing situations are not counted,
            to ensure that the list of crossings
            captures strict inside/outside topology.
            </summary>
            <param name="p0">An endpoint of the segment.</param>
            <param name="p1">An endpoint of the segment.</param>
            <param name="scanY">The Y-ordinate of the horizontal line.</param>
            <returns><see langword="true"/> if the edge crossing is counted.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.InteriorPointPolygon.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Computes the intersection of a segment with a horizontal line.
            The segment is expected to cross the horizontal line
            - this condition is not checked.
            Computation uses regular double-precision arithmetic.
            Test seems to indicate this is as good as using DD arithmetic.
            </summary>
            <param name="p0">An endpoint of the segment.</param>
            <param name="p1">An endpoint of the segment.</param>
            <param name="y">The Y-ordinate of the horizontal line</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.IntersectsHorizontalLine(NetTopologySuite.Geometries.Envelope,System.Double)">
            <summary>
            Tests if an envelope intersects a horizontal line.
            </summary>
            <param name="env">The envelope to test.</param>
            <param name="y">The Y-ordinate of the horizontal line.</param>
            <returns><see langword="true"/> if the envelope and line intersect.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea.IntersectsHorizontalLine(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Tests if a line segment intersects a horizontal line.
            </summary>
            <param name="p0">A segment endpoint.</param>
            <param name="p1">A segment endpoint.</param>
            <param name="y">The Y-ordinate of the horizontal line.</param>
            <returns><see langword="true"/> if the segment and line intersect.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointArea.ScanLineYOrdinateFinder">
            <summary>
            Finds a safe scan line Y ordinate by projecting
            the polygon segments
            to the Y axis and finding the
            Y-axis interval which contains the centre of the Y extent.
            The centre of
            this interval is returned as the scan line Y-ordinate.
            <para>
            Note that in the case of (degenerate, invalid)
            zero-area polygons the computed Y value
            may be equal to a vertex Y-ordinate.
            </para>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointLine">
            <summary>
            Computes a point in the interior of an linear point.
            Algorithm:
            Find an interior vertex which is closest to
            the centroid of the linestring.
            If there is no interior vertex, find the endpoint which is
            closest to the centroid.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.GetInteriorPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes an interior point for the
            linear components of a Geometry.
            </summary>
            <param name="geom">The geometry to compute.</param>
            <returns>
            The computed interior point,
            or <see langword="null"/> if the geometry has no linear components.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.#ctor(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.InteriorPointLine.InteriorPoint">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.AddInterior(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.AddInterior(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.AddEndpoints(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests the endpoint vertices
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.AddEndpoints(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine.Add(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="point"></param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointPoint">
            <summary>
            Computes a point in the interior of an point point.
            Algorithm:
            Find a point which is closest to the centroid of the point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointPoint.GetInteriorPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes an interior point for the
            puntal components of a Geometry.
            </summary>
            <param name="geom">The geometry to compute.</param>
            <returns>
            The computed interior point,
            or <see langword="null"/> if the geometry has no puntal components.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointPoint.#ctor(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointPoint.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests the point(s) defined by a Geometry for the best inside point.
            If a Geometry is not of dimension 0 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointPoint.Add(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="point"></param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.InteriorPointPoint.InteriorPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IntersectionComputer">
            <summary>
            Functions to compute intersection points between lines and line segments.
            <para/>
            In general it is not possible to compute
            the intersection point of two lines exactly, due to numerical roundoff.
            This is particularly true when the lines are nearly parallel.
            These routines uses numerical conditioning on the input values
            to ensure that the computed value is very close to the correct value.
            <para/>
            The Z-ordinate is ignored, and not populated.
            </summary>
            <author>mdavis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IntersectionComputer.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the intersection point of two lines.
            If the lines are parallel or collinear this case is detected
            and <c>null</c> is returned.
            </summary>
            <param name="p1">An endpoint of line 1</param>
            <param name="p2">An endpoint of line 1</param>
            <param name="q1">An endpoint of line 2</param>
            <param name="q2">An endpoint of line 2</param>
            <returns>
            <remarks>
            NOTE: In JTS this function is called Intersection.
            </remarks>
            The intersection point between the lines, if there is one,
            or null if the lines are parallel or collinear</returns>
            <seealso cref="M:NetTopologySuite.Algorithm.CGAlgorithmsDD.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IntersectionComputer.LineSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the intersection point of a line and a line segment (if any).
            There will be no intersection point if:
            <list type=">bullet">
            <item><description>the segment does not intersect the line</description></item>
            <item><description>the line or the segment are degenerate (have zero length)</description></item>
            </list>
            If the segment is collinear with the line the first segment endpoint is returned.
            </summary>
            <returns>The intersection point, or <c>null</c> if it is not possible to find an intersection</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IPointInAreaLocator">
            <summary>
            An interface for classes which determine the <see cref="T:NetTopologySuite.Geometries.Location"/> of points in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IPointInAreaLocator.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the  <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in the <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="p">The point to test</param>
            <returns>the location of the point in the geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Length">
            <summary>
            Functions for computing length.
            </summary>
            <author>
            Martin Davis
            </author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Length.OfLine(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes the length of a <c>LineString</c> specified by a sequence of points.
            </summary>
            <param name="pts">The points specifying the <c>LineString</c></param>
            <returns>The length of the <c>LineString</c></returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.LineIntersector">
            <summary>
            A <c>LineIntersector</c> is an algorithm that can both test whether
            two line segments intersect and compute the intersection point(s)
            if they do.
            <para>
            There are three possible outcomes when determining whether two line segments intersect:
            <list type="bullet">
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.NoIntersection"/> - the segments do not intersect</description></item>
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.PointIntersection"/> - the segments intersect in a single point</description></item>
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.CollinearIntersection"/> - the segments are collinear and they intersect in a line segment</description></item>
            </list>
            </para>
            <para>
            For segments which intersect in a single point, the point may be either an endpoint
            or in the interior of each segment.
            If the point lies in the interior of both segments,
            this is termed a <i>proper intersection</i>.
            The property <see cref="P:NetTopologySuite.Algorithm.LineIntersector.IsProper"/> test for this situation.
            </para><para>
            The intersection point(s) may be computed in a precise or non-precise manner.
            Computing an intersection point precisely involves rounding it
            via a supplied <see cref="P:NetTopologySuite.Algorithm.LineIntersector.PrecisionModel"/>.
            </para><para>
            LineIntersectors do not perform an initial envelope intersection test
            to determine if the segments are disjoint.
            This is because this class is likely to be used in a context where
            envelope overlap is already known to occur (or be likely).
            </para>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.NoIntersection">
            <summary>
            Indicates that line segments do not intersect
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.PointIntersection">
            <summary>
            Indicates that line segments intersect in a single point
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.CollinearIntersection">
            <summary>
            Indicates that line segments intersect in a line segment
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeEdgeDistance(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the "edge distance" of an intersection point p along a segment.
            The edge distance is a metric of the point along the edge.
            The metric used is a robust and easy to compute metric function.
            It is not equivalent to the usual Euclidean metric.
            It relies on the fact that either the x or the y ordinates of the
            points in the edge are unique, depending on whether the edge is longer in
            the horizontal or vertical direction.
            NOTE: This function may produce incorrect distances
            for inputs where p is not precisely on p1-p2
            (E.g. p = (139,9) p1 = (139,10), p2 = (280,1) produces distance 0.0, which is incorrect.
            My hypothesis is that the function is safe to use for points which are the
            result of rounding points which lie on the line, but not safe to use for truncated points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.NonRobustComputeEdgeDistance(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            This function is non-robust, since it may compute the square of large numbers.
            Currently not sure how to improve this.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.Result">
            <summary>
            A value indicating the intersection result
            <para/>
            Possible values are:
            <list type="bullet">
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.NoIntersection"/></description></item>
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.PointIntersection"/></description></item>
            <item><description><see cref="F:NetTopologySuite.Algorithm.LineIntersector.CollinearIntersection"/></description></item>
            </list>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.InputLines">
            <summary>
            Array of coordinate arrays forming the lines
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.IntersectionPoint">
            <summary>
            Array of
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector.IntersectionLineIndex">
            <summary>
            The indexes of the endpoints of the intersection lines, in order along
            the corresponding line
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.Pa">
            <summary>
            Alias the <see cref="F:NetTopologySuite.Algorithm.LineIntersector.IntersectionPoint"/>[0] for ease of reference
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.Pb">
            <summary>
            Alias the <see cref="F:NetTopologySuite.Algorithm.LineIntersector.IntersectionPoint"/>[1] for ease of reference
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersector._precisionModel">
            <summary>
            If MakePrecise is true, computed intersection coordinates will be made precise
            using <c>Coordinate.MakePrecise</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.#ctor">
            <summary>
            Creates an instance of this class
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.PrecisionModel">
            <summary>
            Force computed intersection to be rounded to a given precision model.
            No getter is provided, because the precision model is not required to be specified.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.GetEndpoint(System.Int32,System.Int32)">
            <summary>
            Gets an endpoint of an input segment.
            </summary>
            <param name="segmentIndex">the index of the input segment (0 or 1)</param>
            <param name="ptIndex">the index of the endpoint (0 or 1)</param>
            <returns>The specified endpoint</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Compute the intersection of a point p and the line p1-p2.
            This function computes the bool value of the hasIntersection test.
            The actual value of the intersection (if there is one)
            is equal to the value of <c>p</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.IsCollinear">
            <summary>
            Gets a value indicating if the computed intersection is collinear
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the intersection of the lines p1-p2 and p3-p4.
            This function computes both the bool value of the hasIntersection test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
            <param name="p1">The 1st point of the 1st segment</param>
            <param name="p2">The 2nd point of the 1st segment</param>
            <param name="p3">The 1st point of the 2nd segment</param>
            <param name="p4">The 2nd point of the 2nd segment</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntersect(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the intersection of two line segments, one defined by <paramref name="p1"/> and <paramref name="p2"/>,
            the other by <paramref name="q1"/> and <paramref name="q2"/>.
            </summary>
            <param name="p1">The 1st point of the 1st segment</param>
            <param name="p2">The 2nd point of the 1st segment</param>
            <param name="q1">The 1st point of the 2nd segment</param>
            <param name="q2">The 2nd point of the 2nd segment</param>
            <returns></returns>
            <remarks>
            Don't use this function directly, it is not meant for public use.
            Please call <see cref="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
            and test <see cref="P:NetTopologySuite.Algorithm.LineIntersector.HasIntersection"/> or <see cref="P:NetTopologySuite.Algorithm.LineIntersector.IsCollinear"/> along with <see cref="P:NetTopologySuite.Algorithm.LineIntersector.IsProper"/> and
            <see cref="P:NetTopologySuite.Algorithm.LineIntersector.IsEndPoint"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.IsEndPoint">
            <summary>
            Gets a value indicating if the intersection is an end-point intersection
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.HasIntersection">
            <summary>
            Tests whether the input geometries intersect.
            </summary>
            <returns><c>true</c> if the input geometries intersect.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.IntersectionNum">
            <summary>
            Returns the number of intersection points found.  This will be either 0, 1 or 2.
            </summary>
            <returns>The number of intersection points found (0, 1, or 2)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.GetIntersection(System.Int32)">
            <summary>
            Returns the intIndex'th intersection point.
            </summary>
            <param name="intIndex">is 0 or 1.</param>
            <returns>The intIndex'th intersection point.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntLineIndex">
            <summary>
            Computes the <see cref="F:NetTopologySuite.Algorithm.LineIntersector.IntersectionLineIndex"/> values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.IsIntersection(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Test whether a point is a intersection point of two line segments.
            Note that if the intersection is a line segment, this method only tests for
            equality with the endpoints of the intersection segment.
            It does not return true if the input point is internal to the intersection segment.
            </summary>
            <returns><c>true</c> if the input point is one of the intersection points.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.IsInteriorIntersection">
            <summary>
            Tests whether either intersection point is an interior point of one of the input segments.
            </summary>
            <returns>
            <c>true</c> if either intersection point is in the interior of one of the input segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.IsInteriorIntersection(System.Int32)">
            <summary>
            Tests whether either intersection point is an interior point of the specified input segment.
            </summary>
            <returns>
            <c>true</c> if either intersection point is in the interior of the input segment.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector.IsProper">
            <summary>
            Tests whether an intersection is proper.
            The intersection between two line segments is considered proper if
            they intersect in a single point in the interior of both segments
            (e.g. the intersection is a single point and is not equal to any of the endpoints).
            The intersection between a point and a line segment is considered proper
            if the point lies in the interior of the segment (e.g. is not equal to either of the endpoints).
            </summary>
            <returns><c>true</c>  if the intersection is proper.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.GetIntersectionAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the intIndex'th intersection point in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>
            The intIndex'th intersection point in the direction of the specified input line segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.GetIndexAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the index (order) of the intIndex'th intersection point in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>
            The index of the intersection point along the segment (0 or 1).
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntLineIndex(System.Int32)">
            <summary>
            Computes the intersection line index
            </summary>
            <param name="segmentIndex">The segment index</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector.GetEdgeDistance(System.Int32,System.Int32)">
            <summary>
            Computes the "edge distance" of an intersection point along the specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>The edge distance of the intersection point.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s relative to
            an areal geometry, using indexing for efficiency.
            This algorithm is suitable for use in cases where
            many points will be tested against a given area.
            <para/>
            The <c>Location</c> is computed precisely, th that points
            located on the geometry boundary or segments will
            return <see cref="F:NetTopologySuite.Geometries.Location.Boundary"/>.
            <para/>
            <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> and <see cref="T:NetTopologySuite.Geometries.LinearRing"/> geometries are supported.
            <para/>
            The index is lazy-loaded, which allows
            creating instances even if they are not used.
            <para/>
            Thread-safe and immutable.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new locator for a given <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> and <see cref="T:NetTopologySuite.Geometries.LinearRing"/> geometries are supported
            </summary>
            <param name="g">The Geometry to locate in</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in an areal <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="p">The point to test</param>
            <returns>The location of the point in the geometry
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.CreateIndex">
            <summary>
            Creates the indexed geometry, creating it if necessary.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator">
            <summary>
            An interface for classes which determine the <see cref="T:NetTopologySuite.Geometries.Location"/> of
            points in areal geometries.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in an areal <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="p">The point to test</param>
            <returns>The location of the point in the geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions">
            <summary>
            Static methods for <see cref="T:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator"/> classes
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions.Intersects(NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Convenience method to test a point for intersection with a geometry
            <para/>
            The geometry is wrapped in a <see cref="T:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator"/> class.
            </summary>
            <param name="locator">The locator to use.</param>
            <param name="coordinate">The coordinate to test.</param>
            <returns><c>true</c> if the point is in the interior or boundary of the geometry.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator">
            <summary>
            Computes the location of points
            relative to an areal <see cref="T:NetTopologySuite.Geometries.Geometry"/>,
            using a simple <c>O(n)</c> algorithm.
            <para>
            The algorithm used reports
            if a point lies in the interior, exterior,
            or exactly on the boundary of the Geometry.
            </para>
            <para>
            Instance methods are provided to implement
            the interface <see cref="T:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator"/>.
            However, they provide no performance
            advantage over the class methods.
            </para>
            <para>
            This algorithm is suitable for use in cases where
            only a few points will be tested.
            If many points will be tested,
            <see cref="T:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator"/> may provide better performance.
            </para>
            </summary>
            <remarks>The algorithm used is only guaranteed to return correct results for points which are <b>not</b> on the boundary of the Geometry.</remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.Locate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in an areal <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The return value is one of:
            <list type="bullet">
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Interior"/></term><description>if the point is in the geometry interior</description></item>
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Boundary"/></term><description>if the point lies exactly on the boundary</description></item>
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Exterior"/></term><description>if the point is outside the geometry</description></item>
            </list>
            </summary>
            <param name="p">The point to test</param>
            <param name="geom">The areal geometry to test</param>
            <returns>The Location of the point in the geometry  </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.IsContained(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines whether a point is contained in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>,
            or lies on its boundary.
            This is a convenience method for
            <code>
            Location.Exterior != Locate(p, geom)
            </code>
            </summary>
            <param name="p">The point to test.</param>
            <param name="geom">The geometry to test.</param>
            <returns><see langword="true"/> if the point lies in or on the geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.ContainsPointInPolygon(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Polygon)">
            <summary>
            Determines whether a point lies in a <see cref="T:NetTopologySuite.Geometries.Polygon"/>.
            If the point lies on the polygon boundary it is
            considered to be inside.
            </summary>
            <param name="p">The point to test</param>
            <param name="poly">The areal geometry to test</param>
            <returns><c>true</c> if the point lies in the polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.LocatePointInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Determines whether a point lies in a LinearRing, using the ring envelope to short-circuit if possible.
            </summary>
            <param name="p">The point to test</param>
            <param name="ring">A linear ring</param>
            <returns><c>true</c> if the point lies inside the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator"/> class,
            using the provided areal geometry.
            </summary>
            <param name="geom">The areal geometry to locate in.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in an areal <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The return value is one of:
            <list type="bullet">
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Interior"/></term><description>if the point is in the geometry interior</description></item>
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Boundary"/></term><description>if the point lies exactly on the boundary</description></item>
            <item><term><see cref="F:NetTopologySuite.Geometries.Location.Exterior"/></term><description>if the point is outside the geometry</description></item>
            </list>
            </summary>
            <param name="p">The point to test</param>
            <returns>The Location of the point in the geometry.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure">
            <summary>
            Measures the degree of similarity between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            using the area of intersection between the geometries.
            The measure is normalized to lie in the range [0, 1].
            Higher measures indicate a great degree of similarity.
            </summary>
            <remarks>
            NOTE: Currently experimental and incomplete.
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure.Measure(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the similarity measure between two geometries
            </summary>
            <param name="g1">A geometry.</param>
            <param name="g2">A geometry.</param>
            <returns>
            The value of the similarity measure, in [0.0, 1.0].
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure">
            <summary>
            Measures the degree of similarity between two
            <see cref="T:NetTopologySuite.Geometries.Geometry"/>s using the Frchet distance metric.
            The measure is normalized to lie in the range [0, 1].
            Higher measures indicate a great degree of similarity.
            <para/>
            The measure is computed by computing the Frchet distance
            between the input geometries, and then normalizing
            this by dividing it by the diagonal distance across
            the envelope of the combined geometries.
            <para/>
            Note: the input should be normalized, especially when
            measuring <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> geometries because for the
            Frchet distance the order of {@link Coordinate}s is
            important.
            </summary>
            <author>Felix Obermaier</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure.#ctor">
            <summary>
            Creates an instance of this class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure.Measure(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc/>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure">
            <summary>
            Measures the degree of similarity between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s using the Hausdorff distance metric.
            </summary>
            <remarks>
            <para>
            The measure is normalized to lie in the range [0, 1]. Higher measures indicate a great degree of similarity.
            </para>
            <para>
            The measure is computed by computing the Hausdorff distance between the input geometries, and then normalizing
            this by dividing it by the diagonal distance across the envelope of the combined geometries.
            </para>
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure.Measure(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure.DiagonalSize(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.ISimilarityMeasure">
            <summary>
            An interface for classes which measures the degree of similarity between two {@link Geometry}s.
            </summary>
            <remarks>
            The computed measure lies in the range [0, 1].
            Higher measures indicate a great degree of similarity.
            A measure of 1.0 indicates that the input geometries are identical
            A measure of 0.0 indicates that the geometries have essentially no similarity.
            The precise definition of "identical" and "no similarity" may depend on the  exact algorithm being used.
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.ISimilarityMeasure.Measure(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Function to measure the similarity between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="g1">A geometry</param>
            <param name="g2">A geometry</param>
            <returns>The similarity value between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner">
            <summary>
            Provides methods to mathematically combine <see cref="T:NetTopologySuite.Algorithm.Match.ISimilarityMeasure"/> values.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner.Combine(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="measure1"></param>
             <param name="measure2"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MinimumBoundingCircle">
            <summary>
            Computes the <b>Minimum Bounding Circle</b> (MBC) for the points in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The MBC is the smallest circle which <tt>cover</tt>s all the input points
            (this is also sometimes known as the <b>Smallest Enclosing Circle</b>).
            This is equivalent to computing the Maximum Diameter of the input point set.
            </summary>
            <remarks>
            <para/>
            The computed circle can be specified in two equivalent ways,
            both of which are provide as output by this class:
            <list type="bullet">
            <item><description>As a centre point and a radius</description></item>
            <item><description>By the set of points defining the circle.
            Depending on the number of points in the input
            and their relative positions, this set
            contains from 0 to 3 points.
            <list type="bullet">
            <item><description>0 or 1 points indicate an empty or trivial input point arrangement.</description></item>
            <item><description>2 points define the diameter of the minimum bounding circle.</description></item>
            <item><description>3 points define an inscribed triangle of the minimum bounding circle.</description></item>
            </list>
            </description></item></list>
            <para/>
            The class can also output a <see cref="T:NetTopologySuite.Geometries.Geometry"/> which approximates the
            shape of the Minimum Bounding Circle (although as an approximation 
            it is <b>not</b> guaranteed to <tt>cover</tt> all the input points.)
            <para/>
            The Maximum Diameter of the input point set can
            be computed as well. The Maximum Diameter is
            defined by the pair of input points with maximum distance between them.
            The points of the maximum diameter are two of the extremal points of the Minimum Bounding Circle.
            They lie on the convex hull of the input.
            However, that the maximum diameter is not a diameter
            of the Minimum Bounding Circle in the case where the MBC is
            defined by an inscribed triangle.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new object for computing the minimum bounding circle for the
            point set defined by the vertices of the given geometry.
            </summary>
            <param name="geom">The geometry to use to obtain the point set </param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetCircle">
            <summary>
            Gets a geometry which represents the Minimum Bounding Circle.
            </summary>
            <remarks>
            <para>
            If the input is degenerate (empty or a single unique point),
            this method will return an empty geometry or a single Point geometry.
            Otherwise, a Polygon will be returned which approximates the
            Minimum Bounding Circle. (Note that because the computed polygon is only an approximation, it may not precisely contain all the input points.)
            </para>
            </remarks>
            <returns>A Geometry representing the Minimum Bounding Circle.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetMaximumDiameter">
            <summary>Gets a geometry representing the maximum diameter of the
            input. The maximum diameter is the longest line segment
            between any two points of the input.
            <para/>
            The points are two of the extremal points of the Minimum Bounding Circle.
            They lie on the convex hull of the input.
            </summary>
            <returns>
            The result is 
            <list type="Bullet">
            <item><description>a LineString between the two farthest points of the input</description></item>
            <item><description>a empty LineString if the input is empty</description></item>
            <item><description>a Point if the input is a point</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetFarthestPoints">
            <summary>
            Gets a geometry representing a line between the two farthest points
            in the input.
            <para/>
            These points are two of the extremal points of the Minimum Bounding Circle
            They lie on the convex hull of the input.
            </summary>
            <returns>A LineString between the two farthest points of the input</returns>
            <returns>An empty LineString if the input is empty</returns>
            <returns>A Point if the input is a point</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.FarthestPoints(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Finds the farthest pair out of 3 extremal points
            </summary>
            <param name="pts">The array of extremal points</param>
            <returns>The pair of farthest points</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetDiameter">
            <summary>
            Gets a geometry representing the diameter of the computed Minimum Bounding Circle.
            </summary>
            <returns>
            <list type="bullet">
            <item><description>the diameter line of the Minimum Bounding Circle</description></item>
            <item><description>an empty line if the input is empty</description></item>
            <item><description>a Point if the input is a point</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetExtremalPoints">
            <summary>
            Gets the extremal points which define the computed Minimum Bounding Circle.
            There may be zero, one, two or three of these points, depending on the number
            of points in the input and the geometry of those points.
            <list type="Bullet">
            <item><description>0 or 1 points indicate an empty or trivial input point arrangement.</description></item>
            <item><description>2 points define the diameter of the Minimum Bounding Circle.</description></item>
            <item><description>3 points define an inscribed triangle of which the Minimum Bounding Circle is the circumcircle.
            The longest chords of the circle are the line segments [0-1] and[1 - 2]</description></item>
            </list>
            </summary>
            <returns>The points defining the Minimum Bounding Circle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetCentre">
            <summary>
            Gets the centre point of the computed Minimum Bounding Circle.
            </summary>
            <returns>
            <list type="Bullet">
            <item><description>The centre point of the Minimum Bounding Circle or</description></item>
            <item><description><c>null</c> if the input is empty</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumBoundingCircle.GetRadius">
            <summary>
            Gets the radius of the computed Minimum Bounding Circle.
            </summary>
            <returns>The radius of the Minimum Bounding Circle</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MinimumDiameter">
            <summary>
            Computes the minimum diameter of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <remarks>
            <para>
            The minimum diameter is defined to be the
            width of the smallest band that contains the geometry,
            where a band is a strip of the plane defined by two parallel lines.
            This can be thought of as the smallest hole that the point can be
            moved through, with a single rotation.
            </para>
            <para>
            The first step in the algorithm is computing the convex hull of the Geometry.
            If the input Geometry is known to be convex, a hint can be supplied to
            avoid this computation.
            </para>
            <para>
            This class can also be used to compute
            <list type="bullet">
            <item><description>a line segment representing the minimum diameter</description></item>
            <item><description>the <b>supporting line segment</b> of the minimum diameter</description></item>
            <item><description>a <b>minimum enclosing rectangle</b> of the input geometry.
            The rectangle has width equal to the minimum diameter, and has one side
            parallel to the supporting segment.
            In degenerate cases the minimum enclosing geometry may be a LineString or a Point.
            </description></item></list>
            </para>
            </remarks>
            <seealso cref="T:NetTopologySuite.Algorithm.ConvexHull"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.GetMinimumRectangle(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the minimum rectangular <see cref="T:NetTopologySuite.Geometries.Polygon"/> which encloses the input geometry.
            The rectangle has width equal to the minimum diameter,
            and a longer length.
            If the convex hull of the input is degenerate (a line or point)
            a <see cref="T:NetTopologySuite.Geometries.LineString"/>
            or <see cref="T:NetTopologySuite.Geometries.Point"/> is returned.
            <para/>
            The minimum rectangle can be used as an extremely generalized representation
            for the given geometry.
            </summary>
            <param name="geom">The geometry</param>
            <returns>The minimum rectangle enclosing the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.GetMinimumDiameter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the minimum diameter enclosing a geometry.
            </summary>
            <param name="geom">The geometry</param>
            <returns>The length of the minimum diameter of the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Compute a minimum diameter for a given <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="inputGeom">a Geometry.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.#ctor(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Compute a minimum diameter for a giver <c>Geometry</c>,
            with a hint if
            the Geometry is convex
            (e.g. a convex Polygon or LinearRing,
            or a two-point LineString, or a Point).
            </summary>
            <param name="inputGeom">a Geometry which is convex.</param>
            <param name="isConvex"><c>true</c> if the input point is convex.</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter.Length">
            <summary>
            Gets the length of the minimum diameter of the input Geometry.
            </summary>
            <returns>The length of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter.WidthCoordinate">
            <summary>
            Gets the <c>Coordinate</c> forming one end of the minimum diameter.
            </summary>
            <returns>A coordinate forming one end of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter.SupportingSegment">
            <summary>
            Gets the segment forming the base of the minimum diameter.
            </summary>
            <returns>The segment forming the base of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter.Diameter">
            <summary>
            Gets a <c>LineString</c> which is a minimum diameter.
            </summary>
            <returns>A <c>LineString</c> which is a minimum diameter.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.ComputeMinimumDiameter">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.ComputeWidthConvex(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="convexGeom"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.ComputeConvexRingMinDiameter(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Compute the width information for a ring of <c>Coordinate</c>s.
            Leaves the width information in the instance variables.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.FindMaxPerpDistance(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.LineSegment,System.Int32)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="seg"></param>
             <param name="startIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.NextIndex(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.GetMinimumRectangle">
            <summary>
            Gets the minimum rectangular <see cref="T:NetTopologySuite.Geometries.Polygon"/> which encloses the input geometry.
            </summary>
            <remarks>
            <para>
            The rectangle has width equal to the minimum diameter, and a longer length.
            If the convex hull of the input is degenerate (a line or point) a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.Point"/> is returned.
            </para>
            <para>
            The minimum rectangle can be used as an extremely generalized representation for the given geometry.
            </para>
            </remarks>
            <returns>The minimum rectangle enclosing the input (or a line or point if degenerate)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter.ComputeMaximumLine(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a line of maximum extent from the provided vertices
            </summary>
            <param name="pts">The vertices</param>
            <param name="factory">The geometry factory</param>
            <returns>The line of maximum extent</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.NotRepresentableException">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.NotRepresentableException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Orientation">
            <summary>
            Functions to compute the orientation of basic geometric structures
            including point triplets(triangles) and rings.
            Orientation is a fundamental property of planar geometries
            (and more generally geometry on two-dimensional manifolds).
            <para/>
            Determining triangle orientation
            is notoriously subject to numerical precision errors
            in the case of collinear or nearly collinear points.
            NTS uses extended-precision arithmetic to increase
            the robustness of the computation.
            </summary>
            <author>
            Martin Davis
            </author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the orientation index of the direction of the point <paramref name="q"/> relative to
            a directed infinite line specified by <c>p1-&gt;p2</c>.
            The index indicates whether the point lies to the <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Left"/>
            or <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Right"/> of the line, or lies on it <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Collinear"/>.
            The index also indicates the orientation of the triangle formed by the three points
            (<see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/>, <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/>, or
            <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Straight"/> )
            </summary>
            <param name="p1">The origin point of the line vector</param>
            <param name="p2">The final point of the line vector</param>
            <param name="q">The point to compute the direction to</param>
            <returns>
            The <see cref="T:NetTopologySuite.Algorithm.OrientationIndex"/> of q in regard to the vector <c>p1-&gt;p2</c>
            <list type="table">
            <listheader>
            <term>Value</term><description>Description</description>
            </listheader>
            <item>
            <term><see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Collinear"/>, <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Straight"/></term>
            <description><paramref name="q"/> is collinear with <c>p1-&gt;p2</c></description>
            </item>
            <item>
            <term><see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/>, <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Right"/></term>
            <description><paramref name="q"/> is clockwise (right) from <c>p1-&gt;p2</c></description>
            </item>
            <item>
            <term><see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/>, <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Left"/></term>
            <description><paramref name="q"/> is counter-clockwise (left) from <c>p1-&gt;p2</c></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.IsCCW(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests if a ring defined by an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s is
            oriented counter-clockwise.
            <list type="bullet">
            <item><description>The list of points is assumed to have the first and last points equal.</description></item>
            <item><description>This handles coordinate lists which contain repeated points.</description></item>
            <item><description>This handles rings which contain collapsed segments (in particular, along the top of the ring).</description></item>
            </list>
            This algorithm is guaranteed to work with valid rings.
            It also works with "mildly invalid" rings
            which contain collapsed(coincident) flat segments along the top of the ring.
            If the ring is "more" invalid (e.g.self-crosses or touches),
            the computed result may not be correct.
            </summary>
            <param name="ring">An array of <c>Coordinate</c>s forming a ring (with first and last point identical)</param>
            <returns><c>true</c> if the ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.IsCCW(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests if a ring defined by a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> is
            oriented counter-clockwise.
            <list type="bullet">
            <item><description>The list of points is assumed to have the first and last points equal.</description></item>
            <item><description>This handles coordinate lists which contain repeated points.</description></item>
            <item><description>This handles rings which contain collapsed segments (in particular, along the top of the ring).</description></item>
            </list>
            This algorithm is guaranteed to work with valid rings.
            It also works with "mildly invalid" rings
            which contain collapsed(coincident) flat segments along the top of the ring.
            If the ring is "more" invalid (e.g.self-crosses or touches),
            the computed result may not be correct.
            </summary>
            <param name="ring">A <c>CoordinateSequence</c>s forming a ring (with first and last point identical).</param>
            <returns><c>true</c> if the ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.IsCCWArea(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests if a ring defined by an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s is
            oriented counter-clockwise, using the signed area of the ring.
            <list type="bullet">
            <item><description>The list of points is assumed to have the first and last points equal.</description></item>
            <item><description>This handles coordinate lists which contain repeated points.</description></item>
            <item><description>This handles rings which contain collapsed segments 
               (in particular, along the top of the ring).</description></item>
            <item><description>This handles rings which are invalid due to self-intersection</description></item>
            </list>
            This algorithm is guaranteed to work with valid rings.
            For invalid rings (containing self-intersections),
            the algorithm determines the orientation of
            the largest enclosed area (including overlaps).
            This provides a more useful result in some situations, such as buffering.
            <para/>
            However, this approach may be less accurate in the case of
            rings with almost zero area.
            (Note that the orientation of rings with zero area is essentially
            undefined, and hence non-deterministic.)
            </summary>
            <param name="ring">An array of Coordinates forming a ring (with first and last point identical)</param>
            <returns><c>true</c> if the ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.IsCCWArea(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests if a ring defined by a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> is
            oriented counter-clockwise, using the signed area of the ring.
            <list type="bullet">
            <item><description>The list of points is assumed to have the first and last points equal.</description></item>
            <item><description>This handles coordinate lists which contain repeated points.</description></item>
            <item><description>This handles rings which contain collapsed segments 
               (in particular, along the top of the ring).</description></item>
            <item><description>This handles rings which are invalid due to self-intersection</description></item>
            </list>
            This algorithm is guaranteed to work with valid rings.
            For invalid rings (containing self-intersections),
            the algorithm determines the orientation of
            the largest enclosed area (including overlaps).
            This provides a more useful result in some situations, such as buffering.
            <para/>
            However, this approach may be less accurate in the case of
            rings with almost zero area.
            (Note that the orientation of rings with zero area is essentially
            undefined, and hence non-deterministic.)
            </summary>
            <param name="ring">An array of Coordinates forming a ring (with first and last point identical)</param>
            <returns><c>true</c> if the ring is oriented counter-clockwise.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Orientation.ReOrient(NetTopologySuite.Algorithm.OrientationIndex)">
            <summary>
            Re-orients an orientation.
            </summary>
            <param name="orientation">The orientation</param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.OrientationIndex">
            <summary>
            Angle orientation
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.Collinear">
            <summary>A value that indicates an orientation of collinear, or no turn (straight)</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.None">
            <summary>A value that indicates an orientation of collinear, or no turn (straight)</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.Straight">
            <summary>A value that indicates an orientation of collinear, or no turn (straight)</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise">
            <summary>A value that indicates an orientation of counterclockwise, or a left turn.</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.Left">
            <summary>A value that indicates an orientation of counterclockwise, or a left turn.</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise">
            <summary>A value that indicates an orientation of clockwise or a right turn.</summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.OrientationIndex.Right">
            <summary>A value that indicates an orientation of clockwise or a right turn.</summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.PointLocation">
            <summary>
            Functions for locating points within basic geometric
            structures such as lines and rings.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.IsOnLine(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether a point lies on the line defined by a list of
            coordinates.
            </summary>
            <param name="p">The point to test</param>
            <param name="line">The line coordinates</param>
            <returns>
            <c>true</c> if the point is a vertex of the line or lies in the interior
            of a line segment in the line
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.IsOnLine(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests whether a point lies on the line defined by a list of
            coordinates.
            </summary>
            <param name="p">The point to test</param>
            <param name="line">The line coordinates</param>
            <returns>
            <c>true</c> if the point is a vertex of the line or lies in the interior
            of a line segment in the line
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.IsInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether a point lies inside or on a ring. The ring may be oriented in
            either direction. A point lying exactly on the ring boundary is considered
            to be inside the ring.
            <para/>
            This method does <i>not</i> first check the point against the envelope of
            the ring.
            </summary>
            <param name="p">The point to check for ring inclusion</param>
            <param name="ring">An array of coordinates representing the ring (which must have
            first point identical to last point)</param>
            <returns><c>true</c> if p is inside ring</returns>
            <seealso cref="M:NetTopologySuite.Algorithm.PointLocation.LocateInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.IsInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests whether a point lies inside or on a ring. The ring may be oriented in
            either direction. A point lying exactly on the ring boundary is considered
            to be inside the ring.
            <para/>
            This method does <i>not</i> first check the point against the envelope of
            the ring.
            </summary>
            <param name="p">The point to check for ring inclusion</param>
            <param name="ring">A <c>CoordinateSequence</c> representing the ring (which must have
            first point identical to last point)</param>
            <returns><c>true</c> if p is inside ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.LocateInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determines whether a point lies in the interior, on the boundary, or in the
            exterior of a ring.The ring may be oriented in either direction.
            <para/>
            This method does<i> not</i> first check the point against the envelope of
            the ring.
            </summary>
            <param name="p">The point to check for ring inclusion</param>
            <param name="ring">A <c>CoordinateSequence</c> representing the ring (which must have
            first point identical to last point)</param>
            <returns>the <see cref="T:NetTopologySuite.Geometries.Location"/> of p relative to the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocation.LocateInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Determines whether a point lies in the interior, on the boundary, or in the
            exterior of a ring.The ring may be oriented in either direction.
            <para/>
            This method does<i> not</i> first check the point against the envelope of
            the ring.
            </summary>
            <param name="p">The point to check for ring inclusion</param>
            <param name="ring">A <c>CoordinateSequence</c> representing the ring (which must have
            first point identical to last point)</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.PointLocator">
            <summary>
            Computes the topological relationship (<see cref="T:NetTopologySuite.Geometries.Location"/>) of a single point to a Geometry.
            </summary>
            <remarks>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> may be specified to control the evaluation of whether the point lies on the boundary or not
            The default rule is to use the <i>SFS Boundary Determination Rule</i>
            <para>
            Notes:
            <list Type="Bullet">
            <item><description><see cref="T:NetTopologySuite.Geometries.LinearRing"/>s do not enclose any area - points inside the ring are still in the EXTERIOR of the ring.</description></item>
            </list>
            Instances of this class are not reentrant.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.PointLocator"/> class.<para/>
            The default boundary rule is <see cref="F:NetTopologySuite.Algorithm.BoundaryNodeRules.EndpointBoundaryRule"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator.#ctor(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.PointLocator"/> class using the provided
            <paramref name="boundaryRule">boundary rule</paramref>.
            </summary>
            <param name="boundaryRule">The boundary rule to use.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Convenience method to test a point for intersection with a Geometry
            </summary>
            <param name="p">The coordinate to test.</param>
            <param name="geom">The Geometry to test.</param>
            <returns><c>true</c> if the point is in the interior or boundary of the Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator.Locate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the topological relationship ({Location}) of a single point to a Geometry.
            It handles both single-element and multi-element Geometries.
            The algorithm for multi-part Geometries takes into account the boundaryDetermination rule.
            </summary>
            <returns>The Location of the point relative to the input Geometry.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.RayCrossingCounter">
            <summary>
            Counts the number of segments crossed by a horizontal ray extending to the right
            from a given point, in an incremental fashion.
            <para>This can be used to determine whether a point lies in a <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometry.</para>
            <para>The class determines the situation where the point lies exactly on a segment.</para>
            <para>When being used for Point-In-Polygon determination, this case allows short-circuiting the evaluation.</para>
            </summary>
            <remarks>
            This class handles polygonal geometries with any number of shells and holes.
            The orientation of the shell and hole rings is unimportant.
            In order to compute a correct location for a given polygonal geometry,
            it is essential that <b>all</b> segments are counted which
            <list type="bullet">
            <item><description>touch the ray</description></item>
            <item><description>lie in in any ring which may contain the point</description></item>
            </list>
            <para>
            The only exception is when the point-on-segment situation is detected, in which
            case no further processing is required.
            The implication of the above rule is that segments which can be a priori determined to <i>not</i> touch the ray
            (i.e. by a test of their bounding box or Y-extent) do not need to be counted.  This allows for optimization by indexing.
            </para>
            <para>
            This implementation uses the extended-precision orientation test,
            to provide maximum robustness and consistency within
            other algorithms.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RayCrossingCounter.LocatePointInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in a ring.
            This method is an exemplar of how to use this class.
            </summary>
            <param name="p">The point to test</param>
            <param name="ring">An array of Coordinates forming a ring</param>
            <returns>The location of the point in the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RayCrossingCounter.LocatePointInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of a point in a ring.
            </summary>
            <param name="p">The point to test</param>
            <param name="ring">A coordinate sequence forming a ring</param>
            <returns>The location of the point in the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RayCrossingCounter.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="p">A coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RayCrossingCounter.CountSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Counts a segment
            </summary>
            <param name="p1">An endpoint of the segment</param>
            <param name="p2">Another endpoint of the segment</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.RayCrossingCounter.IsOnSegment">
            <summary>
            Reports whether the point lies exactly on one of the supplied segments.
            </summary>
            <remarks>
            This method may be called at any time as segments are processed. If the result of this method is <c>true</c>,
            no further segments need be supplied, since the result will never change again.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Algorithm.RayCrossingCounter.Location">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Location"/> of the point relative to  the ring, polygon
            or multipolygon from which the processed segments were provided.
            </summary>
            <remarks>
            This property only determines the correct location
            if <b>all</b> relevant segments have been processed.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Algorithm.RayCrossingCounter.IsPointInPolygon">
            <summary>
            Tests whether the point lies in or on
            the ring, polygon or multipolygon from which the processed
            segments were provided.
            </summary>
            <remarks>
            This property only determines the correct location
            if <b>all</b> relevant segments have been processed
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Algorithm.RectangleLineIntersector">
            <summary>
            Computes whether a rectangle intersects line segments.
            </summary>
            <remarks>
            Rectangles contain a large amount of inherent symmetry
            (or to put it another way, although they contain four
            coordinates they only actually contain 4 ordinates
            worth of information).
            The algorithm used takes advantage of the symmetry of
            the geometric situation
            to optimize performance by minimizing the number
            of line intersection tests.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RectangleLineIntersector.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates a new intersector for the given query rectangle,
            specified as an <see cref="T:NetTopologySuite.Geometries.Envelope"/>.
            </summary>
            <param name="rectEnv">The query rectangle, specified as an Envelope</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RectangleLineIntersector.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the query rectangle intersects a given line segment.
            </summary>
            <param name="p0">The first endpoint of the segment</param>
            <param name="p1">The second endpoint of the segment</param>
            <returns><c>true</c> if the rectangle intersects the segment</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.RobustDeterminant">
             <summary>
             Implements an algorithm to compute the
             sign of a 2x2 determinant for double precision values robustly.
             It is a direct translation of code developed by Olivier Devillers.
            
             The original code carries the following copyright notice:
             ************************************************************************
             Author : Olivier Devillers
             Olivier.Devillers@sophia.inria.fr
             http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html
            
             Olivier Devillers has allowed the code to be distributed under
             the LGPL (2012-02-16) saying "It is ok for LGPL distribution."
            
             *************************************************************************
             *************************************************************************
             Copyright (c) 1995  by  INRIA Prisme Project
             BP 93 06902 Sophia Antipolis Cedex, France.
             All rights reserved
             *************************************************************************
             </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustDeterminant.SignOfDet2x2(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the sign of the determinant of the 2x2 matrix with the given entries, in a robust way.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns>
            <list type="bullet">
            <item><description>-1 if the determinant is negative,</description></item>
            <item><description>1 if the determinant is positive,</description></item>
            <item><description>0 if the determinant is null.</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustDeterminant.OrientationIndex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the index of the direction of the point <c>q</c> relative to
            a vector specified by <c>p1-p2</c>.
            </summary>
            <param name="p1">The origin point of the vector</param>
            <param name="p2">The final point of the vector</param>
            <param name="q">the point to compute the direction to</param>
            <returns>
            <list type="bullet">
            <item><description>1 if q is counter-clockwise (left) from p1-p2</description></item>
            <item><description>-1 if q is clockwise (right) from p1-p2</description></item>
            <item><description>0 if q is collinear with p1-p2</description></item></list>
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.RobustLineIntersector">
            <summary>
            A robust version of <see cref="T:NetTopologySuite.Algorithm.LineIntersector"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.ComputeIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.ComputeIntersect(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:NetTopologySuite.Algorithm.LineIntersector.ComputeIntersect(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            This method computes the actual value of the intersection point.
            To obtain the maximum precision from the intersection calculation,
            the coordinates are normalized by subtracting the minimum
            ordinate values (in absolute value).  This has the effect of
            removing common significant digits from the calculation to
            maintain more bits of precision.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.IntersectionSafe(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes a segment intersection using homogeneous coordinates.
            Round-off error can cause the raw computation to fail,
            (usually due to the segments being approximately parallel).
            If this happens, a reasonable approximation is computed instead.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.IsInSegmentEnvelopes(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a point lies in the envelopes of both input segments.
            A correctly computed intersection point should return <c>true</c>
            for this test.
            Since this test is for debugging purposes only, no attempt is
            made to optimize the envelope test.
            </summary>
            <param name="intPoint"></param>
            <returns><c>true</c> if the input point lies within both input segment envelopes.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.NearestEndpoint(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds the endpoint of the segments P and Q which
            is closest to the other segment.
            This is a reasonable surrogate for the true
            intersection points in ill-conditioned cases
            (e.g. where two segments are nearly coincident,
            or where the endpoint of one segment lies almost on the other segment).
            </summary>
            <remarks>
            This replaces the older CentralEndpoint heuristic,
            which chose the wrong endpoint in some cases
            where the segments had very distinct slopes
            and one endpoint lay almost on the other segment.
            </remarks>
            <param name="p1">an endpoint of segment P</param>
            <param name="p2">an endpoint of segment P</param>
            <param name="q1">an endpoint of segment Q</param>
            <param name="q2">an endpoint of segment Q</param>
            <returns>the nearest endpoint to the other segment</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.zGetOrInterpolate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets the Z value of a coordinate if present, or
            interpolates it from the segment it lies on.
            If the segment Z values are not fully populate
            NaN is returned.
            </summary>
            <param name="p">A coordinate, possibly with Z</param>
            <param name="p1">A segment endpoint, possibly with Z</param>
            <param name="p2">A segment endpoint, possibly with Z</param>
            <returns>The extracted or interpolated Z value (may be NaN)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.zInterpolate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Interpolates a Z value for a point along
            a line segment between two points.
            The Z value of the interpolation point (if any) is ignored.
            If either segment point is missing Z,
            returns NaN.
            </summary>
            <param name="p">A coordinate, possibly with Z</param>
            <param name="p1">A segment endpoint, possibly with Z</param>
            <param name="p2">A segment endpoint, possibly with Z</param>
            <returns>The extracted or interpolated Z value (may be NaN)</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector.zInterpolate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Interpolates a Z value for a point along
            two line segments and computes their average.
            The Z value of the interpolation point (if any) is ignored.
            If one segment point is missing Z that segment is ignored
            if both segments are missing Z, returns NaN.
            </summary>
            <param name="p">A coordinate</param>
            <param name="p1">A segment endpoint, possibly with Z</param>
            <param name="p2">A segment endpoint, possibly with Z</param>
            <param name="q1">A segment endpoint, possibly with Z</param>
            <param name="q2">A segment endpoint, possibly with Z</param>
            <returns>The averaged interpolated Z value (may be NaN)</returns>    
        </member>
        <member name="T:NetTopologySuite.DataStructures.Interval">
            <summary>
            Structure for a closed 1-dimensional &#x211d;-interval
            </summary>
        </member>
        <member name="F:NetTopologySuite.DataStructures.Interval.Min">
            <summary>
            The lower bound of the interval
            </summary>
        </member>
        <member name="F:NetTopologySuite.DataStructures.Interval.Max">
            <summary>
            The upper bound of the interval
            </summary>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.#ctor(System.Double)">
            <summary>
            Initializes this structure with <see cref="F:NetTopologySuite.DataStructures.Interval.Min"/> = <see cref="F:NetTopologySuite.DataStructures.Interval.Max"/> = <paramref name="value"/>
            </summary>
            <param name="value">The value for min and max</param>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.#ctor(System.Double,System.Double)">
            <summary>
            Initializes this structure with <paramref name="min"/> and <paramref name="max"/> values
            </summary>
            <param name="min">The minimum interval values</param>
            <param name="max">The maximum interval values</param>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.ExpandedByValue(System.Double)">
            <summary>
            Method to expand 
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.DataStructures.Interval.IsEmpty">
            <summary>
            Gets a value if this interval is empty/undefined
            </summary>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode" />
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Equals(NetTopologySuite.DataStructures.Interval)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)" />
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.ToString">
            <inheritdoc/>
        </member>
        <member name="P:NetTopologySuite.DataStructures.Interval.Width">
            <summary>
            Gets a value indicating the width of the <see cref="T:NetTopologySuite.DataStructures.Interval"/>
            </summary>
        </member>
        <member name="P:NetTopologySuite.DataStructures.Interval.Centre">
            <summary>
            Gets a value indicating the centre of the interval (Min + Width * 0.5)
            </summary>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.ExpandedByInterval(NetTopologySuite.DataStructures.Interval)">
            <summary>
            Function to compute an interval that contains this and <paramref name="interval"/> <see cref="T:NetTopologySuite.DataStructures.Interval"/>
            </summary>
            <param name="interval">The interval</param>
            <returns>An interval</returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Overlaps(NetTopologySuite.DataStructures.Interval)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> overlaps <paramref name="interval"/>.
            </summary>
            <param name="interval">The interval to test</param>
            <returns><c>true</c> if this interval overlaps <paramref name="interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Overlaps(System.Double,System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> overlaps the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>].
            </summary>
            <param name="min">The minimum value of the interval</param>
            <param name="max">The maximum value of the interval</param>
            <returns><c>true</c> if this interval overlaps the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>]</returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Contains(NetTopologySuite.DataStructures.Interval)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> contains <paramref name="interval"/>.
            </summary>
            <remarks>This is more rigid than <see cref="M:NetTopologySuite.DataStructures.Interval.Overlaps(NetTopologySuite.DataStructures.Interval)"/></remarks>
            <param name="interval">The interval to test</param>
            <returns><c>true</c> if this interval contains <paramref name="interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Contains(System.Double,System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> contains the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>].
            </summary>
            <remarks>This is more rigid than <see cref="M:NetTopologySuite.DataStructures.Interval.Overlaps(System.Double,System.Double)"/></remarks>
            <param name="min">The minimum value of the interval</param>
            <param name="max">The maximum value of the interval</param>
            <returns><c>true</c> if this interval contains the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>]</returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Contains(System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> contains the value <paramref name="p"/>.
            </summary>
            <param name="p">The value to test</param>
            <returns><c>true</c> if this interval contains the value <paramref name="p"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Intersects(NetTopologySuite.DataStructures.Interval)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> intersects the interval <paramref name="other"/>.
            </summary>
            <param name="other"></param>
            <returns></returns>
            <returns><c>true</c> if this interval intersects <paramref name="other"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Intersects(System.Double,System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.DataStructures.Interval"/> intersects the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>].
            </summary>
            <param name="min">The minimum value of the interval</param>
            <param name="max">The maximum value of the interval</param>
            <returns><c>true</c> if this interval intersects the interval &#x211d;[<paramref name="min"/>, <paramref name="max"/>].</returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Create">
            <summary>
            Creates an empty or uninitialized Interval
            </summary>
            <returns>An empty or uninitialized <see cref="T:NetTopologySuite.DataStructures.Interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Create(System.Double)">
            <summary>
            Creates an interval with the range &#x211d;[<paramref name="value"/>,<paramref name="value"/>]
            </summary>
            <param name="value">The value</param>
            <returns>An <see cref="T:NetTopologySuite.DataStructures.Interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Create(System.Double,System.Double)">
            <summary>
            Creates an interval with the range &#x211d;[<paramref name="val1"/>,<paramref name="val2"/>]. <br/>
            If necessary, val1 and val2 are exchanged.
            </summary>
            <param name="val1">The minimum value</param>
            <param name="val2">The maximum value</param>
            <returns>An <see cref="T:NetTopologySuite.DataStructures.Interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.Create(NetTopologySuite.DataStructures.Interval)">
            <summary>
            Creates an interval with the range &#x211d;[<see cref="F:NetTopologySuite.DataStructures.Interval.Min"/>,<see cref="F:NetTopologySuite.DataStructures.Interval.Max"/>].
            </summary>
            <param name="interval">The template interval</param>
            <returns>An <see cref="T:NetTopologySuite.DataStructures.Interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.op_Equality(NetTopologySuite.DataStructures.Interval,NetTopologySuite.DataStructures.Interval)">
            <summary>
            Equality operator for <see cref="T:NetTopologySuite.DataStructures.Interval"/>s
            </summary>
            <param name="lhs">The left-hand-side <see cref="T:NetTopologySuite.DataStructures.Interval"/></param>
            <param name="rhs">The right-hand-side <see cref="T:NetTopologySuite.DataStructures.Interval"/></param>
            <returns><c>true</c> if the <see cref="T:NetTopologySuite.DataStructures.Interval"/>s are equal.</returns>
        </member>
        <member name="M:NetTopologySuite.DataStructures.Interval.op_Inequality(NetTopologySuite.DataStructures.Interval,NetTopologySuite.DataStructures.Interval)">
            <summary>
            Inequality operator for <see cref="T:NetTopologySuite.DataStructures.Interval"/>s
            </summary>
            <param name="lhs">The left-hand-side <see cref="T:NetTopologySuite.DataStructures.Interval"/></param>
            <param name="rhs">The right-hand-side <see cref="T:NetTopologySuite.DataStructures.Interval"/></param>
            <returns><c>true</c> if the <see cref="T:NetTopologySuite.DataStructures.Interval"/>s are <b>not</b> equal.</returns>
        </member>
        <member name="T:NetTopologySuite.Densify.Densifier">
            <summary>
            Densifies a geometry by inserting extra vertices along the line segments
            contained in the geometry.
            All segments in the created densified geometry will be <b>no longer</b>
            than the given distance tolerance
            (that is, all segments in the output will have length less than or equal to
            the distance tolerance).
            </summary>
            <remarks>
            Densified polygonal geometries are guaranteed to be topologically correct.
            <para/>
            The coordinates created during densification respect the input geometry's <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            <para/>
            By default polygonal results are processed to ensure they are valid.
            This processing is costly, and it is very rare for results to be invalid.
            Validation processing can be disabled by setting the <see cref="P:NetTopologySuite.Densify.Densifier.Validate"/> property to <c>false</c>.
            <para/>
            <b>Note:</b> At some future point this class will offer a variety of densification strategies.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier.Densify(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Densifies a geometry using a given distance tolerance, and respecting the input geometry's <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            </summary>
            <param name="geom">The geometry densify</param>
            <param name="distanceTolerance">The distance tolerance (<see cref="P:NetTopologySuite.Densify.Densifier.DistanceTolerance"/>)</param>
            <returns>The densified geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier.DensifyPoints(NetTopologySuite.Geometries.Coordinate[],System.Double,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Densifies a list of coordinates.
            </summary>
            <param name="pts">The coordinate list</param>
            <param name="distanceTolerance">The densify tolerance</param>
            <param name="precModel">The precision model to apply on the new coordinates</param>
            <returns>The densified coordinate sequence</returns>
        </member>
        <member name="F:NetTopologySuite.Densify.Densifier._validate">
            <summary>
            Indicates whether areas should be topologically validated.
            <br/><b>Note:</b> JTS name <c>_isValidated</c>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>Creates a new densifier instance</summary>
            <param name="inputGeom">The geometry to densify</param>
        </member>
        <member name="P:NetTopologySuite.Densify.Densifier.DistanceTolerance">
            <summary>
            Gets or sets the distance tolerance for the densification. All line segments
            in the densified geometry will be no longer than the distance tolerance.
            The distance tolerance must be positive.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Densify.Densifier.Validate">
            <summary>
            Gets or sets whether polygonal results are processed to ensure they are valid.
            </summary>
            <returns><c>true</c> if polygonal input is validated.</returns>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier.GetResultGeometry">
            <summary>
            Gets the densified geometry.
            </summary>
            <returns>The densified geometry</returns>
        </member>
        <member name="F:NetTopologySuite.Densify.Densifier.DensifyTransformer._validate">
            <summary>
            Indicates whether areas should be topologically validated.
            <br/><b>Note:</b> JTS name <c>_isValidated</c>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier.DensifyTransformer.CreateValidArea(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a valid area geometry from one that possibly has bad topology
            (i.e. self-intersections). Since buffer can handle invalid topology, but
            always returns valid geometry, constructing a 0-width buffer "corrects"
            the topology. Note this only works for area geometries, since buffer
            always returns areas. This also may return empty geometries, if the input
            has no actual area.
            </summary>
            <param name="roughAreaGeom">An area geometry possibly containing self-intersections</param>
            <returns>A valid area geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Dissolve.DissolveEdgeGraph">
            <summary>
            A graph containing <see cref="T:NetTopologySuite.Dissolve.DissolveHalfEdge"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Dissolve.DissolveEdgeGraph.CreateEdge(NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc/>
        </member>
        <member name="T:NetTopologySuite.Dissolve.DissolveHalfEdge">
            <summary>
            A HalfEdge which carries information
            required to support <see cref="T:NetTopologySuite.Dissolve.LineDissolver"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Dissolve.DissolveHalfEdge.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of a <c>DissolveHalfEdge</c> using the provided origin.
            </summary>
            <param name="orig">The origin</param>
        </member>
        <member name="P:NetTopologySuite.Dissolve.DissolveHalfEdge.IsStart">
            <summary>
            Tests whether this edge is the starting segment
            in a LineString being dissolved.
            </summary>
            <returns><c>true</c> if this edge is a start segment</returns>
        </member>
        <member name="M:NetTopologySuite.Dissolve.DissolveHalfEdge.SetStart">
            <summary>
            Sets this edge to be the start segment of an input LineString.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Dissolve.LineDissolver">
            <summary>
            Dissolves the linear components
            from a collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            into a set of maximal-length <see cref="T:NetTopologySuite.Geometries.LineString"/>s
            in which every unique segment appears once only.
            The output linestrings run between node vertices
            of the input, which are vertices which have
            either degree 1, or degree 3 or greater.
            </summary>
            <remarks>
            Use cases for dissolving linear components
            include generalization
            (in particular, simplifying polygonal coverages),
            and visualization
            (in particular, avoiding symbology conflicts when
            depicting shared polygon boundaries).
            </remarks>
            <remarks>
            This class does NOT node the input lines.
            If there are line segments crossing in the input,
            they will still cross in the output.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.Dissolve(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Dissolves the linear components in a geometry.
            </summary>
            <param name="g">the geometry to dissolve</param>
            <returns>the dissolved lines</returns>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.#ctor">
            <summary>
            Creates an instance of this class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to be dissolved.
            Any number of geometries may be added by calling this method multiple times.
            Any type of Geometry may be added.  The constituent linework will be
            extracted to be dissolved.
            </summary>
            <param name="geometry">geometry to be line-merged</param>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Adds a collection of Geometries to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometries">the geometries to be line-merged</param>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.GetResult">
            <summary>
            Gets the dissolved result as a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <returns>the dissolved lines</returns>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.BuildLines">
            <summary>
            For each edge in stack
            (which must originate at a node)
            extracts the line it initiates.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.UpdateRingStartEdge(NetTopologySuite.Dissolve.DissolveHalfEdge)">
            <summary>
            Updates the tracked ringStartEdge
            if the given edge has a lower origin
            (using the standard <see cref="T:NetTopologySuite.Geometries.Coordinate"/> ordering).
            </summary>
            <remarks>
            Identifying the lowest starting node meets two goals:
            * It ensures that isolated input rings are created using the original node and orientation.
            * For isolated rings formed from multiple input linestrings,
            it provides a canonical node and orientation for the output
            (rather than essentially random, and thus hard to test).
            </remarks>
            <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.BuildLine(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Builds a line starting from the given edge.
            The start edge origin is a node (valence = 1 or >= 3),
            unless it is part of a pure ring.
            </summary>
            <remarks>
            A pure ring has no other incident lines.
            In this case the start edge may occur anywhere on the ring.
            </remarks>
            <remarks>
            The line is built up to the next node encountered,
            or until the start edge is re-encountered
            (which happens if the edges form a ring).
            </remarks>
            <param name="eStart"></param>
        </member>
        <member name="M:NetTopologySuite.Dissolve.LineDissolver.StackEdges(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Adds edges around this node to the stack.
            </summary>
            <param name="node"></param>
        </member>
        <member name="T:NetTopologySuite.EdgeGraph.EdgeGraph">
            <summary>
            A graph comprised of <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/>s.
            It supports tracking the vertices in the graph
            via edges incident on them,
            to allow efficient lookup of edges and vertices.
            </summary>
            <remarks>
            This class may be subclassed to use a
            different subclass of HalfEdge,
            by overriding <see cref="M:NetTopologySuite.EdgeGraph.EdgeGraph.CreateEdge(NetTopologySuite.Geometries.Coordinate)"/>.
            If additional logic is required to initialize
            edges then <see cref="M:NetTopologySuite.EdgeGraph.EdgeGraph.AddEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
            can be overridden as well.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.CreateEdge(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a single HalfEdge.
            Override to use a different HalfEdge subclass.
            </summary>
            <param name="orig">the origin location</param>
            <returns>a new <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/> with the given origin</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.Create(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/> pair, using the <c>HalfEdge</c> type of the graph subclass
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns>A <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/> pair</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.AddEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds an edge between the coordinates orig and dest
            to this graph.
            </summary>
            <remarks>
            Only valid edges can be added (in particular, zero-length segments cannot be added)
            </remarks>
            <param name="orig">the edge origin location</param>
            <param name="dest">the edge destination location</param>
            <returns>The created edge</returns>
            <returns><c>null</c> if the edge was invalid and not added</returns>
            <seealso cref="M:NetTopologySuite.EdgeGraph.EdgeGraph.IsValidEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.IsValidEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Test if an the coordinates for an edge form a valid edge (with non-zero length)
            </summary>
            <param name="orig">The start coordinate</param>
            <param name="dest">The end coordinate</param>
            <returns><c>true</c> of the edge formed is valid</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.Insert(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Inserts an edge not already present into the graph.
            </summary>
            <param name="orig">the edge origin location</param>
            <param name="dest">the edge destination location</param>
            <param name="eAdj">an existing edge with same orig (if any)</param>
            <returns>the created edge</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.GetVertexEdges">
            <summary>
            Gets all <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/>s in the graph.
            Both edges of edge pairs are included.
            </summary>
            <returns>An enumeration of the graph edges</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraph.FindEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds an edge in this graph with the given origin
            and destination, if one exists.
            </summary>
            <param name="orig">the origin location</param>
            <param name="dest">the destination location</param>
            <returns>an edge with the given orig and dest, or null if none exists</returns>
        </member>
        <member name="T:NetTopologySuite.EdgeGraph.EdgeGraphBuilder">
            <summary>
            Builds an edge graph from geometries containing edges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraphBuilder.Build(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Factory method to build an <c>EdgeGraph</c>.
            </summary>
            <param name="geoms">The geometries to make up the <c>EdgeGraph</c></param>
            <returns>An <c>EdgeGraph</c> of the <paramref name="geoms"/></returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraphBuilder.#ctor">
            <summary>
            Creates a new <c>EdgeGraphBuilder</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraphBuilder.GetGraph">
            <summary>
            Gets the created <c>EdgeGraph</c>
            </summary>
            <returns>The created <c>EdgeGraph</c></returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraphBuilder.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds the edges of a Geometry to the graph.
            May be called multiple times.
            Any dimension of Geometry may be added; the constituent edges are extracted.
            </summary>
            <param name="geometry">geometry to be added</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.EdgeGraphBuilder.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
             Adds the edges in a collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s to the graph.
            May be called multiple times.
            Any dimension of <see cref="T:NetTopologySuite.Geometries.Geometry"/> may be added.
            </summary>
            <param name="geometries">the geometries to be added</param>
        </member>
        <member name="T:NetTopologySuite.EdgeGraph.HalfEdge">
            <summary>
            Represents a directed component of an edge in an <see cref="T:NetTopologySuite.EdgeGraph.EdgeGraph"/>.
            HalfEdges link vertices whose locations are defined by <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            HalfEdges start at an <b>origin</b> vertex,
            and terminate at a <b>destination</b> vertex.
            HalfEdges always occur in symmetric pairs, with the <see cref="P:NetTopologySuite.EdgeGraph.HalfEdge.Sym"/> method
            giving access to the oppositely-oriented component.
            HalfEdges and the methods on them form an edge algebra,
            which can be used to traverse and query the topology
            of the graph formed by the edges.
            <para/>
            To support graphs where the edges are sequences of coordinates
            each edge may also have a direction point supplied.
            This is used to determine the ordering
            of the edges around the origin.
            HalfEdges with the same origin are ordered
            so that the ring of edges formed by them is oriented CCW.
            <para/>
            By design HalfEdges carry minimal information
            about the actual usage of the graph they represent.
            They can be subclassed to carry more information if required.
            <para/>
            HalfEdges form a complete and consistent data structure by themselves,
            but an <see cref="T:NetTopologySuite.EdgeGraph.EdgeGraph"/> is useful to allow retrieving edges
            by vertex and edge location, as well as ensuring
            edges are created and linked appropriately.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Create(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
             Creates a HalfEdge pair representing an edge
            between two vertices located at coordinates p0 and p1.
            </summary>
            <param name="p0">a vertex coordinate</param>
            <param name="p1">a vertex coordinate</param>
            <returns>the HalfEdge with origin at p0</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Init(NetTopologySuite.EdgeGraph.HalfEdge,NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Initialize a symmetric pair of halfedges.
            Intended for use by <see cref="T:NetTopologySuite.EdgeGraph.EdgeGraph" />
            subclasses.
            <para/>
            The edges are initialized to have each other
            as the <see cref="P:NetTopologySuite.EdgeGraph.HalfEdge.Sym"/> edge, and to have
            <see cref="P:NetTopologySuite.EdgeGraph.HalfEdge.Next"/> pointers which point to edge other.
            This effectively creates a graph containing a single edge.
            </summary>
            <param name="e0">A halfedge</param>
            <param name="e1">A symmetric halfedge</param>
            <returns>The initialized edge e0</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an edge originating from a given coordinate.
            </summary>
            <param name="orig">the origin coordinate</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Link(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Links this edge with its sym (opposite) edge.
            This must be done for each pair of edges created.
            </summary>
            <param name="sym">The sym edge to link.</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Init(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Initializes this edge with <paramref name="e"/> as <see cref="P:NetTopologySuite.EdgeGraph.HalfEdge.Sym"/> edge.
            </summary>
            <param name="e">A symmetric half edge.</param>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.Orig">
            <summary>
            Gets the origin coordinate of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.Dest">
            <summary>
            Gets the destination coordinate of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.DirectionX">
            <summary>
            Gets a value indicating the X component of the direction vector.
            </summary>
            <returns>The X component of the direction vector</returns>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.DirectionY">
            <summary>
            Gets a value indicating the Y component of the direction vector.
            </summary>
            <returns>The Y component of the direction vector</returns>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.DirectionPt">
            <summary>
            Gets a value indicating the direction point of this edge.
            In the base case this is the dest coordinate
            of the edge.
            <para/>
            Subclasses may override to
            allow a HalfEdge to represent an edge with more than two coordinates.
            </summary>
            <returns>The direction point for the edge</returns>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.Sym">
            <summary>
            Gets or sets the symmetric (opposite) edge of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.Next">
            <summary>
            Gets the next edge CCW around the destination vertex of this edge.
            If the destination vertex has degree <c>1</c> then this is the <c>Sym</c> edge.
            </summary>
            <returns>The next outgoing edge CCW around the destination vertex</returns>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.Prev">
            <summary>
            Gets the previous edge CW around the origin
            vertex of this edge,
            with that vertex being its destination.
            <para/>
            It is always true that <c>e.Next.Prev == e</c>
            <para/>
            Note that this requires a scan of the origin edges,
            so may not be efficient for some uses.
            </summary>
            <returns>The previous edge CW around the origin vertex</returns>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.ONext">
            <summary>
            Gets the next edge CCW around the origin of this edge,
            with the same origin.<br/>
            If the origin vertex has degree <c>1</c> then this is the edge itself.
            <para/>
            <c>e.ONext</c> is equal to <c>e.Sym.Next()</c>
            </summary>
            <returns>The next edge around the origin</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Find(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds the edge starting at the origin of this edge
            with the given dest vertex, if any.
            </summary>
            <param name="dest">the dest vertex to search for</param>
            <returns>
            the edge with the required dest vertex,
            if it exists, or null
            </returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Equals(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether this edge has the given orig and dest vertices.
            </summary>
            <param name="p0">the origin vertex to test</param>
            <param name="p1">the destination vertex to test</param>
            <returns><c>true</c> if the vertices are equal to the ones of this edge</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Insert(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Inserts an edge
            into the ring of edges around the origin vertex of this edge,
            ensuring that the edges remain ordered CCW.
            The inserted edge must have the same origin as this edge.
            </summary>
            <param name="eAdd">the edge to insert</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.InsertionEdge(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Finds the insertion edge for a edge
            being added to this origin,
            ensuring that the star of edges
            around the origin remains fully CCW.
            </summary>
            <param name="eAdd">The edge being added</param>
            <returns>The edge to insert after</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.InsertAfter(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Insert an edge with the same origin after this one.
            Assumes that the inserted edge is in the correct
            position around the ring.
            </summary>
            <param name="e">the edge to insert (with same origin)</param>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.IsEdgesSorted">
            <summary>
            Tests whether the edges around the origin
            are sorted correctly.
            Note that edges must be strictly increasing,
            which implies no two edges can have the same direction point.
            </summary>
            <returns><c>true</c> if the origin edges are sorted correctly
            </returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.FindLowest">
            <summary>
            Finds the lowest edge around the origin,
            using the standard edge ordering.
            </summary>
            <returns>The lowest edge around the origin</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.CompareTo(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Compares edges which originate at the same vertex
            based on the angle they make at their origin vertex with the positive X-axis.
            This allows sorting edges around their origin vertex in CCW order.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.CompareAngularDirection(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Implements the total order relation.
            The angle of edge a is greater than the angle of edge b,
            where the angle of an edge is the angle made by
            the first segment of the edge with the positive x-axis.
            When applied to a list of edges originating at the same point,
            this produces a CCW ordering of the edges around the point.
            Using the obvious algorithm of computing the angle is not robust,
            since the angle calculation is susceptible to round off error.
            </summary>
            <remarks>
            A robust algorithm is:
            1. compare the quadrants the edge vectors lie in.
            If the quadrants are different,
            it is trivial to determine which edge has a greater angle.
            2. If the vectors lie in the same quadrant, the
            <see cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/> function
            can be used to determine the relative orientation of the vectors.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.DeltaX">
            <summary>
            The X component of the distance between the orig and dest vertices.
            </summary>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.HalfEdge.DeltaY">
            <summary>
            The Y component of the distance between the orig and dest vertices.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.ToString">
            <summary>
            Computes a string representation of a HalfEdge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.ToStringNode">
            <summary>
            Provides a string representation of the edges around
            the origin node of this edge.
            </summary>
            <remarks>
            Uses the subclass representation for each edge.
            </remarks>
            <returns>A string showing the edges around the origin</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.Degree">
            <summary>
            Computes the degree of the origin vertex.
            The degree is the number of edges
            originating from the vertex.
            </summary>
            <returns>the degree of the origin vertex</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.HalfEdge.PrevNode">
            <summary>
            Finds the first node previous to this edge, if any.
            If no such node exists (i.e. the edge is part of a ring)
            then null is returned.
            </summary>
            <returns>
            an edge originating at the node prior to this edge, if any,
            or null if no node exists
            </returns>
        </member>
        <member name="T:NetTopologySuite.EdgeGraph.MarkHalfEdge">
            <summary>
            A <see cref="T:NetTopologySuite.EdgeGraph.HalfEdge"/> which supports
            marking edges with a boolean flag.
            Useful for algorithms which perform graph traversals.
            </summary>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.IsMarked(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Returns a value indicating that the given edge is marked.
            </summary>
            <param name="e">An edge</param>
            <returns><c>true</c> if the edge is marked</returns>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.Mark(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Marks the edge.
            </summary>
            <param name="e">An edge to mark</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.SetMark(NetTopologySuite.EdgeGraph.HalfEdge,System.Boolean)">
            <summary>
            Sets the mark for the given edge to a boolean value.
            </summary>
            <param name="e">An Edge to update</param>
            <param name="isMarked">The mark value to set</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.SetMarkBoth(NetTopologySuite.EdgeGraph.HalfEdge,System.Boolean)">
            <summary>
            Sets the mark for the given edge pair to a boolean value.
            </summary>
            <param name="e">an edge of the pair to update</param>
            <param name="isMarked">the mark value to set</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.MarkBoth(NetTopologySuite.EdgeGraph.HalfEdge)">
            <summary>
            Marks the edges in a pair.
            </summary>
            <param name="e">an edge of the pair to mark</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new marked edge.
            </summary>
            <param name="orig">the coordinate of the edge origin</param>
        </member>
        <member name="M:NetTopologySuite.EdgeGraph.MarkHalfEdge.Mark">
            <summary>
            Marks this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.EdgeGraph.MarkHalfEdge.Marked">
            <summary>
            Gets or sets a value indicating if this <c>MarkHalfEdge</c> is marked
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Coordinate">
            <summary>
            A lightweight class used to store coordinates on the 2-dimensional Cartesian plane.
            <para>
            The base data object is suitable for use with coordinate sequences with
            <c>dimension</c> = 2 and <c>measures</c> = 0.
            </para>
            </summary>
            <remarks>
            It is distinct from <see cref="T:NetTopologySuite.Geometries.Point"/>, which is a subclass of <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Unlike objects of type <see cref="T:NetTopologySuite.Geometries.Point"/> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>Coordinate</c> only contains ordinate values
            and properties.
            <para/>
            Implementations may optionally support Z-ordinate and M-measure values
            as appropriate for a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>. Use of <see cref="P:NetTopologySuite.Geometries.Coordinate.Z"/>
            and <see cref="P:NetTopologySuite.Geometries.Coordinate.M"/> setters or <see cref="P:NetTopologySuite.Geometries.Coordinate.this[int]" /> indexer are recommended.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate">
            <summary>
             The value used to indicate a null or missing ordinate value.
             In particular, used for the value of ordinates for dimensions
             greater than the defined dimension of a coordinate.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.X">
            <summary>
            Gets or sets the X-ordinate value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.Y">
            <summary>
            Gets or sets the Y-ordinate value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.Z">
            <summary>
            Gets or sets the Z-ordinate value, if supported.
            If no Z value is present, returns <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if an attempt is made to <b>set</b> the Z-ordinate value on an instance where
            the Z-ordinate value is not supported.
            </exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.M">
            <summary>
            Gets or sets the value of the measure, if supported.
            If no measure value is present, returns <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if an attempt is made to <b>set</b> the measure value on an instance where
            measures are not supported.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a <c>Coordinate</c> at (x,y).
            </summary>
            <param name="x">The X value</param>
            <param name="y">The Y value</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.#ctor">
            <summary>
             Constructs a <c>Coordinate</c> at (0,0).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a <c>Coordinate</c> having the same (x,y,z) values as
            <paramref name="c"/>.
            </summary>
            <param name="c"><c>Coordinate</c> to copy.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.Item(NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Gets or sets the value for the given ordinate.
            </summary>
            <param name="ordinate">The ordinate.</param>
            <returns>The ordinate value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="ordinate"/> is not one of <see cref="F:NetTopologySuite.Geometries.Ordinate.X"/>, <see cref="F:NetTopologySuite.Geometries.Ordinate.Y"/>, <see cref="F:NetTopologySuite.Geometries.Ordinate.Z"/>, or <see cref="F:NetTopologySuite.Geometries.Ordinate.M"/>.</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.Item(System.Int32)">
            <summary>
            Gets or sets the ordinate value for the given index.
            </summary>
            <remarks>
            The base implementation supports 0 (X) and 1 (Y) as values for the index.
            </remarks>
            <param name="ordinateIndex">The ordinate index</param>
            <returns>The ordinate value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="ordinateIndex"/> is not in the valid range.</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.CoordinateValue">
            <summary>
            Gets/Sets <c>Coordinate</c>s (x,y,z) values.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Coordinate.IsValid">
            <summary>Gets a value indicating if the <c>Coordinate</c>
            has valid x- and y ordinate values
            <para/>
            An ordinate value is valid if it is finite.
            </summary>
            <returns><c>true</c> if the coordinate is valid</returns>
            <see cref="M:System.Double.IsInfinity(System.Double)"/>
            <see cref="M:System.Double.IsNaN(System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.IsFinite(System.Double)">
            <summary>
            Predicate to check if a <see cref="T:System.Double"/> value is finite.
            <para/>
            It is finite if both <see cref="M:System.Double.IsInfinity(System.Double)"/> and <see cref="M:System.Double.IsNaN(System.Double)"/> return <c>false</c>
            </summary>
            <param name="value">The value to test</param>
            <returns><c>value</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Equals2D(NetTopologySuite.Geometries.Coordinate)">
             <summary>
             Returns whether the planar projections of the two <c>Coordinate</c>s are equal.
            </summary>
             <param name="other"><c>Coordinate</c> with which to do the 2D comparison.</param>
             <returns>
             <c>true</c> if the x- and y-coordinates are equal;
             the Z coordinates do not have to be equal.
             </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Equals2D(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Tests if another Coordinate has the same values for the X and Y ordinates,
            within a specified tolerance value.  The Z ordinate is ignored.
            </summary>
            <param name="c">A <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.</param>
            <param name="tolerance">The tolerance value to use.</param>
            <returns><c>true</c> if the X and Y ordinates are within the given tolerance.</returns>
            <remarks>The Z ordinate is ignored.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Equals(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
              -1  : this.x &lt; other.x || ((this.x == other.x) AND (this.y &lt; other.y))
               0  : this.x == other.x AND this.y = other.y
               1  : this.x &gt; other.x || ((this.x == other.x) AND (this.y &gt; other.y))
            </summary>
            <param name="o"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.CompareTo(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
              -1  : this.x &lt; other.x || ((this.x == other.x) AND (this.y &lt; other.y))
               0  : this.x == other.x AND this.y = other.y
               1  : this.x &gt; other.x || ((this.x == other.x) AND (this.y &gt; other.y))
            </summary>
            <param name="other"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Copy">
            <summary>
            Create a copy of this <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <returns>A copy of this coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Create(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a Coordinate of the same type as this Coordinate, using the provided values.
            </summary>
            <remarks>Depending on the actual type the following limitations are in place:
            <list type="table">
            <listheader><term>Coordinate (Sub-)Class</term><description>Limitation</description></listheader>
            <item><term><c>Coordinate</c></term><description><paramref name="z"/>-parameter and <paramref name="m"/>-parameter are silently dropped.</description></item>
            <item><term><c>CoordinateZ</c></term><description><paramref name="m"/>-parameter is silently dropped.</description></item>
            <item><term><c>CoordinateM</c></term><description><paramref name="z"/>-parameter is silently dropped.</description></item>
            <item><term><c>CoordinateZM</c></term><description>No parameter is dropped.</description></item>
            </list>
            </remarks>
            <param name="x">The x-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="y">The y-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="z">The z-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <param name="m">The m-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <returns>A new <see cref="T:NetTopologySuite.Geometries.Coordinate"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Distance(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the 2-dimensional Euclidean distance to another location.
            </summary>
            <param name="c">A <see cref="T:NetTopologySuite.Geometries.Coordinate"/> with which to do the distance comparison.</param>
            <returns>the 2-dimensional Euclidean distance between the locations.</returns>
            <remarks>The Z-ordinate is ignored.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <c>other</c> has the same values for the x and y ordinates.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            </summary>
            <param name="o"><c>Coordinate</c> with which to do the comparison.</param>
            <returns><c>true</c> if <c>other</c> is a <c>Coordinate</c> with the same values for the x and y ordinates.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.GetHashCode">
            <summary>
            Gets a hashcode for this coordinate.
            </summary>
            <returns>A hashcode for this coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinate.ToString">
            <summary>
            Returns a <c>string</c> of the form <I>(x,y,z)</I> .
            </summary>
            <returns><c>string</c> of the form <I>(x,y,z)</I></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateArrays">
            <summary>
            Useful utility functions for handling Coordinate arrays.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Dimension(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determine dimension based on subclass of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="pts">pts supplied coordinates</param>
            <returns>number of ordinates recorded</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Measures(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determine number of measures based on subclass of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="pts">supplied coordinates</param>
            <returns>number of measures recorded</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.EnforceConsistency(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Utility method ensuring array contents are of consistent dimension and measures.
            <para/>
            Array is modified in place if required, coordinates are replaced in the array as required
            to ensure all coordinates have the same dimension and measures. The final dimension and
            measures used are the maximum found when checking the array.
            </summary>
            <param name="array">Modified in place to coordinates of consistent dimension and measures.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.EnforceConsistency(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Utility method ensuring array contents are of the specified dimension and measures.
            <para/>
            Array is returned unmodified if consistent, or a copy of the array is made with
            each inconsistent coordinate duplicated into an instance of the correct dimension and measures.
            </summary>
            <param name="array">A coordinate array</param>
            <param name="dimension"></param>
            <param name="measures"></param>
            <returns>Input array or copy created if required to enforce consistency.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.IsRing(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s forms a ring, by checking length and closure.
            Self-intersection is not checked.
            </summary>
            <param name="pts">An array of Coordinates</param>
            <returns>true if the coordinate form a ring.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.PointNotInList(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Finds a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in a list of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s
            which is not contained in another list of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="testPts">The <see cref="T:NetTopologySuite.Geometries.Coordinate" />s to test.</param>
            <param name="pts">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s to test the input points against.</param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Coordinate" /> from <paramref name="testPts" />
            which is not in <paramref name="pts" />, or <c>null</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Compare(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.Coordinate" /> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.IncreasingDirection(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determines which orientation of the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array is (overall) increasing.
            In other words, determines which end of the array is "smaller"
            (using the standard ordering on <see cref="T:NetTopologySuite.Geometries.Coordinate" />).
            Returns an integer indicating the increasing direction.
            If the sequence is a palindrome, it is defined to be
            oriented in a positive direction.
            </summary>
            <param name="pts">The array of Coordinates to test.</param>
            <returns>
            <c>1</c> if the array is smaller at the start or is a palindrome,
            <c>-1</c> if smaller at the end.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.IsEqualReversed(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Determines whether two <see cref="T:NetTopologySuite.Geometries.Coordinate" /> arrays of equal length
            are equal in opposite directions.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.CopyDeep(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a deep copy of the argument <c>Coordinate</c> array.
            </summary>
            <param name="coordinates">Array of Coordinates.</param>
            <returns>Deep copy of the input.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.CopyDeep(NetTopologySuite.Geometries.Coordinate[],System.Int32,NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Creates a deep copy of a given section of a source <see cref="T:NetTopologySuite.Geometries.Coordinate"/> array into a destination Coordinate array.
            The destination array must be an appropriate size to receive the copied coordinates.
            </summary>
            <param name="src">An array of Coordinates</param>
            <param name="srcStart">The index to start copying from</param>
            <param name="dest">The array to receive the deep-copied coordinates</param>
            <param name="destStart">The destination index to start copying to</param>
            <param name="length">The number of items to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.ToCoordinateArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Converts the given <see cref="T:System.Collections.Generic.IEnumerable`1" /> of
            <see cref="T:NetTopologySuite.Geometries.Coordinate" />s into a <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array.
            </summary>
            <param name="coordList"><see cref="T:System.Collections.Generic.IEnumerable`1"/> of coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.HasRepeatedPoints(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns whether <see cref="M:NetTopologySuite.Geometries.Coordinate.Equals(System.Object)"/> returns true
            for any two consecutive coordinates in the given array.
            </summary>
            <param name="coord">An array of <c>Coordinate</c>s.</param>
            <returns>true if coord has repeated points; false otherwise.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.AtLeastNCoordinatesOrNothing(System.Int32,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns either the given coordinate array if its length is greater than
            the given amount, or an empty coordinate array.
            </summary>
            <param name="n">Length amount.</param>
            <param name="c">Array of Coordinates.</param>
            <returns>New Coordinate array.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.RemoveRepeatedPoints(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            If the coordinate array argument has repeated points,
            constructs a new array containing no repeated points.
            Otherwise, returns the argument.
            </summary>
            <param name="coord">An array of <c>Coordinate</c>s</param>
            <returns>The array with repeated coordinates removed</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.HasRepeatedOrInvalidPoints(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether an array has any repeated or invalid coordinates.
            </summary>
            <param name="coord">An array of coordinates</param>
            <returns><c>true</c> if the array contains repeated or invalid coordinates</returns>
            <see cref="P:NetTopologySuite.Geometries.Coordinate.IsValid"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.RemoveRepeatedOrInvalidPoints(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            If the coordinate array argument has repeated or invalid points,
            constructs a new array containing no repeated points.
            Otherwise, returns the argument.
            </summary>
            <param name="coord">An array of coordinates</param>
            <returns>The array with repeated or invalid coordinates removed.</returns>
            <see cref="M:NetTopologySuite.Geometries.CoordinateArrays.HasRepeatedOrInvalidPoints(NetTopologySuite.Geometries.Coordinate[])"/>
            <see cref="P:NetTopologySuite.Geometries.Coordinate.IsValid"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.RemoveNull(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Collapses a coordinate array to remove all null elements.
            </summary>
            <param name="coord">The coordinate array to collapse</param>
            <returns>An Array containing only non-null elements</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Reverse(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Reverses the coordinates in an array in-place.
            </summary>
            <param name="coord">Array of Coordinates.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Equals(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal (as compared using Coordinate.Equals).
            </summary>
            <param name="coord1">First array of Coordinates.</param>
            <param name="coord2">Second array of Coordinates.</param>
            <returns><c>true</c> if two Coordinates array are equals; false otherwise</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.Coordinate" /> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator.Compare(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Compares the specified <see cref="T:NetTopologySuite.Geometries.Coordinate" />s arrays.
            </summary>
            <param name="pts1">An array of coordinates</param>
            <param name="pts2">An array of coordinates</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator">
            <summary>
            A comparator for <see cref="T:NetTopologySuite.Geometries.Coordinate" /> arrays modulo their directionality.
            E.g. if two coordinate arrays are identical but reversed
            they will compare as equal under this ordering.
            If the arrays are not equal, the ordering returned
            is the ordering in the forward direction.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator.Compare(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Compares the specified <see cref="T:NetTopologySuite.Geometries.Coordinate" />s arrays.
            </summary>
            <param name="pts1">An array of coordinates</param>
            <param name="pts2">An array of coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator.OldCompare(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Equals(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[],System.Collections.Generic.IComparer{NetTopologySuite.Geometries.Coordinate[]})">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal, using a user-defined <see cref="T:System.Collections.IComparer" />
            for <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.
            </summary>
            <param name="coord1">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.</param>
            <param name="coord2">Another array of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.</param>
            <param name="coordinateComparer">
            A <see cref="T:System.Collections.IComparer" /> for <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.
            </param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.MinCoordinate(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns the minimum coordinate, using the usual lexicographic comparison.
            </summary>
            <param name="coordinates">Array to search.</param>
            <returns>The minimum coordinate in the array, found using <c>CompareTo</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Scroll(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Shifts the positions of the coordinates until <c>firstCoordinate</c> is first.
            </summary>
            <param name="coordinates">Array to rearrange.</param>
            <param name="firstCoordinate">Coordinate to make first.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Scroll(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Shifts the positions of the coordinates until the coordinate
            at <c>indexOfFirstCoordinate</c> is first.
            </summary>
            <param name="coordinates">The array of coordinates to arrange</param>
            <param name="indexOfFirstCoordinate">The index of the coordinate to make first</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Scroll(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Boolean)">
            <summary>
            Shifts the positions of the coordinates until the coordinate
            at <c>indexOfFirstCoordinate</c> is first.
            </summary>
            <remarks>
            If <paramref name="ensureRing"/> is <c>true</c>, first and last
            coordinate of the returned array are equal.
            </remarks>
            <param name="coordinates">The array of coordinates to arrange</param>
            <param name="indexOfFirstCoordinate">The index of the coordinate to make first</param>
            <param name="ensureRing">A flag indicating if returned array should form a ring.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.IndexOf(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns the index of <paramref name="coordinate" /> in <paramref name="coordinates" />.
            The first position is 0; the second is 1; etc.
            </summary>
            <param name="coordinate">A <see cref="T:NetTopologySuite.Geometries.Coordinate" /> to search for.</param>
            <param name="coordinates">A <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array to search.</param>
            <returns>The position of <c>coordinate</c>, or -1 if it is not found.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Extract(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Extracts a subsequence of the input <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array
            from indices <paramref name="start" /> to <paramref name="end"/> (inclusive).
            The input indices are clamped to the array size;
            If the end index is less than the start index,
            the extracted array will be empty.
            </summary>
            <param name="pts">The input array.</param>
            <param name="start">The index of the start of the subsequence to extract.</param>
            <param name="end">The index of the end of the subsequence to extract.</param>
            <returns>A subsequence of the input array.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Envelope(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the <see cref="M:NetTopologySuite.Geometries.CoordinateArrays.Envelope(NetTopologySuite.Geometries.Coordinate[])"/> of the coordinates.
            </summary>
            <param name="coordinates">the <see cref="T:NetTopologySuite.Geometries.Coordinate"/> array to scan.</param>
            <returns>the <see cref="M:NetTopologySuite.Geometries.CoordinateArrays.Envelope(NetTopologySuite.Geometries.Coordinate[])"/> of the <paramref name="coordinates"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateArrays.Intersection(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Envelope)">
            <summary>
            Extracts the coordinates which intersect an <see cref="M:NetTopologySuite.Geometries.CoordinateArrays.Envelope(NetTopologySuite.Geometries.Coordinate[])"/>.
            </summary>
            <param name="coordinates">The coordinates to scan</param>
            <param name="env">The envelope to intersect with</param>
            <returns>An array of coordinates which intersect with the envelope</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateEqualityComparer">
            <summary>
            A class that can be used to test coordinates for equality.
            <para/>
            It uses the algorithm that was default for NTS prior to v2.2,
            i.e. checks if the 2d distance between coordinates <c>x</c>
            and <c>y</c> is less than or equal to a tolerance value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateEqualityComparer.Equals(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:System.Collections.Generic.EqualityComparer`1.Equals(`0,`0)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateEqualityComparer.Equals(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Compares <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s <paramref name="x"/> and <paramref name="y"/> for equality allowing for a <paramref name="tolerance"/>.
            </summary>
            <param name="x">A <c>Coordinate</c></param>
            <param name="y">A <c>Coordinate</c></param>
            <param name="tolerance">A tolerance value.</param>
            <returns><c>true</c> if <paramref name="x"/> and <paramref name="y"/> can be considered equal; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateEqualityComparer.GetHashCode(NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:System.Collections.Generic.EqualityComparer`1.GetHashCode(`0)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateEqualityComparer.AreEqual(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Method to test 2 <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s for equality, allowing a tolerance.
            </summary>
            <param name="a">The 1st Coordinate</param>
            <param name="b">The 2nd Coordinate</param>
            <param name="tolerance">A tolerance value</param>
            <returns><c>true</c> if <paramref name="a"/> and <paramref name="b"/> can be considered equal.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.PerOrdinateEqualityComparer">
            <summary>
            A class that can be used to test coordinates for equality.
            <para/>
            This class test for each ordinate if the distance is less
            than a tolerance value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.PerOrdinateEqualityComparer.AreEqual(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Method to test 2 <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s for equality, allowing a tolerance.
            </summary>
            <param name="a">The 1st Coordinate</param>
            <param name="b">The 2nd Coordinate</param>
            <param name="tolerance">A tolerance value</param>
            <returns><c>true</c> if <paramref name="a"/> and <paramref name="b"/> can be considered equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PerOrdinateEqualityComparer.Distance(System.Double,System.Double)">
            <summary>
            Computes the distance between two <see cref="T:System.Double"/> values
            </summary>
            <param name="a">1st double</param>
            <param name="b">2nd double</param>
            <returns>The distance between <paramref name="a"/> and <paramref name="b"/></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateList">
            <summary>
            A list of Coordinates, which may
            be set to prevent repeated coordinates from occurring in the list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor">
            <summary>
            Constructs a new list without any coordinates
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor(System.Int32)">
            <summary>
            Constructs a new list without any coordinates but an initial capacity
            </summary>
            <param name="capacity">The initial capacity of the list.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Constructs a new list from an array of Coordinates, allowing repeated points.
            (I.e. this constructor produces a <see cref="T:NetTopologySuite.Geometries.CoordinateList"/> with exactly the same set of points
            as the input array.)
            </summary>
            <param name="coord">Initial coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor(System.Collections.Generic.IList{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Constructs a new list from a collection of Coordinates,
            allows repeated points.
            </summary>
            <param name="coordList">Collection of coordinates to load into the list.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor(System.Collections.Generic.IList{NetTopologySuite.Geometries.Coordinate},System.Boolean)">
            <summary>
            Constructs a new list from a collection of Coordinates,
            allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coordList">Collection of coordinates to load into the list.</param>
            <param name="allowRepeated">If <c>false</c>, repeated points are removed.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Boolean)">
            <summary>
            Constructs a new list from an array of Coordinates,
            allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coord">Array of coordinates to load into the list.</param>
            <param name="allowRepeated">If <c>false</c>, repeated points are removed.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.GetCoordinate(System.Int32)">
            <summary>
            Returns the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>Coordinate specified.</return>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(NetTopologySuite.Geometries.Coordinate[],System.Boolean,System.Int32,System.Int32)">
            <summary>
            Adds a section of an array of coordinates to the list.
            </summary>
            <param name="coord">The coordinates</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed</param>
            <param name="start">The index to start from</param>
            <param name="end">The index to add up to but not including</param>
            <returns>true (as by general collection contract)</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(NetTopologySuite.Geometries.Coordinate[],System.Boolean,System.Boolean)">
            <summary>
            Adds an array of coordinates to the list.
            </summary>
            <param name="coord">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <param name="direction">If false, the array is added in reverse order.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(NetTopologySuite.Geometries.Coordinate[],System.Boolean)">
            <summary>
            Adds an array of coordinates to the list.
            </summary>
            <param name="coord">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(System.Object,System.Boolean)">
            <summary>
            Adds a coordinate to the list.
            </summary>
            <param name="obj">Coordinate to be inserted, as object.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Adds a coordinate to the end of this list.
            </summary>
            <param name="coord">Coordinate to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true if all ok.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Add(System.Int32,NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Inserts the specified coordinate at the specified position in this list.
            </summary>
            <param name="i">The position at which to insert</param>
            <param name="coord">the coordinate to insert</param>
            <param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.AddAll(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate},System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coll">Coordinates collection to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true if at least one element has added (IList not empty).</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.CloseRing">
            <summary>
            Ensure this coordList is a ring, by adding the start point if necessary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.ToCoordinateArray">
            <summary>
            Returns the Coordinates in this collection.
            </summary>
            <returns>Coordinates as <c>Coordinate[]</c> array.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.ToCoordinateArray(System.Boolean)">
            <summary>
            Creates an array containing the coordinates in this list,
            oriented in the given direction (forward or reverse).
            </summary>
            <param name="isForward">The direction value: <c>true</c> for forward, <c>false</c> for reverse</param>
            <returns>An oriented array of coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList.Clone">
            <summary>
            Returns a deep copy of this collection.
            </summary>
            <returns>The copied object.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateM">
            <summary>
            A lightweight class used to store coordinates on the 2-dimensional Cartesian plane
            and an additional measure (<see cref="P:NetTopologySuite.Geometries.CoordinateM.M"/>) value.
            <para>
            This data object is suitable for use with coordinate sequences with
            <c>dimension</c> = 3 and <c>measures</c> = 1.
            </para>
            </summary>
            <remarks>
            It is distinct from <see cref="T:NetTopologySuite.Geometries.Point"/>, which is a subclass of <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Unlike objects of type <see cref="T:NetTopologySuite.Geometries.Point"/> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>CoordinateM</c> only contains ordinate values
            and properties.
            <para/>
            <c>CoordinateM</c>s are two-dimensional points, with an additional M-ordinate.    
            If an M-ordinate value is not specified or not defined,
            constructed coordinates have a M-ordinate of <c>NaN</c>
            (which is also the value of <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>).
            Apart from the basic accessor functions, NTS supports
            only specific operations involving the M-ordinate.
            <para/>
            Implementations may optionally support Z-ordinate and M-measure values
            as appropriate for a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>. Use of <see cref="P:NetTopologySuite.Geometries.CoordinateZ.Z"/>
            and <see cref="P:NetTopologySuite.Geometries.CoordinateM.M"/> setters or <see cref="P:NetTopologySuite.Geometries.CoordinateM.this[int]" /> indexer are recommended.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateM.M">
            <summary>
            Gets or sets the M-ordinate value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateM</c> at (x,y,z).
            </summary>
            <param name="x">The X value</param>
            <param name="y">The Y value</param>
            <param name="m">The measure value</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.#ctor">
            <summary>
             Constructs a <c>CoordinateM</c> at (0,0,NaN).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a <c>CoordinateM</c> having the same (x,y) values as
            <paramref name="c"/>.
            </summary>
            <param name="c"><c>Coordinate</c> to copy.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateM</c> at (x,y,NaN).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateM.Item(System.Int32)">
            <summary>
            Gets or sets the ordinate value for the given index.
            </summary>
            <remarks>
            The base implementation supports 0 (X), 1 (Y) and 2 (M) as values for the index.
            </remarks>
            <param name="ordinateIndex">The ordinate index</param>
            <returns>The ordinate value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="ordinateIndex"/> is not in the valid range.</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateM.CoordinateValue">
            <summary>
            Gets/Sets <c>CoordinateM</c>s (x,y,z) values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.Create(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a Coordinate of the same type as this Coordinate,
            using the provided values for <paramref name="x"/>, <paramref name="y"/> and <paramref name="m"/>.
            </summary>
            <remarks>A provided value for <paramref name="z"/> will be silently dropped.</remarks>
            <param name="x">The x-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="y">The y-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="z">The z-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <param name="m">The m-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <returns>A new <see cref="T:NetTopologySuite.Geometries.CoordinateM"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateM.ToString">
            <summary>
            Returns a <c>string</c> of the form <i>(x, y, m=m)</i>.
            </summary>
            <returns><c>string</c> of the form <i>(x, y, m=m)</i></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Coordinates">
            <summary>
            Useful utility functions for handling Coordinate objects.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinates.Create(System.Int32)">
            <summary>
            Factory method providing access to common Coordinate implementations.
            </summary>
            <param name="dimension"></param>
            <returns>created coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinates.Create(System.Int32,System.Int32)">
            <summary>
            Factory method providing access to common Coordinate implementations.
            </summary>
            <param name="dimension"></param>
            <param name="measures"></param>
            <returns>created coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinates.Dimension(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determine dimension based on subclass of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="coordinate">supplied coordinate</param>
            <returns>number of ordinates recorded</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Coordinates.Measures(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determine number of measures based on subclass of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="coordinate">supplied coordinate</param>
            <returns>number of measures recorded </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateSequence">
            <seealso cref="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> class.
            </summary>
            <param name="count">The value for <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Count"/>.</param>
            <param name="dimension">The value for <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/>.</param>
            <param name="measures">The value for <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when any argument is negative.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="dimension"/> and <paramref name="measures"/> specify fewer
            than two (2) spatial dimensions.
            </exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension">
            <summary>
            Returns the dimension (number of ordinates in each coordinate) for this sequence.
            <para>
            This total includes any measures, indicated by non-zero <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>.
            </para>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Measures">
            <summary>
            Gets the number of measures included in <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/> for each coordinate for this
            sequence.
            </summary>
            <remarks>
            For a measured coordinate sequence a non-zero value is returned.
            <list type="bullet">
            <item><description>For <see cref="F:NetTopologySuite.Geometries.Ordinates.XY"/> sequence measures is zero</description></item>
            <item><description>For <see cref="F:NetTopologySuite.Geometries.Ordinates.XYM"/> sequence measure is one</description></item>
            <item><description>For <see cref="F:NetTopologySuite.Geometries.Ordinates.XYZ"/> sequence measure is zero</description></item>
            <item><description>For <see cref="F:NetTopologySuite.Geometries.Ordinates.XYZM"/> sequence measure is one</description></item>
            <item><description>Values greater than one are supported</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Spatial">
            <summary>
            Gets the number of non-measure dimensions included in <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/> for each
            coordinate for this sequence.
            <para>
            Equivalent to <c>Dimension - Measures</c>.
            </para>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Ordinates">
            <summary>
            Gets the kind of ordinates this sequence supplies.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.HasZ">
            <summary>
            Gets a value indicating if <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetZ(System.Int32)"/> is supported.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.HasM">
            <summary>
            Gets a value indicating if <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetM(System.Int32)"/> is supported.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.ZOrdinateIndex">
            <summary>
            Gets the index of the Z ordinate (for use with <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetOrdinate(System.Int32,System.Int32)"/> or
            <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>), or -1 if <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.HasZ"/> is
            <see langword="false"/>.
            </summary>
            <remarks>
            It's just a cache for <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.TryGetOrdinateIndex(NetTopologySuite.Geometries.Ordinate,System.Int32@)"/> with <see cref="F:NetTopologySuite.Geometries.Ordinate.Z"/>.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.MOrdinateIndex">
            <summary>
            Gets the index of the M ordinate (for use with <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetOrdinate(System.Int32,System.Int32)"/> or
            <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>), or -1 if <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.HasM"/> is
            <see langword="false"/>.
            </summary>
            <remarks>
            It's just a cache for <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.TryGetOrdinateIndex(NetTopologySuite.Geometries.Ordinate,System.Int32@)"/> with <see cref="F:NetTopologySuite.Geometries.Ordinate.M"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.CreateCoordinate">
            <summary>
            Creates a coordinate for use in this sequence.
            </summary>
            <remarks>
            The coordinate is created supporting the same number of <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/> and <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>
            as this sequence and is suitable for use with <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)"/>.
            </remarks>
            <returns>A coordinate for use with this sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinate(System.Int32)">
            <summary>
            Returns (possibly a copy of) the ith Coordinate in this collection.
            Whether or not the Coordinate returned is the actual underlying
            Coordinate or merely a copy depends on the implementation.
            Note that in the future the semantics of this method may change
            to guarantee that the Coordinate returned is always a copy. Callers are
            advised not to assume that they can modify a CoordinateSequence by
            modifying the Coordinate returned by this method.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinateCopy(System.Int32)">
            <summary>
            Returns a copy of the i'th coordinate in this sequence.
            This method optimizes the situation where the caller is
            going to make a copy anyway - if the implementation
            has already created a new Coordinate object, no further copy is needed.
            </summary>
            <param name="i">The index of the coordinate to retrieve.</param>
            <returns>A copy of the i'th coordinate in the sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Copies the i'th coordinate in the sequence to the supplied Coordinate.
            At least the first two dimensions <b>must</b> be copied.
            </summary>
            <param name="index">The index of the coordinate to copy.</param>
            <param name="coord">A Coordinate to receive the value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetX(System.Int32)">
            <summary>
            Returns ordinate X (0) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>The value of the X ordinate in the index'th coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetY(System.Int32)">
            <summary>
            Returns ordinate Y (1) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>The value of the Y ordinate in the index'th coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetZ(System.Int32)">
            <summary>
            Returns ordinate Z of the specified coordinate if available.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the Z ordinate in the index'th coordinate, or
            <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/> if not defined.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetM(System.Int32)">
            <summary>
            Returns ordinate M of the specified coordinate if available.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the M ordinate in the index'th coordinate, or
            <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/> if not defined.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetX(System.Int32,System.Double)">
            <summary>
            Sets ordinate X (0) of the specified coordinate to the specified value.
            </summary>
            <param name="index">
            The index of the coordinate whose X value to set.
            </param>
            <param name="value">
            The value to set the coordinate's X value to.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetY(System.Int32,System.Double)">
            <summary>
            Sets ordinate Y (1) of the specified coordinate to the specified value.
            </summary>
            <param name="index">
            The index of the coordinate whose Y value to set.
            </param>
            <param name="value">
            The value to set the coordinate's Y value to.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetZ(System.Int32,System.Double)">
            <summary>
            Sets ordinate Z of the specified coordinate to the specified value if present.
            </summary>
            <param name="index">
            The index of the coordinate whose Z value to set if present.
            </param>
            <param name="value">
            The value to set the coordinate's Z value to if present.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetM(System.Int32,System.Double)">
            <summary>
            Sets ordinate M of the specified coordinate to the specified value if present.
            </summary>
            <param name="index">
            The index of the coordinate whose M value to set if present.
            </param>
            <param name="value">
            The value to set the coordinate's M value to if present.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetOrdinate(System.Int32,System.Int32)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            <para/>
            Ordinate indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure
            values as described by <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/> and <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>.
            </summary>
            <remarks>
            If the sequence does not provide value for the required ordinate, the implementation <b>must not</b> throw an exception, it should return <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.
            </remarks>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns>The ordinate value, or <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/> if the sequence does not provide values for <paramref name="ordinateIndex"/>"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.GetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate value to get.</param>
            <returns>The ordinate value, or <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/> if the sequence does not provide values for <paramref name="ordinate"/>"/></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.First">
            <summary>
            Gets a value indicating the first <c>Coordinate</c> in this sequence.<br/>
            For <c>LineString</c>s e.g. this is the starting point.
            </summary>
            <returns>First <c>Coordinate</c> in sequence or <c>null</c> if empty.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Last">
            <summary>
            Gets a value indicating the last <c>Coordinate</c> in this sequence.<br/>
            For <c>LineString</c>s e.g. this is the ending point.
            </summary>
            <returns>Last <c>Coordinate</c> in sequence or <c>null</c> if empty.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequence.Count">
            <summary>
            Gets a value indicating the number of coordinates in this sequence.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <remarks>
            If the sequence can't store the ordinate value, the implementation <b>must not</b> throw an exception, it should simply ignore the call.
            </remarks>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate value to set.</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.ToCoordinateArray">
            <summary>
            Returns (possibly copies of) the Coordinates in this collection.
            Whether or not the Coordinates returned are the actual underlying
            Coordinates or merely copies depends on the implementation. Note that
            if this implementation does not store its data as an array of Coordinates,
            this method will incur a performance penalty because the array needs to
            be built from scratch.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.Copy">
            <summary>
            Returns a deep copy of this collection.
            </summary>
            <returns>A copy of the coordinate sequence containing copies of all points</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.Reversed">
            <summary>
            Returns a reversed copy of this <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <returns>
            A reversed copy of this <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.Copy"/> returned <see langword="null"/>.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequence.TryGetOrdinateIndex(NetTopologySuite.Geometries.Ordinate,System.Int32@)">
            <summary>
            Retrieves the index at which this sequence stores a particular <see cref="T:NetTopologySuite.Geometries.Ordinate"/>'s
            values, if that ordinate is present in <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Ordinates"/>.
            </summary>
            <param name="ordinate">
            The <see cref="T:NetTopologySuite.Geometries.Ordinate"/> value whose index to retrieve.
            </param>
            <param name="ordinateIndex">
            When this method returns, contains the index of the requested ordinate, if the ordinate
            is present in this sequence; otherwise, -1.  This parameter is passed uninitialized.
            </param>
            <returns>
            <see langword="true"/> if this sequence contains <paramref name="ordinate"/>; otherwise,
            <see langword="false"/>.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateSequenceComparator">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s.
            </summary><remarks>
            <para>
            For sequences of the same dimension, the ordering is lexicographic.
            Otherwise, lower dimensions are sorted before higher.
            The dimensions compared can be limited; if this is done
            ordinate dimensions above the limit will not be compared.
            </para>
            <para>
            If different behaviour is required for comparing size, dimension,
            or coordinate values, any or all methods can be overridden.</para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.Compare(System.Double,System.Double)">
            <summary>
            Compare two <c>double</c>s, allowing for NaN values.
            NaN is treated as being less than any valid number.
            </summary>
            <param name="a">A <c>double</c></param>
            <param name="b">A <c>double</c></param>
            <returns>-1, 0, or 1 depending on whether a is less than, equal to or greater than b</returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.CoordinateSequenceComparator.DimensionLimit">
            <summary>
            The number of dimensions to test
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.#ctor">
            <summary>
            Creates a comparator which will test all dimensions.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.#ctor(System.Int32)">
            <summary>
            Creates a comparator which will test only the specified number of dimensions.
            </summary>
            <param name="dimensionLimit">The number of dimensions to test</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.Compare(System.Object,System.Object)">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />s for relative order.
            </summary>
            <param name="o1">A coordinate sequence</param>
            <param name="o2">A coordinate sequence</param>
            <returns>-1, 0, or 1 depending on whether o1 is less than, equal to, or greater than o2</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.CompareCoordinate(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Compares the same coordinate of two <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s
            </summary>
            <param name="s1">A coordinate sequence</param>
            <param name="s2">A coordinate sequence</param>
            <param name="i">The index of the coordinate to test</param>
            <param name="dimension">the number of dimensions to test</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceComparator.Compare(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s for relative order.
            </summary>
            <param name="s1">A coordinate sequence</param>
            <param name="s2">A coordinate sequence</param>
            <returns>-1, 0, or 1 depending on whether s1 is less than, equal to, or greater than s2</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateSequenceFactory">
            <summary>
            An object that knows how to build a particular implementation of
            <c>CoordinateSequence</c> from an array of Coordinates.
            </summary>
            <seealso cref="T:NetTopologySuite.Geometries.CoordinateSequence" />
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/> class.`
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.#ctor(NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/> class.
            </summary>
            <param name="ordinates">
            The maximum set of <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that this instance will be
            able to create sequences for.
            </param>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateSequenceFactory.Ordinates">
            <summary>
            Gets the Ordinate flags that sequences created by this factory can maximal cope with.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> based on the given array;
            whether or not the array is copied is implementation-dependent.
            </summary>
            <param name="coordinates">A coordinates array, which may not be null nor contain null elements</param>
            <returns>A coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />  which is a copy
            of the given <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />.
            This method must handle null arguments by creating an empty sequence.
            </summary>
            <param name="coordSeq"></param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> of the specified size and dimension.
            For this to be useful, the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> implementation must be mutable.
            </summary>
            <remarks>
            If the requested dimension is larger than the CoordinateSequence implementation
            can provide, then a sequence of maximum possible dimension should be created.
            An error should not be thrown.
            </remarks>
            <param name="size"></param>
            <param name="dimension">the dimension of the coordinates in the sequence
            (if user-specifiable, otherwise ignored)</param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> of the specified size and dimension
            with measure support. For this to be useful, the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />
            implementation must be mutable.
            </summary>
            <remarks>
            If the requested dimension or measures are larger than the CoordinateSequence implementation
            can provide, then a sequence of maximum possible dimension should be created.
            An error should not be thrown.
            </remarks>
            <param name="size">The number of coordinates in the sequence</param>
            <param name="dimension">The dimension of the coordinates in the sequence (if user-specifiable,
            otherwise ignored)</param>
            <param name="measures">The number of measures of the coordinates in the sequence (if user-specifiable,
            otherwise ignored)</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(System.Int32,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> of the specified size and ordinates.
            For this to be useful, the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> implementation must be mutable.
            </summary>
            <param name="size">The number of coordinates.</param>
            <param name="ordinates">
            The ordinates each coordinate has. <see cref="F:NetTopologySuite.Geometries.Ordinates.XY"/> is fix, <see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/> and <see cref="F:NetTopologySuite.Geometries.Ordinates.M"/> can be set.
            </param>
            <returns>A coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.GetCommonSequenceParameters(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Gets the three parameters needed to create any <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> instance
            (<see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Count"/>, <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Dimension"/>, and
            <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>) such that the sequence can store all the data
            from a given array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/> instances.
            </summary>
            <param name="coordinates">
            The array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/> instances that the sequence will be created from.
            </param>
            <returns>
            The values of the three parameters to use for creating the sequence.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateSequences">
            <summary>
            Utility functions for manipulating <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Reverse(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Reverses the coordinates in a sequence in-place.
            </summary>
            <param name="seq">The coordinate sequence to reverse.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Swap(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Swaps two coordinates in a sequence.
            </summary>
            <param name="seq">seq the sequence to modify</param>
            <param name="i">the index of a coordinate to swap</param>
            <param name="j">the index of a coordinate to swap</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Copy(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Copies a section of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            The sequences may have different dimensions;
            in this case only the common dimensions are copied.
            </summary>
            <param name="src">The sequence to copy coordinates from</param>
            <param name="srcPos">The starting index of the coordinates to copy</param>
            <param name="dest">The sequence to which the coordinates should be copied to</param>
            <param name="destPos">The starting index of the coordinates in <see paramref="dest"/></param>
            <param name="length">The number of coordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.TryRawCopy(NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence,System.Int32,NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Copies a section of a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>.
            The sequences must have same dimensions.
            </summary>
            <param name="src">The sequence to copy coordinates from</param>
            <param name="srcPos">The starting index of the coordinates to copy</param>
            <param name="dest">The sequence to which the coordinates should be copied to</param>
            <param name="destPos">The starting index of the coordinates in <see paramref="dest"/></param>
            <param name="length">The number of coordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.TryRawCopy(NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence,System.Int32,NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Copies a section of a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/>.
            The sequences must have same dimensions.
            </summary>
            <param name="src">The sequence to copy coordinates from</param>
            <param name="srcPos">The starting index of the coordinates to copy</param>
            <param name="dest">The sequence to which the coordinates should be copied to</param>
            <param name="destPos">The starting index of the coordinates in <see paramref="dest"/></param>
            <param name="length">The number of coordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.TryRawCopy(NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence,System.Int32,NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Copies a section of a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>.
            The sequences must have same dimensions.
            </summary>
            <param name="src">The sequence to copy coordinates from</param>
            <param name="srcPos">The starting index of the coordinates to copy</param>
            <param name="dest">The sequence to which the coordinates should be copied to</param>
            <param name="destPos">The starting index of the coordinates in <see paramref="dest"/></param>
            <param name="length">The number of coordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.CopyCoord(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Copies a coordinate of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            The sequences may have different dimensions;
            in this case only the common dimensions are copied.
            </summary>
            <param name="src">The sequence to copy coordinate from</param>
            <param name="srcPos">The index of the coordinate to copy</param>
            <param name="dest">The sequence to which the coordinate should be copied to</param>
            <param name="destPos">The index of the coordinate in <see paramref="dest"/></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.CopyCoord(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies a coordinate of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to another <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            The sequences may have different dimensions;
            in this case only the common dimensions are copied.
            </summary>
            <param name="src">The sequence to copy coordinate from</param>
            <param name="srcPos">The index of the coordinate to copy</param>
            <param name="dest">The sequence to which the coordinate should be copied to</param>
            <param name="destPos">The index of the coordinate in <see paramref="dest"/></param>
            <param name="numSpatial">The number of spatial ordinates to copy</param>
            <param name="numMeasures">The number of measure ordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.IsRing(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> forms a valid <see cref="T:NetTopologySuite.Geometries.LinearRing"/>,
            by checking the sequence length and closure
            (whether the first and last points are identical in 2D).
            Self-intersection is not checked.
            </summary>
            <param name="seq">The sequence to test</param>
            <returns>True if the sequence is a ring</returns>
            <seealso cref="T:NetTopologySuite.Geometries.LinearRing"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.EnsureValidRing(NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Ensures that a CoordinateSequence forms a valid ring,
            returning a new closed sequence of the correct length if required.
            If the input sequence is already a valid ring, it is returned
            without modification.
            If the input sequence is too short or is not closed,
            it is extended with one or more copies of the start point.
            </summary>
            <param name="fact">The CoordinateSequenceFactory to use to create the new sequence</param>
            <param name="seq">The sequence to test</param>
            <returns>The original sequence, if it was a valid ring, or a new sequence which is valid.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Extend(NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Extends a given <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            <para/>
            Because coordinate sequences are fix in size, extending is done by
            creating a new coordinate sequence of the requested size.
            <para/>
            The new, trailing coordinate entries (if any) are filled with the last
            coordinate of the input sequence
            </summary>
            <param name="fact">The factory to use when creating the new sequence.</param>
            <param name="seq">The sequence to extend.</param>
            <param name="size">The required size of the extended sequence</param>
            <returns>The extended sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.IsEqual(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Tests whether two <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s are equal.
            To be equal, the sequences must be the same length.
            They do not need to be of the same dimension,
            but the ordinate values for the smallest dimension of the two
            must be equal.
            Two <c>NaN</c> ordinates values are considered to be equal.
            </summary>
            <param name="seq1">a CoordinateSequence</param>
            <param name="seq2">a CoordinateSequence</param>
            <returns><c>true</c> if the sequences are equal in the common dimensions</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.IsEqualAt(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Tests whether two <c>Coordinate</c>s <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s are equal.
            They do not need to be of the same dimension,
            but the ordinate values for the common ordinates of the two
            must be equal.
            Two <c>NaN</c> ordinates values are considered to be equal.
            </summary>
            <param name="seq1">A CoordinateSequence</param>
            <param name="pos1">The index of the <c>Coordinate</c> in <paramref name="seq1"/>.</param>
            <param name="seq2">a CoordinateSequence</param>
            <param name="pos2">The index of the <c>Coordinate</c> in <paramref name="seq2"/>.</param>
            <returns><c>true</c> if the sequences are equal in the common dimensions</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.IsEqualAt(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32,System.Int32)">
            <summary>
            Tests whether two <c>Coordinate</c>s <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s are equal.
            They do not need to be of the same dimension,
            but the ordinate values for the common ordinates of the two
            must be equal.
            Two <c>NaN</c> ordinates values are considered to be equal.
            </summary>
            <param name="seq1">A CoordinateSequence</param>
            <param name="pos1">The index of the <c>Coordinate</c> in <paramref name="seq1"/>.</param>
            <param name="seq2">a CoordinateSequence</param>
            <param name="pos2">The index of the <c>Coordinate</c> in <paramref name="seq2"/>.</param>
            <param name="numSpatial">The number of spatial ordinates to compare</param>
            <param name="numMeasures">The number of measure ordinates to compare</param>
            <returns><c>true</c> if the sequences are equal in the common dimensions</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.ToString(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a string representation of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            The format is:
            <para>
             ( ord0,ord1.. ord0,ord1,...  ... )
            </para>
            </summary>
            <param name="cs">the sequence to output</param>
            <returns>the string representation of the sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.MinCoordinate(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Returns the minimum coordinate, using the usual lexicographic comparison.
            </summary>
            <param name="seq">The coordinate sequence to search</param>
            <returns>The minimum coordinate in the sequence, found using <see cref="M:NetTopologySuite.Geometries.Coordinate.CompareTo(NetTopologySuite.Geometries.Coordinate)"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.MinCoordinateIndex(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Returns the index of the minimum coordinate of the whole
            coordinate sequence, using the usual lexicographic comparison.
            </summary>
            <param name="seq">The coordinate sequence to search</param>
            <returns>The index of the minimum coordinate in the sequence, found using <see cref="M:NetTopologySuite.Geometries.Coordinate.CompareTo(NetTopologySuite.Geometries.Coordinate)"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.MinCoordinateIndex(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Returns the index of the minimum coordinate of a part of
            the coordinate sequence (defined by <paramref name="from"/>
            and <paramref name="to"/>), using the usual lexicographic
            comparison.
            </summary>
            <param name="seq">The coordinate sequence to search</param>
            <param name="from">The lower search index</param>
            <param name="to">The upper search index</param>
            <returns>The index of the minimum coordinate in the sequence, found using <see cref="M:NetTopologySuite.Geometries.Coordinate.CompareTo(NetTopologySuite.Geometries.Coordinate)"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Scroll(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Shifts the positions of the coordinates until <c>firstCoordinate</c> is first.
            </summary>
            <param name="seq">The coordinate sequence to rearrange</param>
            <param name="firstCoordinate">The coordinate to make first"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Scroll(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Shifts the positions of the coordinates until the coordinate at  <c>firstCoordinateIndex</c>
            is first.
            </summary>
            <param name="seq">The coordinate sequence to rearrange</param>
            <param name="indexOfFirstCoordinate">The index of the coordinate to make first</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.Scroll(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Boolean)">
            <summary>
            Shifts the positions of the coordinates until the coordinate at  <c>firstCoordinateIndex</c>
            is first.
            </summary>
            <param name="seq">The coordinate sequence to rearrange</param>
            <param name="indexOfFirstCoordinate">The index of the coordinate to make first</param>
            <param name="ensureRing">Makes sure that <paramref name="seq"/> will be a closed ring upon exit</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateSequences.IndexOf(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Returns the index of <c>coordinate</c> in a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>
            The first position is 0; the second, 1; etc.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to search for</param>
            <param name="seq">The coordinate sequence to search</param>
            <returns>
            The position of <c>coordinate</c>, or -1 if it is not found
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateZ">
            <summary>
            A lightweight class used to store coordinates on the 2-dimensional Cartesian plane
            and an additional z-ordinate (<see cref="P:NetTopologySuite.Geometries.CoordinateZ.Z"/>) value.
            <para>
            This base data object is suitable for use with coordinate sequences with
            <c>dimension</c> = 3 and <c>measures</c> = 0.
            </para>
            </summary><remarks>
            It is distinct from <see cref="T:NetTopologySuite.Geometries.Point"/>, which is a subclass of <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Unlike objects of type <see cref="T:NetTopologySuite.Geometries.Point"/> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>CoordinateZ</c> only contains ordinate values
            and properties.
            <para/>
            <c>CoordinateZ</c>s are two-dimensional points, with an additional Z-ordinate.    
            If an Z-ordinate value is not specified or not defined,
            constructed coordinates have a Z-ordinate of <c>NaN</c>
            (which is also the value of <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>).
            <para/>
            Apart from the basic accessor functions, NTS supports
            only specific operations involving the Z-ordinate.
            <para/>
            Implementations may optionally support Z-ordinate and M-measure values
            as appropriate for a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>. Use of <see cref="P:NetTopologySuite.Geometries.CoordinateZ.Z"/>
            and <see cref="P:NetTopologySuite.Geometries.Coordinate.M"/> setters or <see cref="P:NetTopologySuite.Geometries.CoordinateZ.this[int]" /> indexer are recommended.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZ.Z">
            <summary>
            Gets or sets the Z-ordinate value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateZ</c> at (x,y,z).
            </summary>
            <param name="x">The X value</param>
            <param name="y">The Y value</param>
            <param name="z">The Z value</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.#ctor">
            <summary>
             Constructs a <c>CoordinateZ</c> at (0,0,NaN).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a <c>CoordinateZ</c> having the same (x,y) values as
            <paramref name="c"/>.
            </summary>
            <param name="c"><c>Coordinate</c> to copy.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateZ</c> at (x,y,NaN).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZ.Item(System.Int32)">
            <summary>
            Gets or sets the ordinate value for the given index.
            </summary>
            <remarks>
            The base implementation supports 0 (X), 1 (Y) and 2 (Z) as values for the index.
            </remarks>
            <param name="ordinateIndex">The ordinate index</param>
            <returns>The ordinate value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="ordinateIndex"/> is not in the valid range.</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZ.CoordinateValue">
            <summary>
            Gets/Sets <c>CoordinateZ</c>s (x,y,z) values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.Create(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a Coordinate of the same type as this Coordinate,
            using the provided values for <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>.
            </summary>
            <remarks>A provided value for <paramref name="m"/> will be silently dropped.</remarks>
            <param name="x">The x-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="y">The y-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="z">The z-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <param name="m">The m-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <returns>A new <see cref="T:NetTopologySuite.Geometries.CoordinateZ"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.Equals3D(NetTopologySuite.Geometries.CoordinateZ)">
            <summary>
            Returns <c>true</c> if <paramref name="other"/> 
            has the same values for X, Y and Z.
            </summary>
            <param name="other">A <see cref="T:NetTopologySuite.Geometries.CoordinateZ"/> with which to do the 3D comparison.</param>
            <returns>
            <c>true</c> if <paramref name="other"/> is a <see cref="T:NetTopologySuite.Geometries.CoordinateZ"/> 
            with the same values for X, Y and Z.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.EqualInZ(NetTopologySuite.Geometries.CoordinateZ,System.Double)">
            <summary>
            Tests if another CoordinateZ has the same value for Z, within a tolerance.
            </summary>
            <param name="c">A <see cref="T:NetTopologySuite.Geometries.CoordinateZ"/>.</param>
            <param name="tolerance">The tolerance value.</param>
            <returns><c>true</c> if the Z ordinates are within the given tolerance.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.ToString">
            <summary>
            Returns a <c>string</c> of the form <i>(x, y, z)</i> .
            </summary>
            <returns><c>string</c> of the form <i>(x, y, z)</i></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZ.Distance3D(NetTopologySuite.Geometries.CoordinateZ)">
            <summary>
            Computes the 3-dimensional Euclidean distance to another location.
            </summary>
            <param name="c">A <see cref="T:NetTopologySuite.Geometries.CoordinateZ"/> with which to do the distance comparison.</param>
            <returns>the 3-dimensional Euclidean distance between the locations.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.CoordinateZM">
            <summary>
            A lightweight class used to store coordinates on the 2-dimensional Cartesian plane
            and additional z- and m-ordinate values (<see cref="P:NetTopologySuite.Geometries.CoordinateZ.Z"/>, <see cref="P:NetTopologySuite.Geometries.CoordinateZM.M"/>).
            <para>
            This data object is suitable for use with coordinate sequences with
            <c>dimension</c> = 4 and <c>measures</c> = 1.
            </para>
            </summary>
            <remarks>
            It is distinct from <see cref="T:NetTopologySuite.Geometries.Point"/>, which is a subclass of <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Unlike objects of type <see cref="T:NetTopologySuite.Geometries.Point"/> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>CoordinateZM</c> only contains ordinate values
            and properties.
            <para/>
            <c>CoordinateZM</c>s are two-dimensional points, with an additional Z-ordinate.    
            If an Z-ordinate value is not specified or not defined,
            constructed coordinates have a Z-ordinate of <c>NaN</c>
            (which is also the value of <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>).
            <para/>
            Apart from the basic accessor functions, NTS supports
            only specific operations involving the Z- and/or M-ordinate.
            <para/>
            Implementations may optionally support Z-ordinate and M-measure values
            as appropriate for a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>. Use of <see cref="P:NetTopologySuite.Geometries.CoordinateZ.Z"/>
            and <see cref="P:NetTopologySuite.Geometries.CoordinateZM.M"/> setters or <see cref="P:NetTopologySuite.Geometries.CoordinateZM.this[int]" /> indexer are recommended.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZM.M">
            <summary>
            Gets or sets the measure-ordinate value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateZM</c> at (x,y,z).
            </summary>
            <param name="x">The X value</param>
            <param name="y">The Y value</param>
            <param name="z">The Z value</param>
            <param name="m">The Measure value</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.#ctor">
            <summary>
             Constructs a <c>CoordinateZM</c> at (0,0,NaN,NaN).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a <c>CoordinateZM</c> having the same (x,y) values as
            <paramref name="c"/>.
            </summary>
            <param name="c"><c>Coordinate</c> to copy.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a <c>CoordinateZM</c> at (x,y,NaN).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZM.Item(System.Int32)">
            <summary>
            Gets or sets the ordinate value for the given index.
            </summary>
            <remarks>
            The base implementation supports 0 (X), 1 (Y) and 2 (Z) as values for the index.
            </remarks>
            <param name="ordinateIndex">The ordinate index</param>
            <returns>The ordinate value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="ordinateIndex"/> is not in the valid range.</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.CoordinateZM.CoordinateValue">
            <summary>
            Gets/Sets <c>CoordinateZM</c>s (x,y,z) values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.Create(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a Coordinate of the same type as this Coordinate,
            using the provided values for <paramref name="x"/>, <paramref name="y"/>, <paramref name="z"/>  and <paramref name="m"/>.
            </summary>
            <param name="x">The x-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="y">The y-ordinate value, if not provided, it is <c>0d</c>.</param>
            <param name="z">The z-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <param name="m">The m-ordinate value, if not provided, it is <see cref="F:NetTopologySuite.Geometries.Coordinate.NullOrdinate"/>.</param>
            <returns>A new <see cref="T:NetTopologySuite.Geometries.CoordinateZM"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateZM.ToString">
            <summary>
            Returns a <c>string</c> of the form <i>(x, y, z, m=m)</i> .
            </summary>
            <returns><c>string</c> of the form <i>(x, y, z, m=m)</i></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Dimension">
            <summary>
            Provides constants representing the dimensions of a point, a curve and a surface.
            </summary>
            <remarks>
            Also provides constants representing the dimensions of the empty geometry and
            non-empty geometries, and the wildcard constant <see cref="F:NetTopologySuite.Geometries.Dimension.Dontcare"/> meaning "any dimension".
            These constants are used as the entries in <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix"/>s.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Point">
            <summary>
            Dimension value of a point (0).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.P">
            <summary>
            Dimension value of a point (0).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Curve">
            <summary>
            Dimension value of a curve (1).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.L">
            <summary>
            Dimension value of a curve (1).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Surface">
            <summary>
            Dimension value of a surface (2).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.A">
            <summary>
            Dimension value of a surface (2).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.False">
            <summary>
            Dimension value of a empty point (-1).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.True">
            <summary>
            Dimension value of non-empty geometries (= {Point,Curve,Surface}).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Dontcare">
            <summary>
            Dimension value for any dimension (= {False, True}).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Unknown">
            <summary>
            Dimension value for a unknown spatial object
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Dimension.Collapse">
            <summary>
            Dimension value for a collapsed surface or curve
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.DimensionUtility">
            <summary>
            Class containing static methods for conversions
            between dimension values and characters.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymFalse">
            <summary>
            Symbol for the FALSE pattern matrix entry
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymTrue">
            <summary>
            Symbol for the TRUE pattern matrix entry
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymDontcare">
            <summary>
            Symbol for the DONTCARE pattern matrix entry
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymP">
            <summary>
            Symbol for the P (dimension 0) pattern matrix entry
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymL">
            <summary>
            Symbol for the L (dimension 1) pattern matrix entry
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.DimensionUtility.SymA">
            <summary>
            Symbol for the A (dimension 2) pattern matrix entry
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.DimensionUtility.ToDimensionSymbol(NetTopologySuite.Geometries.Dimension)">
            <summary>
            Converts the dimension value to a dimension symbol,
            for example, <c>True => 'T'</c>
            </summary>
            <param name="dimensionValue">Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</param>
            <returns>Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, * , 0, 1, 2</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.DimensionUtility.ToDimensionValue(System.Char)">
            <summary>
            Converts the dimension symbol to a dimension value,
            for example, <c>'*' => Dontcare</c>
            </summary>
            <param name="dimensionSymbol">Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, * , 0, 1, 2</c>.</param>
            <returns>Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Envelope">
            <summary>
            Defines a rectangular region of the 2D coordinate plane.
            </summary>
            <remarks>
            It is often used to represent the bounding box of a <c>Geometry</c>,
            e.g. the minimum and maximum x and y values of the <c>Coordinate</c>s.
            Note that Envelopes support infinite or half-infinite regions, by using the values of
            <c>Double.PositiveInfinity</c> and <c>Double.NegativeInfinity</c>.
            When Envelope objects are created or initialized,
            the supplied extent values are automatically sorted into the correct order.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Test the point q to see whether it intersects the Envelope
            defined by p1-p2.
            </summary>
            <param name="p1">One extremal point of the envelope.</param>
            <param name="p2">Another extremal point of the envelope.</param>
            <param name="q">Point to test for intersection.</param>
            <returns><c>true</c> if q intersects the envelope p1-p2.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the envelope defined by p1-p2
            and the envelope defined by q1-q2
            intersect.
            </summary>
            <param name="p1">One extremal point of the envelope Point.</param>
            <param name="p2">Another extremal point of the envelope Point.</param>
            <param name="q1">One extremal point of the envelope Q.</param>
            <param name="q2">Another extremal point of the envelope Q.</param>
            <returns><c>true</c> if Q intersects Point</returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.Envelope._minX">
            <summary>
            The minimum x-coordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Envelope._maxX">
            <summary>
            The maximum x-coordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Envelope._minY">
            <summary>
            The minimum y-coordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Envelope._maxY">
            <summary>
            The maximum y-coordinate
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor">
            <summary>
            Creates a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by two Coordinates.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Creates an <c>Envelope</c> for a region defined by an enumeration of <c>Coordinate</c>s.
            </summary>
            <param name="pts">The <c>Coordinates</c>.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by a <c>CoordinateSequence</c>s.
            </summary>
            <param name="sequence">The <c>CoordinateSequence</c>.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Create an <c>Envelope</c> from an existing Envelope.
            </summary>
            <param name="env">The Envelope to initialize from.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Init">
            <summary>
            Initialize to a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Init(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Init(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by two Coordinates.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Init(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Init(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Initialize an <c>Envelope</c> from an existing Envelope.
            </summary>
            <param name="env">The Envelope to initialize from.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.SetToNull">
            <summary>
            Makes this <c>Envelope</c> a "null" envelope..
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.IsNull">
            <summary>
            Returns <c>true</c> if this <c>Envelope</c> is a "null" envelope.
            </summary>
            <returns>
            <c>true</c> if this <c>Envelope</c> is uninitialized
            or is the envelope of the empty point.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.Width">
            <summary>
            Returns the difference between the maximum and minimum x values.
            </summary>
            <returns>max x - min x, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.Height">
            <summary>
            Returns the difference between the maximum and minimum y values.
            </summary>
            <returns>max y - min y, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.Diameter">
            <summary>
            Gets the length of the diameter (diagonal) of the envelope.
            </summary>
            <returns>The diameter length</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MinX">
            <summary>
            Returns the <c>Envelope</c>s minimum x-value. min x > max x
            indicates that this is a null <c>Envelope</c>.
            </summary>
            <returns>The minimum x-coordinate.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MaxX">
            <summary>
            Returns the <c>Envelope</c>s maximum x-value. min x > max x
            indicates that this is a null <c>Envelope</c>.
            </summary>
            <returns>The maximum x-coordinate.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MinY">
            <summary>
            Returns the <c>Envelope</c>s minimum y-value. min y > max y
            indicates that this is a null <c>Envelope</c>.
            </summary>
            <returns>The minimum y-coordinate.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MaxY">
            <summary>
            Returns the <c>Envelope</c>s maximum y-value. min y > max y
            indicates that this is a null <c>Envelope</c>.
            </summary>
            <returns>The maximum y-coordinate.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.Area">
            <summary>
            Gets the area of this envelope.
            </summary>
            <returns>The area of the envelope, or 0.0 if envelope is null</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandBy(System.Double)">
            <summary>
            Expands this envelope by a given distance in all directions.
            Both positive and negative distances are supported.
            </summary>
            <param name="distance">The distance to expand the envelope.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandBy(System.Double,System.Double)">
            <summary>
            Expands this envelope by a given distance in all directions.
            Both positive and negative distances are supported.
            </summary>
            <param name="deltaX">The distance to expand the envelope along the the X axis.</param>
            <param name="deltaY">The distance to expand the envelope along the the Y axis.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MinExtent">
            <summary>
            Gets the minimum extent of this envelope across both dimensions.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.MaxExtent">
            <summary>
            Gets the maximum extent of this envelope across both dimensions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandToInclude(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Enlarges this <c>Envelope</c> so that it contains
            the given <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            Has no effect if the point is already on or within the envelope.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandToInclude(System.Double,System.Double)">
            <summary>
            Enlarges this <c>Envelope</c> so that it contains
            the given <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <remarks>Has no effect if the point is already on or within the envelope.</remarks>
            <param name="x">The value to lower the minimum x to or to raise the maximum x to.</param>
            <param name="y">The value to lower the minimum y to or to raise the maximum y to.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandToInclude(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Enlarges this <c>Envelope</c> so that it contains
            the <c>other</c> Envelope.
            Has no effect if <c>other</c> is wholly on or
            within the envelope.
            </summary>
            <param name="other">the <c>Envelope</c> to expand to include.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ExpandedBy(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Enlarges this <c>Envelope</c> so that it contains
            the <c>other</c> Envelope.
            Has no effect if <c>other</c> is wholly on or
            within the envelope.
            </summary>
            <param name="other">the <c>Envelope</c> to expand to include.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Translate(System.Double,System.Double)">
            <summary>
            Translates this envelope by given amounts in the X and Y direction.
            </summary>
            <param name="transX">The amount to translate along the X axis.</param>
            <param name="transY">The amount to translate along the Y axis.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Envelope.Centre">
            <summary>
            Computes the coordinate of the centre of this envelope (as long as it is non-null).
            </summary>
            <returns>
            The centre coordinate of this envelope,
            or <c>null</c> if the envelope is null.
            </returns>.
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersection(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Computes the intersection of two <see cref="T:NetTopologySuite.Geometries.Envelope"/>s.
            </summary>
            <param name="env">The envelope to intersect with</param>
            <returns>
            A new Envelope representing the intersection of the envelopes (this will be
            the null envelope if either argument is null, or they do not intersect
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Check if the region defined by <c>other</c>
            intersects the region of this <c>Envelope</c>.
            </summary>
            <param name="other">The <c>Envelope</c> which this <c>Envelope</c> is
            being checked for intersecting.
            </param>
            <returns>
            <c>true</c> if the <c>Envelope</c>s intersect.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Check if the point <c>p</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="p"> the <c>Coordinate</c> to be tested.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(System.Double,System.Double)">
            <summary>
            Check if the point <c>(x, y)</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="x"> the x-ordinate of the point.</param>
            <param name="y"> the y-ordinate of the point.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if the extent defined by two extremal points
            intersects the extent of this <c>Envelope</c>.
            </summary>
            <param name="a">A point</param>
            <param name="b">Another point</param>
            <returns><c>true</c> if the extents intersect</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Disjoint(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Tests if the region defined by <c>other</c>
            is disjoint from the region of this <c>Envelope</c>.
            </summary>
            <param name="other">The <c>Envelope</c> being checked for disjointness</param>
            <returns><c>true</c> if the <c>Envelope</c>s are disjoint</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Envelope)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Contains(NetTopologySuite.Geometries.Envelope)">
            <summary>
             Tests if the <c>Envelope other</c> lies wholely inside this <c>Envelope</c> (inclusive of the boundary).
            </summary>
             <remarks>
             Note that this is <b>not</b> the same definition as the SFS <i>contains</i>,
             which would exclude the envelope boundary.
             </remarks>
             <para>The <c>Envelope</c> to check</para>
             <returns>true if <c>other</c> is contained in this <c>Envelope</c></returns>
             <see cref="M:NetTopologySuite.Geometries.Envelope.Covers(NetTopologySuite.Geometries.Envelope)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Contains(NetTopologySuite.Geometries.Coordinate)">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
             <remarks>
             Note that this is <b>not</b> the same definition as the SFS <i>contains</i>,
             which would exclude the envelope boundary.
             </remarks>
             <param name="p">the point which this <c>Envelope</c> is being checked for containing</param>
             <returns><c>true</c> if the point lies in the interior or on the boundary of this <c>Envelope</c>. </returns>
             <see cref="M:NetTopologySuite.Geometries.Envelope.Covers(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Contains(System.Double,System.Double)">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
             <remarks>
             Note that this is <b>not</b> the same definition as the SFS <i>contains</i>, which would exclude the envelope boundary.
             </remarks>
             <param name="x">the x-coordinate of the point which this <c>Envelope</c> is being checked for containing</param>
             <param name="y">the y-coordinate of the point which this <c>Envelope</c> is being checked for containing</param>
             <returns>
             <c>true</c> if <c>(x, y)</c> lies in the interior or on the boundary of this <c>Envelope</c>.
             </returns>
             <see cref="M:NetTopologySuite.Geometries.Envelope.Covers(System.Double,System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Covers(System.Double,System.Double)">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
             <param name="x">the x-coordinate of the point which this <c>Envelope</c> is being checked for containing</param>
             <param name="y">the y-coordinate of the point which this <c>Envelope</c> is being checked for containing</param>
             <returns> <c>true</c> if <c>(x, y)</c> lies in the interior or on the boundary of this <c>Envelope</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Covers(NetTopologySuite.Geometries.Coordinate)">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
             <param name="p">the point which this <c>Envelope</c> is being checked for containing</param>
             <returns><c>true</c> if the point lies in the interior or on the boundary of this <c>Envelope</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Covers(NetTopologySuite.Geometries.Envelope)">
            <summary>
             Tests if the <c>Envelope other</c> lies wholely inside this <c>Envelope</c> (inclusive of the boundary).
            </summary>
             <param name="other">the <c>Envelope</c> to check</param>
             <returns>true if this <c>Envelope</c> covers the <c>other</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Distance(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Computes the distance between this and another
            <c>Envelope</c>.
            The distance between overlapping Envelopes is 0.  Otherwise, the
            distance is the Euclidean distance between the closest points.
            </summary>
            <returns>The distance between this and another <c>Envelope</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Equals(NetTopologySuite.Geometries.Envelope)">
            <inheritdoc cref="M:System.IEquatable{Envelope}.Equals(Envelope)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.CompareTo(System.Object)">
            <summary>
            Compares two envelopes using lexicographic ordering.
            The ordering comparison is based on the usual numerical
            comparison between the sequence of ordinates.
            Null envelopes are less than all non-null envelopes.
            </summary>
            <param name="o">An envelope</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.CompareTo(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Compares two envelopes using lexicographic ordering.
            The ordering comparison is based on the usual numerical
            comparison between the sequence of ordinates.
            Null envelopes are less than all non-null envelopes.
            </summary>
            <param name="env">An envelope</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.ToString">
            <summary>
            Function to get a textual representation of this envelope
            </summary>
            <returns>A textual representation of this envelope</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Copy">
            <summary>
            Creates a deep copy of the current envelope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Envelope.Parse(System.String)">
            <summary>
            Method to parse an envelope from its <see cref="M:NetTopologySuite.Geometries.Envelope.ToString"/> value
            </summary>
            <param name="envelope">The envelope string</param>
            <returns>The envelope</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Geometry">
             <summary>
             A representation of a planar, linear vector geometry.
             </summary>
             <remarks>
             <para>
             <h3>Binary Predicates:</h3>
             Because it is not clear at this time what semantics for spatial
             analysis methods involving <c>GeometryCollection</c>s would be useful,
             <c>GeometryCollection</c>s are not supported as arguments to binary
             predicates or the <c>Relate</c> method.
             </para>
             <para>
             <h3>Overlay Methods:</h3>
             The spatial analysis methods will
             return the most specific class possible to represent the result. If the
             result is homogeneous, a <c>Point</c>, <c>LineString</c>, or
             <c>Polygon</c> will be returned if the result contains a single
             element; otherwise, a <c>MultiPoint</c>, <c>MultiLineString</c>,
             or <c>MultiPolygon</c> will be returned. If the result is
             heterogeneous a <c>GeometryCollection</c> will be returned.
             </para>
             <para>
             Representation of Computed Geometries:
             The SFS states that the result
             of a set-theoretic method is the "point-set" result of the usual
             set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
             sometimes many ways of representing a point set as a <c>Geometry</c>.
             The SFS does not specify an unambiguous representation of a given point set
             returned from a spatial analysis method. One goal of NTS is to make this
             specification precise and unambiguous. NTS uses a canonical form for
             <c>Geometry</c>s returned from overlay methods. The canonical
             form is a <c>Geometry</c> which is simple and noded:
             Simple means that the Geometry returned will be simple according to
             the NTS definition of <c>IsSimple</c>.
             Noded applies only to overlays involving <c>LineString</c>s. It
             means that all intersection points on <c>LineString</c>s will be
             present as endpoints of <c>LineString</c>s in the result.
             This definition implies that non-simple geometries which are arguments to
             spatial analysis methods must be subjected to a line-dissolve process to
             ensure that the results are simple.
             </para>
             <para>
             Constructed Points And The Precision Model:
             The results computed by the set-theoretic methods may
             contain constructed points which are not present in the input <c>Geometry</c>s.
             These new points arise from intersections between line segments in the
             edges of the input <c>Geometry</c>s. In the general case it is not
             possible to represent constructed points exactly. This is due to the fact
             that the coordinates of an intersection point may contain twice as many bits
             of precision as the coordinates of the input line segments. In order to
             represent these constructed points explicitly, NTS must truncate them to fit
             the <c>PrecisionModel</c>.
             Unfortunately, truncating coordinates moves them slightly. Line segments
             which would not be coincident in the exact result may become coincident in
             the truncated representation. This in turn leads to "topology collapses" --
             situations where a computed element has a lower dimension than it would in
             the exact result.
             When NTS detects topology collapses during the computation of spatial
             analysis methods, it will throw an exception. If possible the exception will
             report the location of the collapse.
             </para>
             <para>
            
             <h3>Geometry Equality</h3>
             There are two ways of comparing geometries for equality:
             <b>structural equality</b> and <b>topological equality</b>.
             <h4>Structural Equality</h4>
             Structural Equality is provided by the
             <see cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/> method.
             This implements a comparison based on exact, structural pointwise
             equality.
             The <see cref="M:NetTopologySuite.Geometries.Geometry.Equals(System.Object)"/> is a synonym for this method,
             to provide structural equality semantics for
             use in collections.
             It is important to note that structural pointwise equality
             is easily affected by things like
             ring order and component order.  In many situations
             it will be desirable to normalize geometries before
             comparing them (using the <see cref="M:NetTopologySuite.Geometries.Geometry.Normalized"/>
             or <see cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/> methods).
             <see cref="M:NetTopologySuite.Geometries.Geometry.EqualsNormalized(NetTopologySuite.Geometries.Geometry)"/> is provided
             as a convenience method to compute equality over
             normalized geometries, but it is expensive to use.
             Finally, <see cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)"/>
             allows using a tolerance value for point comparison.
            
             <h4>Topological Equality</h4>
             Topological Equality is provided by the
             <see cref="M:NetTopologySuite.Geometries.Geometry.EqualsTopologically(NetTopologySuite.Geometries.Geometry)"/> method.
             It implements the SFS definition of point-set equality
             defined in terms of the DE-9IM matrix.
             To support the SFS naming convention, the method
             <see cref="M:NetTopologySuite.Geometries.Geometry.Equals(NetTopologySuite.Geometries.Geometry)"/> is also provided as a synonym.
             However, due to the potential for confusion with <see cref="M:NetTopologySuite.Geometries.Geometry.Equals(System.Object)"/>
             its use is discouraged.
             </para>
             <para>
             Since <see cref="M:NetTopologySuite.Geometries.Geometry.Equals(System.Object)"/> and <see cref="M:NetTopologySuite.Geometries.Geometry.GetHashCode"/> are overridden,
             Geometries can be used effectively in .Net collections.
             </para>
             </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.Geometry.SortIndexValue">
            <summary>
            An enumeration of sort values for geometries
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 the values in this enum have been renamed to 'TYPECODE...'
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.Point">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.Point"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiPoint">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiPoint"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.LineString">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.LineString"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.LinearRing">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.LinearRing"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiLineString">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiLineString"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.Polygon">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.Polygon"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiPolygon">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.MultiPolygon"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.GeometryCollection">
            <summary>Sort hierarchy value of a <see cref="F:NetTopologySuite.Geometries.Geometry.SortIndexValue.GeometryCollection"/></summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNamePoint">
            <summary>
            The name of point geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameMultiPoint">
            <summary>
            The name of multi-point geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameLineString">
            <summary>
            The name of linestring geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameLinearRing">
            <summary>
            The name of linearring geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameMultiLineString">
            <summary>
            The name of multi-linestring geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNamePolygon">
            <summary>
            The name of polygon geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameMultiPolygon">
            <summary>
            The name of multi-polygon geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.TypeNameGeometryCollection">
            <summary>
            The name of geometry collection geometries.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Factory">
            <summary>
            Gets the factory which contains the context in which this point was created.
            </summary>
            <returns>The factory for this point.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.UserData">
            <summary>
            Gets/Sets the user data object for this point, if any.
            </summary>
            <remarks>
            A simple scheme for applications to add their own custom data to a Geometry.
            An example use might be to add an object representing a Coordinate Reference System.
            Note that user data objects are not present in geometries created by
            construction methods.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry._envelope">
            <summary>
            The bounding box of this <c>Geometry</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.SRID">
            <summary>
            Sets the ID of the Spatial Reference System used by the <c>Geometry</c>.
            </summary>
            <remarks>
            <para>
            <b>NOTE:</b> This method should only be used for exceptional circumstances or
            for backwards compatibility.  Normally the <c>SRID</c> should be set on the
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> used to <b>create</b> the geometry.
            <c>SRID</c>s set using this method will change the <see cref="P:NetTopologySuite.Geometries.Geometry.Factory"/>.
            </para>
            </remarks>
            <seealso cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a new <c>Geometry</c> via the specified GeometryFactory.
            </summary>
            <param name="factory">The factory</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.GeometryType">
            <summary>
            Returns the name of this Geometry's actual class.
            </summary>
            <returns>The name of this <c>Geometry</c>s actual class.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.OgcGeometryType">
            <summary>
            Gets the OGC geometry type
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.HasNonEmptyElements(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Returns true if the array contains any non-empty <c>Geometry</c>s.
            </summary>
            <param name="geometries"> an array of <c>Geometry</c>s; no elements may be <c>null</c></param>
            <returns>
            <c>true</c> if any of the <c>Geometry</c>s
            <c>IsEmpty</c> methods return <c>false</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.HasNullElements(System.Object[])">
            <summary>
            Returns true if the array contains any <c>null</c> elements.
            </summary>
            <param name="array"> an array to validate.</param>
            <returns><c>true</c> if any of <c>array</c>s elements are <c>null</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.HasNullElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true if the array contains any <c>null</c> elements.
            </summary>
            <param name="array"> an array to validate.</param>
            <returns><c>true</c> if any of <c>array</c>s elements are <c>null</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.PrecisionModel">
            <summary>
            Returns the <c>PrecisionModel</c> used by the <c>Geometry</c>.
            </summary>
            <returns>
            the specification of the grid of allowable points, for this
            <c>Geometry</c> and all other <c>Geometry</c>s.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Coordinate">
            <summary>
            Returns a vertex of this <c>Geometry</c>
            (usually, but not necessarily, the first one).
            </summary>
            <remarks>
            The returned coordinate should not be assumed to be an actual Coordinate object used in the internal representation.
            </remarks>
            <returns>a Coordinate which is a vertex of this <c>Geometry</c>.</returns>
            <returns><c>null</c> if this Geometry is empty.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Coordinates">
            <summary>
            Returns an array containing the values of all the vertices for
            this geometry.
            </summary>
            <remarks>
            If the geometry is a composite, the array will contain all the vertices
            for the components, in the order in which the components occur in the geometry.
            <para>
            In general, the array cannot be assumed to be the actual internal
            storage for the vertices.  Thus modifying the array
            may not modify the geometry itself.
            Use the <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/> or
            <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate,System.Double)"/> method
            (possibly on the components) to modify the underlying data.
            If the coordinates are modified,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> must be called afterwards.
            </para>
            </remarks>
            <returns>The vertices of this <c>Geometry</c>.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate,System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.GetOrdinates(NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Gets an array of <see cref="T:System.Double"/> ordinate values
            </summary>
            <param name="ordinate">The ordinate index</param>
            <returns>An array of ordinate values</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.NumPoints">
            <summary>
            Returns the count of this <c>Geometry</c>s vertices. The <c>Geometry</c>
            s contained by composite <c>Geometry</c>s must be
            Geometry's; that is, they must implement <c>NumPoints</c>.
            </summary>
            <returns>The number of vertices in this <c>Geometry</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.NumGeometries">
            <summary>
            Returns the number of Geometryes in a GeometryCollection,
            or 1, if the geometry is not a collection.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.GetGeometryN(System.Int32)">
            <summary>
            Returns an element Geometry from a GeometryCollection,
            or <c>this</c>, if the geometry is not a collection.
            </summary>
            <param name="n">The index of the geometry element.</param>
            <returns>The n'th geometry contained in this geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.IsSimple">
            <summary>
            Tests whether this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is simple.
            <para/>
            The SFS definition of simplicity
            follows the general rule that a Geometry is simple if it has no points of
            self-tangency, self-intersection or other anomalous points.
            <para/>
            Simplicity is defined for each <see cref="T:NetTopologySuite.Geometries.Geometry"/> subclass as follows:
            <list type="bullet">
            <item><description>Valid polygonal geometries are simple, since their rings
            must not self-intersect. <c>IsSimple</c>
            tests for this condition and reports <c>false</c> if it is not met.
            (This is a looser test than checking for validity).</description></item>
            <item><description>Linear rings have the same semantics.</description></item>
            <item><description>Linear geometries are simple if they do not self-intersect at points
            other than boundary points.</description></item>
            <item><description>Zero-dimensional geometries (points) are simple if they have no
            repeated points.</description></item>
            <item><description>Empty <c>Geometry</c>s are always simple.</description></item>
            </list>
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> is simple</returns>
            <seealso cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.IsValid">
            <summary>
            Tests whether this <c>Geometry</c> is topologically
            valid, according to the OGC SFS specification.<para/>
            For validity rules see the documentation for the specific geometry subclass.
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> is valid.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.IsEmpty">
            <summary>
            Tests whether the set of points covered in this <c>Geometry</c> is empty.
            <para/>
            Note this test is for topological emptiness, not structural emptiness.<br/>
            A collection containing only empty elements is reported as empty.<br/>
            To check structural emptiness use <see cref="P:NetTopologySuite.Geometries.Geometry.NumGeometries"/>.
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> does not cover any points.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns the minimum distance between this <c>Geometry</c>
            and another <c>Geometry</c> g.
            </summary>
            <param name="g">The <c>Geometry</c> from which to compute the distance.</param>
            <returns>The distance between the geometries</returns>
            <returns>0 if either input geometry is empty</returns>
            <exception cref="T:System.ArgumentException">if g is null</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.IsWithinDistance(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Tests whether the distance from this <c>Geometry</c>
            to another is less than or equal to a specified value.
            </summary>
            <param name="geom">the Geometry to check the distance to.</param>
            <param name="distance">the distance value to compare.</param>
            <returns><c>true</c> if the geometries are less than <c>distance</c> apart.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Area">
            <summary>
            Returns the area of this <c>Geometry</c>.
            Areal Geometries have a non-zero area.
            They override this function to compute the area.
            Others return 0.0
            </summary>
            <returns>The area of the Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Length">
            <summary>
            Returns the length of this <c>Geometry</c>.
            Linear geometries return their length.
            Areal geometries return their perimeter.
            They override this function to compute the length.
            Others return 0.0
            </summary>
            <returns>The length of the Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Centroid">
            <summary>
            Computes the centroid of this <c>Geometry</c>.
            The centroid
            is equal to the centroid of the set of component Geometries of highest
            dimension (since the lower-dimension geometries contribute zero
            "weight" to the centroid).
            <para/>
            The centroid of an empty geometry is <c>POINT EMPTY</c>.
            </summary>
            <returns>A Point which is the centroid of this Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.InteriorPoint">
            <summary>
            Computes an interior point of this <c>Geometry</c>.
            </summary>
            <remarks>
            An interior point is guaranteed to lie in the interior of the Geometry,
            if it possible to calculate such a point exactly. Otherwise,
            the point may lie on the boundary of the point.
            <para/>
            The interior point of an empty geometry is <c>POINT EMPTY</c>.
            </remarks>
            <returns>A <c>Point</c> which is in the interior of this Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.PointOnSurface">
            <summary>
            <see cref="P:NetTopologySuite.Geometries.Geometry.InteriorPoint" />
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Dimension">
            <summary>
            Returns the dimension of this geometry.
            </summary>
            <remarks>
            The dimension of a geometry is is the topological
            dimension of its embedding in the 2-D Euclidean plane.
            In the NTS spatial model, dimension values are in the set {0,1,2}.
            <para>
            Note that this is a different concept to the dimension of
            the vertex <see cref="P:NetTopologySuite.Geometries.Geometry.Coordinate"/>s.
            The geometry dimension can never be greater than the coordinate dimension.
            For example, a 0-dimensional geometry (e.g. a Point)
            may have a coordinate dimension of 3 (X,Y,Z).
            </para>
            </remarks>
            <returns>
            The topological dimensions of this geometry
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Boundary">
            <summary>
            Returns the boundary, or an empty geometry of appropriate dimension
            if this <c>Geometry</c> is empty.
            For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.BoundaryDimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.Envelope">
            <summary>
            Gets a geometry representing the envelope (bounding box) of this <c>Geometry</c>.
            </summary>
            <remarks>If this <c>Geometry</c> is
            <list type="bullet">
            <item><description>empty, returns an empty <c>Point</c></description></item>
            <item><description>a point, returns a <c>Point</c></description></item>
            <item><description>a line parallel to an axis, a two-vertex <c>LineString</c>,</description></item>
            <item><description>otherwise, returns a
            <c>Polygon</c> whose vertices are (minx, miny), (maxx, miny),
            (maxx, maxy), (minx, maxy), (minx, miny).</description></item>
            </list>
            </remarks>
            <returns>
            A Geometry representing the envelope of this Geometry
            </returns>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.ToGeometry(NetTopologySuite.Geometries.Envelope)"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.EnvelopeInternal">
            <summary>
            Gets an <see cref="T:NetTopologySuite.Geometries.Envelope"/> containing
            the minimum and maximum x and y values in this <c>Geometry</c>.
            If the geometry is empty, an empty <c>Envelope</c>
            is returned.
            </summary>
            <remarks>
            The returned object is a copy of the one maintained internally,
            to avoid aliasing issues.
            For best performance, clients which access this
            envelope frequently should cache the return value.</remarks>
            <returns>the envelope of this <c>Geometry</c>.</returns>
            <returns>An empty Envelope if this Geometry is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.GeometryChanged">
            <summary>
            Notifies this geometry that its coordinates have been changed by an external
            party (for example, via a <see cref="T:NetTopologySuite.Geometries.ICoordinateFilter"/>).
            </summary>
            <remarks>
            When this method is called the geometry will flush
            and/or update any derived information it has cached (such as its <see cref="T:NetTopologySuite.Geometries.Envelope"/> ).
            The operation is applied to all component Geometries.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.GeometryChangedAction">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party. When GeometryChanged is called, this method will be called for
            this Geometry and its component Geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Disjoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry is disjoint from the argument geometry.
            </summary>
            <remarks>
            The <c>Disjoint</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The DE-9IM intersection matrix for the two geometries matches <c>FF*FF****</c>.</description></item>
            <item><description><c>!g.intersects(this) == true</c><br/>(<c>Disjoint</c> is the inverse of <c>Intersects</c>)</description></item>
            </list>
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are disjoint.</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Intersects(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Touches(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry touches the argument geometry
            </summary>
            <remarks>
            The <c>Touches</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The geometries have at least one point in common,
            but their interiors do not intersect</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches
            at least one of the following patterns
            <list type="bullet">
            <item><description><c>FT*******</c>,</description></item>
            <item><description><c>F**T*****</c> or</description></item>
            <item><description><c>F***T****</c>.</description></item>
            </list></description></item>
            </list>
            If both geometries have dimension 0, the predicate returns <c>false</c>,
            since points have only interiors.
            This predicate is symmetric.
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s touch;
            Returns false if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry intersects the argument geometry.
            </summary>
            <remarks>
            The <c>Intersects</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The two geometries have at least one point in common</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches<br/>
            <c>[T********]</c> or<br/>
            <c>[*T*******]</c> or<br/>
            <c>[***T*****]</c> or<br/>
            <c>[****T****]</c></description></item>
            <item><description><c>!g.disjoint(this)</c><br/>
            (<c>Intersects</c> is the inverse of <c>Disjoint</c>)</description></item>
            </list></remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s intersect.</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Disjoint(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Crosses(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry crosses the specified geometry.
            </summary>
            <remarks>
            The <c>Crosses</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item>The geometries have some but not all interior points in common.</item>
            <item>The DE-9IM Intersection Matrix for the two geometries matches
            one of the following patterns:
            <list type="table">
            <listheader><term>Code</term><description>Description</description></listheader>
            <item><term><c>[T*T******]</c></term><description>for P/L, P/A, and L/A situations</description></item>
            <item><term><c>[T*****T**]</c></term><description>for L/P, A/P, and A/L situations)</description></item>
            <item><term><c>[0********]</c></term><description>for L/L situations</description></item>
            </list>
            </item>
            </list>
            For the A/A and P/P situations this predicate returns <c>false</c>.
            <para>
            The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
            To make the relation symmetric,
            NTS extends the definition to apply to L/P, A/P and A/L situations as well.
            </para>
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if the two <c>Geometry</c>s cross.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry is within the specified geometry.
            </summary>
            <remarks>
            The <c>within</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>
            Every point of this geometry is a point of the other geometry,
            and the interiors of the two geometries have at least one point in common.
            </description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches <c>[T*F**F***]</c></description></item>
            <item><description><c>g.contains(this) == true</c><br/>(<c>Within</c> is the converse of <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/>)</description></item>
            </list>
            <para>
            An implication of the definition is that "The boundary of a geometry is not within the Polygon".
            In other words, if a geometry A is a subset of the points in the boundary of a geometry B, <c>A.within(B) == false</c>
            (As a concrete example, take A to be a LineString which lies in the boundary of a Polygon B.)
            For a predicate with similar behaviour but avoiding
            this subtle limitation, see <see cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)"/>.
            </para>
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> is within <c>other</c>.</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/>
            <see cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry contains the argument geometry.
            </summary>
            <remarks>
            The <c>Contains</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>Every point of the other geometry is a point of this geometry,
            and the interiors of the two geometries have at least one point in common.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches the pattern
            <c>[T*****FF*]</c></description></item>
            <item><description><c>g.within(this)</c><br/>
            (<c>Contains</c> is the converse of <see cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>)</description></item>
            </list>
            <para>
            An implication of the definition is that "Geometries do not
            contain their boundary".  In other words, if a geometry A is a subset of
            the points in the boundary of a geometry B, <c>B.Contains(A) == false</c>.
            (As a concrete example, take A to be a LineString which lies in the boundary of a Polygon B.)
            For a predicate with similar behaviour but avoiding
            this subtle limitation, see <see cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>.
            </para>
            </remarks>
            <param name="g">the <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> contains <c>g</c></returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Overlaps(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry overlaps the specified geometry.
            </summary>
            <remarks>
            The <c>Overlaps</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The geometries have at least one point each not shared by the other (or equivalently neither covers the other),
            they have the same dimension,
            and the intersection of the interiors of the two geometries has
            the same dimension as the geometries themselves.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches
             <c>[T*T***T**]</c> (for two points or two surfaces)
             or <c>[1*T***T**]</c> (for two curves)</description></item>
            </list>
            If the geometries are of different dimension this predicate returns <c>false</c>.
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s overlap.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry covers the argument geometry
            </summary>
            <remarks>
            The <c>covers</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>Every point of the other geometry is a point of this geometry.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches at least
            one of the following patterns:
            <list type="bullet">
            <item><description><c>[T*****FF*]</c> or<br/></description></item>
            <item><description><c>[*T****FF*]</c> or<br/></description></item>
            <item><description><c>[***T**FF*]</c> or<br/></description></item>
            <item><description><c>[****T*FF*]</c></description></item>
            </list>
            </description></item>
            <item><c>g.CoveredBy(this) == true</c><br/>
            (<c>covers</c> is the converse of <see cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)"/>)</item>
            </list>
            If either geometry is empty, the value of this predicate is <c>false</c>.
            <para>
            This predicate is similar to <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/>,
            but is more inclusive (i.e. returns <c>true</c> for more cases).
            In particular, unlike <c>Contains</c> it does not distinguish between
            points in the boundary and in the interior of geometries.
            For most situations, <c>Covers</c> should be used in preference to <c>Contains</c>.
            As an added benefit, <c>Covers</c> is more amenable to optimization,
            and hence should be more performant.
            </para>
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> covers <paramref name="g" /></returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)" />
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)" />
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)">
            <summary>Tests whether this geometry is covered by the specified geometry.</summary>
            <remarks>
            The <c>CoveredBy</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>Every point of this geometry is a point of the other geometry.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches
            at least one of the following patterns:
            <list type="bullet">
            <item><description><c>[T*F**F***]</c></description></item>
            <item><description><c>[*TF**F***]</c></description></item>
            <item><description><c>[**FT*F***]</c></description></item>
            <item><description><c>[**F*TF***]</c></description></item></list></description></item>
            <item><description><c>g.Covers(this) == true</c><br/>
            (<c>CoveredBy</c> is the converse of <see cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>)
            </description></item>
            </list>
            If either geometry is empty, the value of this predicate is <c>false</c>.
            <para>
            This predicate is similar to <see cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>,
            but is more inclusive (i.e. returns <c>true</c> for more cases).
            </para>
            </remarks>
            <param name="g">the <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> is covered by <c>g</c></returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Relate(NetTopologySuite.Geometries.Geometry,System.String)">
            <summary>
            Tests whether the elements in the DE-9IM
            <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix"/> for the two <c>Geometry</c>s match the elements in <c>intersectionPattern</c>.
            </summary>
            <remarks>
            The pattern is a 9-character string, with symbols drawn from the following set:
            <list type="table">
            <item><term>0</term><description>(dimension 0)</description></item>
            <item><term>1</term><description>(dimension 1)</description></item>
            <item><term>2</term><description>(dimension 2)</description></item>
            <item><term>T</term><description>( matches 0, 1 or 2)</description></item>
            <item><term>F</term><description>( matches FALSE)</description></item>
            <item><term>*</term><description>( matches any value)</description></item>
            </list>
            For more information on the DE-9IM, see the <i>OpenGIS Simple Features
            Specification</i>.
            </remarks>
            <param name="g">the <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="intersectionPattern">the pattern against which to check the
            intersection matrix for the two <c>Geometry</c>s</param>
            <returns><c>true</c> if the DE-9IM intersection
            matrix for the two <c>Geometry</c>s match <c>intersectionPattern</c></returns>
            <seealso cref="T:NetTopologySuite.Geometries.IntersectionMatrix"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Relate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns the DE-9IM intersection matrix for the two <c>Geometry</c>s.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A matrix describing the intersections of the interiors,
            boundaries and exteriors of the two <c>Geometry</c>s.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Equals(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry is
            topologically equal to the argument geometry.
            <para/>
            This method is included for backward compatibility reasons.
            It has been superseded by the <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsTopologically(NetTopologySuite.Geometries.Geometry)"/> method,
            which has been named to clearly denote its functionality.
            <para/>
            This method should <b>NOT</b> be confused with the method
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Equals(System.Object)"/>, which implements
            an exact equality comparison.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if the two <c>Geometry</c>s are topologically equal.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsTopologically(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.EqualsTopologically(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry is topologically equal to the argument geometry
            as defined by the SFS <c>Equals</c> predicate.
            </summary>
            <remarks>
            The SFS <c>equals</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The two geometries have at least one point in common,
            and no point of either geometry lies in the exterior of the other geometry.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches
            the pattern <tt>T*F**FFF*</tt>
            <pre>
            T*F
            **F
            FF*
            </pre></description></item>
            </list>
            <b>Note</b> that this method computes <b>topologically equality</b>.
            For structural equality, see {@link #equalsExact(Geometry)}.
            </remarks>
            <param name="g">the <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if the two <c>Geometry</c>s are topologically equal</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Equals(System.Object)">
            <summary>
            Tests whether this geometry is structurally and numerically equal
            to a given <tt>Object</tt>.
            </summary>
            <remarks>
            If the argument <tt>Object</tt> is not a <c>Geometry</c>,
            the result is <c>false</c>.
            Otherwise, the result is computed using
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/>.
            <para/>
            This method is provided to fulfill the Java contract
            for value-based object equality.
            In conjunction with <seealso cref="M:NetTopologySuite.Geometries.Geometry.GetHashCode"/>
            it provides semantics which are most useful
            for using
            <c>Geometry</c>s as keys and values in Java collections.
            <para/>
            Note that to produce the expected result the input geometries
            should be in normal form.  It is the caller's
            responsibility to perform this where required
            (using <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalized"/>
            or <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/> as appropriate).
            </remarks>
            <param name="o">The object to compare</param>
            <returns><c>true</c> if this geometry is exactly equal to the argument</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.GetHashCode"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalized"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareGeometryCollections(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.op_Equality(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.op_Inequality(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.GetHashCode">
            <summary>
            Gets a hash code for the Geometry.
            </summary>
            <returns>
            An integer value suitable for use as a hashcode
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ToString">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ToText">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.AsText">
            <summary>
            <see cref="M:NetTopologySuite.Geometries.Geometry.ToText" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ToBinary">
            <summary>
            Returns the Well-known Binary representation of this <c>Geometry</c>.
            For a definition of the Well-known Binary format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>The Well-known Binary representation of this <c>Geometry</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.AsBinary">
            <summary>
            <see cref="M:NetTopologySuite.Geometries.Geometry.ToBinary" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ToGMLFeature">
            <summary>
            Returns the feature representation as GML 2.1.1 XML document.
            This XML document is based on <c>Geometry.xsd</c> schema.
            NO features or XLink are implemented here!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double)">
            <summary>
            Computes a buffer area around this geometry having the given width. The
            buffer of a Geometry is the Minkowski sum or difference of the geometry
            with a disc of radius <c>Abs(distance)</c>.
            </summary>
            <remarks><para>Mathematically-exact buffer area boundaries can contain circular arcs.
            To represent these arcs using linear geometry they must be approximated with line segments.
            The buffer geometry is constructed using 8 segments per quadrant to approximate
            the circular arcs.</para>
            <para>The end cap style is <c>EndCapStyle.Round</c>.</para>
            <para>
            The buffer operation always returns a polygonal result. The negative or
            zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.IPolygonal"/>.
            This is also the result for the buffers of degenerate (zero-area) polygons.
            </para>
            </remarks>
            <param name="distance">
            The width of the buffer (may be positive, negative or 0), interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <returns>
            a polygonal geometry representing the buffer region (which may be empty)
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a robustness error occurs</exception>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.EndCapStyle)">
            <summary>
            Computes a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the geometry
            with a disc of radius <c>Abs(distance)</c>.
            </summary>
            <remarks>
            <para>The end cap style specifies the buffer geometry that will be
            created at the ends of linestrings.  The styles provided are:
            <ul>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round" /> - (default) a semi-circle</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat" /> - a straight line perpendicular to the end segment</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square" /> - a half-square</li>
            </ul></para>
            <para>The buffer operation always returns a polygonal result. The negative or
            zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.IPolygonal"/>.</para>
            </remarks>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            a polygonal geometry representing the buffer region (which may be empty)
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a robustness error occurs</exception>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32)">
            <summary>
            Computes a buffer region around this <c>Geometry</c> having the given
            width and with a specified accuracy of approximation for circular arcs.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <remarks><para>Mathematically-exact buffer area boundaries can contain circular arcs.
            To represent these arcs using linear geometry they must be approximated with line segments.
            The <c>quadrantSegments</c> argument allows controlling the accuracy of
            the approximation by specifying the number of line segments used to
            represent a quadrant of a circle</para>
            <para>The buffer operation always returns a polygonal result. The negative or
            zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.IPolygonal"/>.
            This is also the result for the buffers of degenerate (zero-area) polygons.
            </para>
            </remarks>
            <param name="distance">
            The width of the buffer (may be positive, negative or 0), interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <returns>
            a polygonal geometry representing the buffer region (which may be empty)
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a robustness error occurs</exception>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)">
            <summary>
            Computes a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <remarks><para>Mathematically-exact buffer area boundaries can contain circular arcs.
            To represent these arcs using linear geometry they must be approximated with line segments.
            The <c>quadrantSegments</c> argument allows controlling the accuracy of
            the approximation by specifying the number of line segments used to
            represent a quadrant of a circle</para>
            <para>The end cap style specifies the buffer geometry that will be
            created at the ends of linestrings.  The styles provided are:
            <ul>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round" /> - (default) a semi-circle</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat" /> - a straight line perpendicular to the end segment</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square" /> - a half-square</li>
            </ul></para>
            <para>The buffer operation always returns a polygonal result. The negative or
            zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.IPolygonal"/>.
            This is also the result for the buffers of degenerate (zero-area) polygons.
            </para>
            </remarks>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            a polygonal geometry representing the buffer region (which may be empty)
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a robustness error occurs</exception>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)">
            <summary>
            Computes a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <remarks><para>Mathematically-exact buffer area boundaries can contain circular arcs.
            To represent these arcs using linear geometry they must be approximated with line segments.
            The <c>bufferParameters</c> argument has a property <c>QuadrantSegments</c> controlling the accuracy of
            the approximation by specifying the number of line segments used to
            represent a quadrant of a circle</para>
            <para>The <c>EndCapStyle</c> property of the <c>bufferParameters</c> argument specifies the buffer geometry that will be
            created at the ends of linestrings.  The styles provided are:
            <ul>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round" /> - (default) a semi-circle</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat" /> - a straight line perpendicular to the end segment</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square" /> - a half-square</li>
            </ul></para>
            <para>The buffer operation always returns a polygonal result. The negative or
            zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.IPolygonal"/>.
            This is also the result for the buffers of degenerate (zero-area) polygons.
            </para>
            </remarks>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="bufferParameters">This argument type has a number of properties that control the construction of the
            buffer, including <c>QuadrantSegments</c>, <c>EndCapStyle</c>, <c>JoinStyle</c>, and <c>MitreLimit</c></param>
            <returns>
            a polygonal geometry representing the buffer region (which may be empty)
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a robustness error occurs</exception>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Buffer(System.Double,System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ConvexHull">
            <summary>
            Returns the smallest convex <c>Polygon</c> that contains all the
            points in the <c>Geometry</c>. This obviously applies only to <c>Geometry</c>
            s which contain 3 or more points.
            </summary>
            <returns>the minimum-area convex polygon containing this <c>Geometry</c>'s points.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Reverse">
            <summary>
            Computes a new geometry which has all component coordinate sequences
            in reverse order (opposite orientation) to this one.
            </summary>
            <returns>A reversed geometry</returns>
            <remarks>Don't override this function, implement <see cref="M:NetTopologySuite.Geometries.Geometry.ReverseInternal"/>.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function
            </summary>
            <returns>A reversed geometry</returns>
            <remarks>In JTS this function is abstract, but that would break binary compatibility of current version.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Intersection(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the point-set which is
            common to both this <c>Geometry</c> and the <c>other</c> Geometry.
            <para/>
            The intersection of two geometries of different dimension produces a result
            geometry of dimension less than or equal to the minimum dimension of the input
            geometries.
            The result geometry may be a heterogeneous <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>.
            If the result is empty, it is an atomic geometry
            with the dimension of the lowest input dimension.
            <para/>
            Intersection of <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s is supported
            only for homogeneous collection types.
            <para/>
            Non-empty heterogeneous <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> arguments are not supported.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the intersection.</param>
            <returns>A geometry representing the point-set common to the two <c>Geometry</c>s.</returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">if a robustness error occurs.</exception>
            <exception cref="T:System.ArgumentException">if the argument is a non-empty heterogeneous <c>GeometryCollection</c></exception>
            <exception cref="T:System.ArgumentException">if the argument has a factory with a different <c>GeometryOverlay</c> object assigned</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Union(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing  the point-set
            which is contained in both this
            <c>Geometry</c> and the <c>other</c> Geometry.
            </summary>
            <remarks>
            The method may be used on arguments of different dimension, but it does not
            support <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> arguments.
            <para/>
            The union of two geometries of different dimension produces a result
            geometry of dimension equal to the maximum dimension of the input
            geometries.
            The result geometry may be a heterogeneous
            <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>.
            If the result is empty, it is an atomic geometry
            with the dimension of the highest input dimension.
            <para/>
            Unioning <see cref="T:NetTopologySuite.Geometries.LineString"/>s has the effect of
            <b>noding</b> and <b>dissolving</b> the input linework. In this context
            "noding" means that there will be a node or endpoint in the result for
            every endpoint or line segment crossing in the input. "Dissolving" means
            that any duplicate (i.e. coincident) line segments or portions of line
            segments will be reduced to a single line segment in the result.
            If <b>merged</b> linework is required, the <see cref="T:NetTopologySuite.Operation.Linemerge.LineMerger"/>
            class can be used.
            <para/>
            Non-empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> arguments are not supported.</remarks>
            <param name="other">the <c>Geometry</c> with which to compute the union</param>
            <returns>A point-set combining the points of this <c>Geometry</c> and the
            points of <c>other</c></returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown if a robustness error occurs</exception>
            <exception cref="T:System.ArgumentException">Thrown if either input is a non-empty GeometryCollection</exception>
            <exception cref="T:System.ArgumentException">if the argument has a factory with a different <c>GeometryOverlay</c> object assigned</exception>
            <seealso cref="T:NetTopologySuite.Operation.Linemerge.LineMerger"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Difference(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the closure of the point-set
            of the points contained in this <c>Geometry</c> that are not contained in
            the <c>other</c> Geometry.
            <para/>
            If the result is empty, it is an atomic geometry
            with the dimension of the left-hand input.
            <para/>
            Non-empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> arguments are not supported.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the difference.</param>
            <returns>A Geometry representing the point-set difference of this <c>Geometry</c> with <c>other</c>.</returns>
            <exception cref="T:System.ArgumentException">if the argument has a factory with a different <c>GeometryOverlay</c> object assigned</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.SymmetricDifference(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry </c> representing the closure of the point-set
            which is the union of the points in this <c>Geometry</c> which are not
            contained in the <c>other</c> Geometry,
            with the points in the <c>other</c> Geometry not contained in this
            <c>Geometry</c>.
            If the result is empty, it is an atomic geometry
            with the dimension of the highest input dimension.
            <para/>
            Non-empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> arguments are not supported.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the symmetric difference.</param>
            <returns>a Geometry representing the point-set symmetric difference of this <c>Geometry</c> with <c>other</c>.</returns>
            <exception cref="T:System.ArgumentException">if the argument has a factory with a different <c>GeometryOverlay</c> object assigned</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Union">
            <summary>
            Computes the union of all the elements of this geometry.
            </summary>
            <remarks>
            This method supports <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s (which the other overlay operations currently do not).</remarks>
            <remarks>
            The result obeys the following contract:
            <list type="bullet">
            <item><description>Unioning a set of <see cref="T:NetTopologySuite.Geometries.LineString"/>s has the effect of fully noding and dissolving the linework.</description></item>
            <item><description>Unioning a set of <see cref="T:NetTopologySuite.Geometries.Polygon"/>s always returns a <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometry
            (unlike <see cref="M:NetTopologySuite.Geometries.Geometry.Union(NetTopologySuite.Geometries.Geometry)"/>), which may return geometries of lower dimension if a topology
            collapse occurred).</description></item>
            </list>
            </remarks>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown if a robustness error occurs</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal,
            up to a specified tolerance.
            Two Geometries are exactly within a tolerance equal if:
            <list type="bullet">
            <item><description>they have the same class,</description></item>
            <item><description>they have the same values of Coordinates,
            within the given tolerance distance, in their internal
            Coordinate lists, in exactly the same order.</description></item>
            </list>
            This method does <i>not</i>
            test the values of the <c>GeometryFactory</c>, the <c>SRID</c>,
            or the <c>UserData</c> fields.
            <para/>
            To properly test equality between different geometries,
            it is usually necessary to <see cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/> them first.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c>
            have identical structure and point values, up to the distance tolerance.</param>
            <param name="tolerance">Distance at or below which two Coordinates will be considered equal.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalized"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal.
            Two Geometries are exactly equal if:
            <list type="bullet">
            <item><description>they have the same class,</description></item>
            <item><description>they have the same values of Coordinates in their internal
            Coordinate lists, in exactly the same order.</description></item>
            </list>
            This provides a stricter test of equality than
            <see cref="M:NetTopologySuite.Geometries.Geometry.EqualsTopologically(NetTopologySuite.Geometries.Geometry)"/>, which is more useful
            in certain situations
            (such as using geometries as keys in collections).
            <para/>
            This method does <i>not</i>
            test the values of the <c>GeometryFactory</c>, the <c>SRID</c>,
            or the <c>UserData</c> fields.
            <para/>
            To properly test equality between different geometries,
            it is usually necessary to <see cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/> them first.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c> have identical structure and point values.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.EqualsNormalized(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether two geometries are exactly equal
            in their normalized forms.
            <remarks>
            This is a convenience method which creates normalized
            versions of both geometries before computing
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/>.<para/>
            This method is relatively expensive to compute.
            For maximum performance, the client
            should instead perform normalization  on the individual geometries
            at an appropriate point during processing.
            </remarks>
            </summary>
            <param name="g">A geometry</param>
            <returns>true if the input geometries are exactly equal in their normalized form</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.EqualsExact(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c>'s coordinates.
            </summary>
            <remarks>
            If this method modifies any coordinate values,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> must be called to update the geometry state.
            Note that you cannot use this method to
            modify this Geometry if its underlying CoordinateSequence's #get method
            returns a copy of the Coordinate, rather than the actual Coordinate stored
            (if it even stores Coordinate objects at all).
            </remarks>
            <param name="filter">The filter to apply to this <c>Geometry</c>'s coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)">
            <summary>
            Performs an operation on the coordinates in this <c>Geometry</c>'s <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s.
            </summary>
            <remarks>
            If the filter reports that a coordinate value has been changed,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> will be called automatically.
            </remarks>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter)">
            <summary>
            Performs an operation on this <c>Geometry</c>'s <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s.
            </summary>
            <remarks>
            If the filter reports that a coordinate value has been changed,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> will be called automatically.
            </remarks>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Copy">
            <summary>
            Creates a deep copy of this <see cref="T:NetTopologySuite.Geometries.Geometry"/> object.
            Coordinate sequences contained in it are copied.
            All instance fields are copied
            (i.e. the <c>SRID</c>, <c>EnvelopeInternal</c> and <c>UserData</c>).
            </summary>
            <remarks>
            <b>NOTE:</b> The UserData object reference (if present) is copied,
            but the value itself is not copied.
            If a deep copy is required this must be performed by the caller. 
            </remarks>
            <returns>A deep copy of this geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CopyInternal">
            <summary>
            An internal method to copy subclass-specific geometry data.
            </summary>
            <returns>A copy of the target geometry object.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Normalize">
            <summary>
            Converts this <c>Geometry</c> to normal form (or canonical form ).
            </summary>
            <remarks>
            <para>
            Normal form is a unique representation for <c>Geometry</c>s.
            It can be used to test whether two <c>Geometry</c>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality.</para>
            <para>
            The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.
            </para>
            <para>
            <b>NOTE</b> that this method mutates the value of this geometry in-place.
            If this is not safe and/or wanted, the geometry should be
            cloned prior to normalization.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Normalized">
            <summary>
            Creates a new Geometry which is a normalized copy of this Geometry.
            </summary>
            <returns>A normalized copy of this geometry.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Normalize"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareTo(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c>.</summary>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
            <list type="bullet">
            <item><description>Point (lowest),</description></item>
            <item><description>MultiPoint,</description></item>
            <item><description>LineString,</description></item>
            <item><description>LinearRing,</description></item>
            <item><description>MultiLineString,</description></item>
            <item><description>Polygon,</description></item>
            <item><description>MultiPolygon,</description></item>
            <item><description>GeometryCollection (highest).</description></item>
            </list>
            If the two <c>Geometry</c>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
            <param name="o">A <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareTo(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c>.</summary>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
            <list type="bullet">
            <item><description>Point (lowest),</description></item>
            <item><description>MultiPoint,</description></item>
            <item><description>LineString,</description></item>
            <item><description>LinearRing,</description></item>
            <item><description>MultiLineString,</description></item>
            <item><description>Polygon,</description></item>
            <item><description>MultiPolygon,</description></item>
            <item><description>GeometryCollection (highest).</description></item>
            /// </list>
            If the two <c>Geometry</c>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
            <param name="geom">A <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareTo(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c>, using the given <see paramref="IComparer{CoordinateSequence}"/>.</summary>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
            <list type="bullet">
            <item><description>Point (lowest),</description></item>
            <item><description>MultiPoint,</description></item>
            <item><description>LineString,</description></item>
            <item><description>LinearRing,</description></item>
            <item><description>MultiLineString,</description></item>
            <item><description>Polygon,</description></item>
            <item><description>MultiPolygon,</description></item>
            <item><description>GeometryCollection (highest).</description></item>
            </list>
            If the two <c>Geometry</c>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
            <param name="o">A <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="comp">A <c>IComparer&lt;CoordinateSequence&gt;</c></param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.IsEquivalentClass(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns whether the two <c>Geometry</c>s are equal, from the point
            of view of the <c>EqualsExact</c> method. Called by <c>EqualsExact</c>
            . In general, two <c>Geometry</c> classes are considered to be
            "equivalent" only if they are the same class. An exception is <c>LineString</c>
            , which is considered to be equivalent to its subclasses.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c> for equality.</param>
            <returns>
            <c>true</c> if the classes of the two <c>Geometry</c>
            s are considered to be equal by the <c>equalsExact</c> method.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CheckNotGeometryCollection(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Throws an exception if <c>g</c>'s type is a <c>GeometryCollection</c>.
            (Its subclasses do not trigger an exception).
            </summary>
            <param name="g">The <c>Geometry</c> to check.</param>
            <exception cref="T:System.ArgumentException">
            if <c>g</c> is a <c>GeometryCollection</c>, but not one of its subclasses.
            </exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.IsGeometryCollection">
            <summary>
            Tests whether this is an instance of a general {@link GeometryCollection},
            rather than a homogeneous subclass.
            </summary>
            <returns><c>true</c> if this is a heterogeneous GeometryCollection</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.ComputeEnvelopeInternal">
            <summary>
            Returns the minimum and maximum x and y values in this <c>Geometry</c>,
            or a null <c>Envelope</c> if this <c>Geometry</c> is empty.
            Unlike <c>EnvelopeInternal</c>, this method calculates the <c>Envelope</c>
            each time it is called; <c>EnvelopeInternal</c> caches the result
            of this method.
            </summary>
            <returns>
            This <c>Geometry</c>s bounding box; if the <c>Geometry</c>
            is empty, <c>Envelope.IsNull</c> will return <c>true</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> having the same class.
            </summary>
            <param name="o">A <c>Geometry</c> having the same class as this <c>Geometry</c>.</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> of the same class.
            using the given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="o">A <c>Geometry</c> having the same class as this <c>Geometry</c></param>
            <param name="comp">The comparer</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the JTS Technical
            Specifications
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Compare(System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry},System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Returns the first non-zero result of <c>CompareTo</c> encountered as
            the two <c>Collection</c>s are iterated over. If, by the time one of
            the iterations is complete, no non-zero result has been encountered,
            returns 0 if the other iteration is also complete. If <c>b</c>
            completes before <c>a</c>, a positive number is returned; if a
            before b, a negative number.
            </summary>
            <param name="a">A <c>Collection</c> of <c>IComparable</c>s.</param>
            <param name="b">A <c>Collection</c> of <c>IComparable</c>s.</param>
            <returns>The first non-zero <c>compareTo</c> result, if any; otherwise, zero.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.Equal(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry.CreatePointFromInternalCoord(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="exemplar"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry.IsRectangle">
            <summary>
            Tests whether this is a rectangular <see cref="T:NetTopologySuite.Geometries.Polygon"/>.
            </summary>
            <returns><c>true</c> if the geometry is a rectangle.</returns>
            <remarks>Polygon overrides to check for actual rectangle.</remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Geometry.DefaultFactory">
            <summary>
            A predefined <see cref="T:NetTopologySuite.Geometries.GeometryFactory" /> with <see cref="P:NetTopologySuite.Geometries.Geometry.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Fixed" />.
            </summary>
            <seealso cref="F:NetTopologySuite.Geometries.GeometryFactory.Default" />
            <seealso cref="F:NetTopologySuite.Geometries.GeometryFactory.Fixed"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryCollection">
            <summary>
            Basic implementation of <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollection.Empty">
            <summary>
            Represents an empty <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollection._geometries">
            <summary>
            Internal representation of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.#ctor(NetTopologySuite.Geometries.Geometry[])">
             <summary>
            
             </summary>
             <param name="geometries">
             The <c>Geometry</c>s for this <c>GeometryCollection</c>,
             or <c>null</c> or an empty array to create the empty
             point. Elements may be empty <c>Geometry</c>s,
             but not <c>null</c>s.
             </param>
             <remarks>
             For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
             with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
             </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.#ctor(NetTopologySuite.Geometries.Geometry[],NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometries">
             The <c>Geometry</c>s for this <c>GeometryCollection</c>,
             or <c>null</c> or an empty array to create the empty
             point. Elements may be empty <c>Geometry</c>s,
             but not <c>null</c>s.
             </param>
             <param name="factory"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Coordinates">
            <summary>
            Collects all coordinates of all subgeometries into an Array.
            Note that while changes to the coordinate objects themselves
            may modify the Geometries in place, the returned Array as such
            is only a temporary container which is not synchronized back.
            </summary>
            <returns>The collected coordinates.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.GetOrdinates(NetTopologySuite.Geometries.Ordinate)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.GetOrdinates(NetTopologySuite.Geometries.Ordinate)"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.IsEmpty">
            <inheritdoc cref="P:NetTopologySuite.Geometries.Geometry.IsEmpty"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Dimension">
            <inheritdoc cref="P:NetTopologySuite.Geometries.Geometry.Dimension"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.NumGeometries">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.GetGeometryN(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Geometries">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"GeometryCollection"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.OgcGeometryType">
            <summary>
            Gets the OGC geometry type
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Area">
            <summary>
            Returns the area of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Length">
            <summary>
            Returns the length of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.ICoordinateFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.ICoordinateFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.IGeometryFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.IGeometryFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.GeometryCollection.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Normalize">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.CompareToSameClass(System.Object)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.IsHomogeneous">
            <summary>
            Return <c>true</c> if all features in collection are of the same type.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Item(System.Int32)">
            <summary>
            Returns the iTh element in the collection.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.Reverse">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> with
            every component reversed.
            The order of the components in the collection are not reversed.
            </summary>
            <returns>A <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/></returns> in the reverse order
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function for <c>GeometryCollection</c>s.
            </summary>
            <returns>A reversed geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection.Count">
            <summary>
            Returns the number of geometries contained by this <see cref="T:NetTopologySuite.Geometries.GeometryCollection" />.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryCollectionEnumerator">
            <summary>
            Iterates over all <c>Geometry</c>'s in a <c>GeometryCollection</c>.
            Implements a pre-order depth-first traversal of the <c>GeometryCollection</c>
            (which may be nested). The original <c>GeometryCollection</c> is
            returned as well (as the first object), as are all sub-collections. It is
            simple to ignore the <c>GeometryCollection</c> objects if they are not
            needed.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollectionEnumerator._parent">
            <summary>
            The <c>GeometryCollection</c> being iterated over.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollectionEnumerator._atStart">
            <summary>
            Indicates whether or not the first element (the <c>GeometryCollection</c>)
            has been returned.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollectionEnumerator._max">
            <summary>
            The number of <c>Geometry</c>s in the the <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollectionEnumerator._index">
            <summary>
            The index of the <c>Geometry</c> that will be returned when <c>next</c>
            is called.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollectionEnumerator._subcollectionEnumerator">
            <summary>
            The iterator over a nested <c>GeometryCollection</c>, or <c>null</c>
            if this <c>GeometryCollectionIterator</c> is not currently iterating
            over a nested <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs an iterator over the given <c>GeometryCollection</c>.
            </summary>
            <param name="parent">
            The collection over which to iterate; also, the first
            element returned by the iterator.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollectionEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>>
            <remarks> The parent GeometryCollection is the first object returned!</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollectionEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc cref="M:System.Collections.IEnumerable.GetEnumerator"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.FilterMethod">
            <summary>
            Delegate function declaration to handle filter operation
            </summary>
            <param name="geom">The geometry to filter</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryComponentFilter">
            <summary>
            An <see cref="T:NetTopologySuite.Geometries.IGeometryComponentFilter"/> implementation that applies filtering with the provided <see cref="T:NetTopologySuite.Geometries.FilterMethod"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryComponentFilter.#ctor(NetTopologySuite.Geometries.FilterMethod)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="filterMethod">The filter method to be used</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryFactory">
            <summary>
            Supplies a set of utility methods for building Geometry objects
            from lists of Coordinates.
            </summary>
            <remarks>
            Note that the factory constructor methods do <b>not</b> change the input coordinates in any way.
            In particular, they are not rounded to the supplied <c>PrecisionModel</c>.
            It is assumed that input Coordinates meet the given precision.
            <para/>
            Instances of this class are thread-safe.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryFactory.Default">
            <summary>
            A predefined <see cref="T:NetTopologySuite.Geometries.GeometryFactory" /> with <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel" />c
            <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating" />.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryFactory.Floating">
            <summary>
            A predefined <see cref="T:NetTopologySuite.Geometries.GeometryFactory" /> with <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel" />
            <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating" />.
            </summary>
            <remarks>A shortcut for <see cref="F:NetTopologySuite.Geometries.GeometryFactory.Default" />.</remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryFactory.FloatingSingle">
            <summary>
            A predefined <see cref="T:NetTopologySuite.Geometries.GeometryFactory" /> with <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel" />
            <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.FloatingSingle" />.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryFactory.Fixed">
            <summary>
            A predefined <see cref="T:NetTopologySuite.Geometries.GeometryFactory" /> with <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel" />
            <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Fixed" />.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel">
            <summary>
            Returns the PrecisionModel that Geometries created by this factory
            will be associated with.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.CoordinateSequenceFactory">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.SRID">
            <summary>
            The SRID value defined for this factory.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.GeometryOverlay">
            <summary>
            Gets a value indicating the geometry overlay function set to use
            </summary>
            <returns>A geometry overlay function set.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.CoordinateEqualityComparer">
            <summary>
            Gets a value indicating the geometry overlay function set to use
            </summary>
            <returns>A geometry overlay function set.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory.GeometryServices">
            <summary>
            Gets a value indicating the <see cref="T:NetTopologySuite.NtsGeometryServices"/> object that created this factory.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePointFromInternalCoord(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="exemplar"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.NtsGeometryServices)">
            <summary>
            Constructs a <c>GeometryFactory</c> that generates Geometries having the given
            <paramref name="precisionModel">precision model</paramref>, <paramref name="srid">spatial-reference ID</paramref>, 
            <paramref name="coordinateSequenceFactory">CoordinateSequence</paramref> and
            <paramref name="services"><c>NtsGeometryServices</c></paramref>.
            </summary>
            <param name="precisionModel">A precision model</param>
            <param name="srid">A spatial reference id</param>
            <param name="coordinateSequenceFactory">A coordinate sequence factory</param>
            <param name="services"><c>NtsGeometryServices</c> object creating this factory</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            CoordinateSequence implementation, a double-precision floating PrecisionModel and a
            spatial-reference ID of 0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            {PrecisionModel} and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            <c>PrecisionModel</c> and spatial-reference ID, and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
            <param name="srid">The SRID to use.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.#ctor">
            <summary>
            Constructs a GeometryFactory that generates Geometries having a floating
            PrecisionModel and a spatial-reference ID of 0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToPointArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="points">The <c>IEnumerable</c> of Points to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToGeometryArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="geometries">The <c>IEnumerable</c> of <c>Geometry</c>'s to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToLineStringArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="lineStrings">The <c>IEnumerable</c> of LineStrings to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToLinearRingArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="linearRings">The <c>IEnumerable</c> of LinearRings to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToPolygonArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="polygons">The <c>IEnumerable</c> of Polygons to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToMultiPointArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="multiPoints">The <c>IEnumerable</c> of MultiPoints to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToMultiLineStringArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="multiLineStrings">The <c>IEnumerable</c> of MultiLineStrings to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToMultiPolygonArray(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Converts the <c>IEnumerable</c> to an array.
            </summary>
            <param name="multiPolygons">The <c>IEnumerable</c> of MultiPolygons to convert.</param>
            <returns>The <c>IEnumerable</c> in array format.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToGeometry(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.Geometry"/> with the same extent as the given envelope.
            </summary>
            <remarks>
            <para>
            The Geometry returned is guaranteed to be valid.
            To provide this behavior, the following cases occur:
            </para>
            <para>
            If the <c>Envelope</c> is:
            <ul>
            <li>null returns an empty <see cref="T:NetTopologySuite.Geometries.Point"/></li>
            <li>a point returns a non-empty <see cref="T:NetTopologySuite.Geometries.Point"/></li>
            <li>a line returns a two-point <see cref="T:NetTopologySuite.Geometries.LineString"/></li>
            <li>a rectangle returns a <see cref="T:NetTopologySuite.Geometries.Polygon"/> whose points are (minx, maxy), (minx, maxy), (maxx, maxy), (maxx, miny).</li>
            </ul>
            </para>
            </remarks>
            <param name="envelope">The <c>Envelope</c></param>
            <returns>
            An empty <c>Point</c> (for null <c>Envelope</c>s), a <c>Point</c> (when min x = max x and min y = max y) or a <c>Polygon</c> (in all other cases)
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePoint">
            <summary>
            Creates an empty Point
            </summary>
            <returns>
            An empty Point
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a Point using the given Coordinate.
            A <c>null</c> coordinate creates an empty Geometry.
            </summary>
            <param name="coordinate">a Coordinate, or null</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Point"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePoint(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a <c>Point</c> using the given <c>CoordinateSequence</c>; a null or empty
            CoordinateSequence will create an empty Point.
            </summary>
            <param name="coordinates">a CoordinateSequence (possibly empty), or null</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Point"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLineString">
            <summary>
            Creates an empty LineString
            </summary>
            <returns>An empty LineString</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLineString(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a LineString using the given Coordinates.
            A null or empty array creates an empty LineString.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LineString"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLineString(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a LineString using the given CoordinateSequence.
            A null or empty CoordinateSequence creates an empty LineString.
            </summary>
            <param name="coordinates">A CoordinateSequence (possibly empty), or null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LineString"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLinearRing">
            <summary>Creates an empty LinearRing</summary>
            <returns>An empty LinearRing</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLinearRing(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a <c>LinearRing</c> using the given <c>Coordinates</c>; a null or empty array
            creates an empty LinearRing. The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LinearRing"/> object</returns>
            <exception cref="T:System.ArgumentException"> If the ring is not closed, or has too few points</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateLinearRing(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a <c>LinearRing</c> using the given <c>CoordinateSequence</c>; a null or empty CoordinateSequence
            creates an empty LinearRing. The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">A CoordinateSequence (possibly empty), or null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LinearRing"/> object</returns>
            <exception cref="T:System.ArgumentException"> If the ring is not closed, or has too few points</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon">
            <summary>Creates an empty Polygon</summary>
            <returns>An empty Polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[])">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>, or
            <c>null</c> or empty <c>LinearRing</c> s if
            the empty point is to be created.
            </param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Polygon"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="coordinates">the outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty geometry is to be created.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Polygon"/> object</returns>
            <exception cref="T:System.ArgumentException">If the boundary ring is invalid</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="coordinates">the outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty geometry is to be created.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Polygon"/> object</returns>
            <exception cref="T:System.ArgumentException">If the boundary ring is invalid</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">the outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty geometry is to be created.</param>
            <returns>the created Polygon</returns>
            <exception cref="T:System.ArgumentException">If the boundary ring is invalid</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPoint">
            <summary>Creates an empty MultiPoint</summary>
            <returns>An empty MultiPoint</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPoint(NetTopologySuite.Geometries.Point[])">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> using the given Points.
            A null or empty array will  create an empty MultiPoint.
            </summary>
            <param name="point">An array (without null elements), or an empty array, or <c>null</c>.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPointFromCoords(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> using the given Coordinates.
            A null or empty array will create an empty MultiPoint.
            </summary>
            <param name="coordinates">An array (without null elements), or an empty array, or <c>null</c></param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPoint(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> using the given CoordinateSequence.
            A null or empty CoordinateSequence will create an empty MultiPoint.
            </summary>
            <param name="coordinates">A CoordinateSequence (possibly empty), or <c>null</c>.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiLineString">
            <summary>Creates an empty MultiLineString</summary>
            <returns>An empty MultiLineString</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiLineString(NetTopologySuite.Geometries.LineString[])">
            <summary>
            Creates a <c>MultiLineString</c> using the given <c>LineStrings</c>; a null or empty
            array will create an empty MultiLineString.
            </summary>
            <param name="lineStrings">LineStrings, each of which may be empty but not null-</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPolygon">
            <summary>Creates an empty MultiPolygon</summary>
            <returns>An empty MultiPolygon</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPolygon(NetTopologySuite.Geometries.Polygon[])">
            <summary>
            Creates a <c>MultiPolygon</c> using the given <c>Polygons</c>; a null or empty array
            will create an empty Polygon. The polygons must conform to the
            assertions specified in the <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.
            </summary>
            <param name="polygons">Polygons, each of which may be empty but not null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateGeometryCollection">
            <summary>Creates an empty GeometryCollection</summary>
            <returns>An empty GeometryCollection</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateGeometryCollection(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Creates a <c>GeometryCollection</c> using the given <c>Geometries</c>; a null or empty
            array will create an empty GeometryCollection.
            </summary>
            <param name="geometries">an array of Geometries, each of which may be empty but not null, or null</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.BuildGeometry(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Build an appropriate <c>Geometry</c>, <c>MultiGeometry</c>, or
            <c>GeometryCollection</c> to contain the <c>Geometry</c>s in
            it.
            </summary>
            <remarks>
             If <c>geomList</c> contains a single <c>Polygon</c>,
            the <c>Polygon</c> is returned.<br/>
             If <c>geomList</c> contains several <c>Polygon</c>s, a
            <c>MultiPolygon</c> is returned.<br/>
             If <c>geomList</c> contains some <c>Polygon</c>s and
            some <c>LineString</c>s, a <c>GeometryCollection</c> is
            returned.<br/>
             If <c>geomList</c> is empty, an empty <c>GeometryCollection</c>
            is returned.
            Note that this method does not "flatten" Geometries in the input, and hence if
            any MultiGeometries are contained in the input a GeometryCollection containing
            them will be returned.
            </remarks>
            <param name="geomList">The <c>Geometry</c> to combine.</param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Geometry"/> of the "smallest", "most type-specific"
            class that can contain the elements of <c>geomList</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateEmpty(NetTopologySuite.Geometries.Dimension)">
            <summary>
            Creates an empty atomic geometry of the given dimension.
            If passed a dimension of <see cref="F:NetTopologySuite.Geometries.Dimension.Dontcare"/>
            will create an empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>.
            </summary>
            <param name="dimension">The required dimension (<see cref="F:NetTopologySuite.Geometries.Dimension.Dontcare"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Point"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Curve"/> or <see cref="F:NetTopologySuite.Geometries.Dimension.Surface"/>)</param>
            <returns>An empty atomic geometry of given dimension</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.CreateGeometry(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a deep copy of the input <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/> defined for this factory
            is used to copy the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s
            of the input geometry.
            <para/>
            This is a convenient way to change the <tt>CoordinateSequence</tt>
            used to represent a geometry, or to change the
            factory used for a geometry.
            <para/>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Copy"/> can also be used to make a deep copy,
            but it does not allow changing the CoordinateSequence type.
            </summary>
            <param name="g">The geometry</param>
            <returns>A deep copy of the input geometry, using the CoordinateSequence type of this factory</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Copy"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.WithSRID(System.Int32)">
            <summary>
            Returns a new <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> whose <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/> is
            the given value and whose other values and behavior are, as near as we possibly can make
            it, the same as our own.
            </summary>
            <param name="srid">
            The <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/> for the result.
            </param>
            <returns>
            The cloned instance.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryFactoryEx">
            <summary>
            An extended <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> that is capable of enforcing a ring orientation for polygons.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.DefaultShellRingOrientation">
            <summary>
            Gets or sets the default polygon shell ring orientation that is used when nothing else has been set.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.DefaultPrecisionModel">
            <summary>
            Gets or sets the default precision model to use with these geometry factories
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.DefaultCoordinateSequenceFactory">
            <summary>
            Gets or sets the default coordinate sequence factory to use with these geometry factories
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.DefaultSRID">
            <summary>
            Gets or sets the default spatial reference id.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.NtsGeometryServices)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            CoordinateSequence implementation, a double-precision floating PrecisionModel and a
            spatial-reference ID of 0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            {PrecisionModel} and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            <c>PrecisionModel</c> and spatial-reference ID, and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
            <param name="srid">The SRID to use.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.#ctor">
            <summary>
            Constructs a GeometryFactory that generates Geometries having a floating
            PrecisionModel and a spatial-reference ID of 0.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryFactoryEx._polygonShellRingOrientation">
            <summary>
            The polygon shell ring orientation enforced by this factory
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.OrientationOfExteriorRing">
            <summary>
            Gets or sets a value indicating the ring orientation of the
            <c>Polygon</c>'s exterior rings.<para>
            If its value is <see cref="F:NetTopologySuite.Geometries.LinearRingOrientation.DontCare"/>, this
            factory behaves just like the base <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </para>
            </summary>
            <remarks>
            The setter of this property has to be used prior to any call
            to <c>CreatePolygon</c>, <c>CreateMultiPolygon</c>, or
            <c>ReplaceSRID</c></remarks>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.Coordinate[])"/>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.CoordinateSequence)"/>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing)"/>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[])"/>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.CreateMultiPolygon(NetTopologySuite.Geometries.Polygon[])"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactoryEx.OrientationOfInteriorRings">
            <summary>
            Gets a value indicating the ring orientation for the interior rings
            </summary>
            <remarks>
            This value is always opposite of <see cref="P:NetTopologySuite.Geometries.GeometryFactoryEx.OrientationOfExteriorRing"/>,
            except when its value is <see cref="F:NetTopologySuite.Geometries.LinearRingOrientation.DontCare"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.CreatePolygon(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[])">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            <para/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryFactoryEx.OrientationOfExteriorRing"/> is enforced on the constructed polygon.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>, or
            <c>null</c> or empty <c>LinearRing</c> s if
            the empty point is to be created.
            </param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Polygon"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.CreateMultiPolygon(NetTopologySuite.Geometries.Polygon[])">
            <summary>
            Creates a <c>MultiPolygon</c> using the given <c>Polygons</c>; a null or empty array
            will create an empty Polygon. The polygons must conform to the
            assertions specified in the <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.<para/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryFactoryEx.OrientationOfExteriorRing"/> is enforced on each polygon.
            </summary>
            <param name="polygons">Polygons, each of which may be empty but not null.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.WithSRID(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactoryEx.EnsureOrientation(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRingOrientation)">
            <summary>
            Utility function to enforce a specific ring orientation on a linear ring
            </summary>
            <param name="ring">The ring</param>
            <param name="ringOrientation">The required orientation</param>
            <returns>A ring</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryOverlay">
            <summary>
            A class that encapsulates geometry overlay functionality
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryOverlay.Legacy">
            <summary>
            Gets a value indicating a geometry overlay operation class that uses old NTS overlay operation set.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryOverlay.NG">
            <summary>
            Gets a value indicating a geometry overlay operation class that uses next-generation NTS overlay operation set.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Computes a <c>Geometry</c> representing the overlay of geometries <c>a</c> and <c>b</c>
            using the spatial function defined by <c>opCode</c>.
            </summary>
            <param name="a">The 1st geometry</param>
            <param name="b">The 2nd geometry</param>
            <param name="opCode">The spatial function for the overlay operation</param>
            <returns>The computed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.Intersection(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the point-set which is
            common to both <c>a</c> and <c>b</c> Geometry.
            </summary>
            <param name="a">The 1st <c>Geometry</c></param>
            <param name="b">The 2nd <c>Geometry</c></param>
            <returns>A geometry representing the point-set common to the two <c>Geometry</c>s.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Intersection(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the point-set
            which is contained in both input <c>Geometry</c>s .
            </summary>
            <param name="a">The 1st <c>Geometry</c></param>
            <param name="b">The 2nd <c>Geometry</c></param>
            <returns>A point-set combining the points of
            <c>Geometry</c>'s <c>a</c> and <c>b</c>.
            </returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Union(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.Difference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the closure of the point-set
            of the points contained in this <c>Geometry</c> that are not contained in
            the <c>other</c> Geometry.
            </summary>
            <param name="a">The 1st <c>Geometry</c></param>
            <param name="b">The 2nd <c>Geometry</c></param>
            <returns>
            A Geometry representing the point-set difference
            of <c>Geometry</c>'s <c>a</c> and <c>b</c>.
            </returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Difference(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.SymmetricDifference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a <c>Geometry</c> representing the closure of the point-set
            which is the union of the points in <c>Geometry</c> <c>a</c> which are not
            contained in the Geometry  <c>b</c>,
            with the points in the <c>b</c> Geometry not contained in the <c>Geometry</c> <c>a</c>.
            </summary>
            <param name="a">The 1st <c>Geometry</c></param>
            <param name="b">The 2nd <c>Geometry</c></param>
            <returns>
            A Geometry representing the point-set symmetric difference
            of <c>Geometry</c>'s <c>a</c> and <c>b</c>.
            </returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.SymmetricDifference(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryOverlay.Union(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the union of all the elements in the <c>Geometry</c> <c>a</c>.
            </summary>
            <param name="a">The <c>Geometry</c></param>
            <returns>The union of <c>a</c></returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Union"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.IBoundable`2">
            <summary>
            A spatial object in an AbstractSTRtree.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.IBoundable`2.Bounds">
            <summary> 
            Returns a representation of space that encloses this Boundable, preferably
            not much bigger than this Boundable's boundary yet fast to test for intersection
            with the bounds of other Boundables. The class of object returned depends
            on the subclass of AbstractSTRtree.
            </summary>
            <returns> 
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other object
            (for other subclasses of AbstractSTRtree).
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.IBoundable`2.Item">
            <summary>
            Gets the item that is bounded
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.ICoordinateFilter">
            <summary>
            An interface for classes which use the values of the coordinates in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>. 
            Coordinate filters can be used to implement centroid and
            envelope computation, and many other functions.<para/>
            <para/>
            <c>ICoordinateFilter</c> is
            an example of the Gang-of-Four Visitor pattern. 
            <para/>
            <b>Note</b>: it is not recommended to use these filters to mutate the coordinates.
            There is no guarantee that the coordinate is the actual object stored in the source geometry.
            In particular, modified values may not be preserved if the source Geometry uses a non-default <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            If in-place mutation is required, use <see cref="T:NetTopologySuite.Geometries.ICoordinateSequenceFilter"/>.
            </summary>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateFilter)"/>
            <seealso cref="T:NetTopologySuite.Geometries.ICoordinateSequenceFilter"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.ICoordinateFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Performs an operation with the provided <c>coord</c>.
            Note that there is no guarantee that the input coordinate 
            is the actual object stored in the source geometry,
            so changes to the coordinate object may not be persistent.
            </summary>
            <param name="coord">A <c>Coordinate</c> to which the filter is applied.</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.ICoordinateSequenceFilter">
            <summary>
             An interface for classes which process the coordinates in a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>. 
             A filter can either record information about each coordinate,
             or change the value of the coordinate. 
             Filters can be
             used to implement operations such as coordinate transformations, centroid and
             envelope computation, and many other functions.
             <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes support the concept of applying a
             <c>CoordinateSequenceFilter</c> to each 
             <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s they contain. 
             <para/>
             For maximum efficiency, the execution of filters can be short-circuited by using the <see cref="P:NetTopologySuite.Geometries.ICoordinateSequenceFilter.Done"/> property.
            </summary>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)"/>
            <remarks>
             <c>CoordinateSequenceFilter</c> is an example of the Gang-of-Four Visitor pattern.
             <para><b>Note</b>: In general, it is preferable to treat Geometrys as immutable. 
             Mutation should be performed by creating a new Geometry object (see <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor"/> 
             and <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer"/> for convenient ways to do this).
             An exception to this rule is when a new Geometry has been created via <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.Copy"/>.
             In this case mutating the Geometry will not cause aliasing issues, 
             and a filter is a convenient way to implement coordinate transformation.
             </para>
            </remarks>
             <author>Martin Davis</author>
             <seealso cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateFilter)"/>
             <seealso cref="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer"/> 
             <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor"/> 
        </member>
        <member name="M:NetTopologySuite.Geometries.ICoordinateSequenceFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
             Performs an operation on a coordinate in a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
             <param name="seq">the <c>CoordinateSequence</c> to which the filter is applied</param>
             <param name="i">i the index of the coordinate to apply the filter to</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.ICoordinateSequenceFilter.Done">
            <summary>
             Reports whether the application of this filter can be terminated.
            </summary>
            <remarks>
             Once this method returns <c>true</c>, it must
             continue to return <c>true</c> on every subsequent call.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.ICoordinateSequenceFilter.GeometryChanged">
            <summary>
             Reports whether the execution of this filter has modified the coordinates of the geometry.
             If so, <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> will be executed
             after this filter has finished being executed.
             </summary>
             <remarks>Most filters can simply return a constant value reflecting whether they are able to change the coordinates.</remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter">
            <summary>
            A variant of <see cref="T:NetTopologySuite.Geometries.ICoordinateSequenceFilter"/>, except it receives each
            <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> just once, instead of once for each of its coordinates.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.Done">
            <summary>
            Reports whether the application of this filter can be terminated.
            </summary>
            <remarks>
            Once this method returns <see langword="true"/> it must continue to return
            <see langword="true"/> on every subsequent call.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.GeometryChanged">
            <summary>
            Reports whether the execution of this filter has modified the coordinates of the geometry.
            If so, <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> will be executed
            after this filter has finished being executed.
            </summary>
            <remarks>
            Most filters can simply return a constant value reflecting whether they are able to
            change the coordinates.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
             Performs an operation on a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
             <param name="seq">
             The <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
             </param>
        </member>
        <member name="T:NetTopologySuite.Geometries.IExpandable`1">
            <summary>
            Interface describing objects that can expand themselves by objects of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of objects that can expand clients</typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.IExpandable`1.ExpandToInclude(`0)">
            <summary>
            Method to expand this object by <paramref name="other"/>
            </summary>
            <param name="other">The object to expand with</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IExpandable`1.ExpandedBy(`0)">
            <summary>
            Function to expand compute a new object that is this object by expanded by <paramref name="other"/>.
            </summary>
            <param name="other">The object to expand with</param>
            <returns>The expanded object</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.IGeometryComponentFilter">
            <summary>
            <c>Geometry</c> classes support the concept of applying
            an <c>IGeometryComponentFilter</c> filter to the <c>Geometry</c>.
            </summary>
            <remarks>
            The filter is applied to every component of the <c>Geometry</c>
            which is itself a <c>Geometry</c>
            and which does not itself contain any components.
            (For instance, all the LinearRings in Polygons are visited,
            but in a MultiPolygon the Polygons themselves are not visited.)
            Thus the only classes of Geometry which must be 
            handled as arguments to <see cref="M:NetTopologySuite.Geometries.IGeometryComponentFilter.Filter(NetTopologySuite.Geometries.Geometry)"/>
            are <see cref="T:NetTopologySuite.Geometries.LineString"/>s, <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s and <see cref="T:NetTopologySuite.Geometries.Point"/>s.
            An <c>IGeometryComponentFilter</c> filter can either
            record information about the <c>Geometry</c>
            or change the <c>Geometry</c> in some way.
            <c>IGeometryComponentFilter</c> is an example of the Gang-of-Four Visitor pattern.
            </remarks>>    
        </member>
        <member name="M:NetTopologySuite.Geometries.IGeometryComponentFilter.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Performs an operation with or on <c>geom</c>.
            </summary>
            <param name="geom">A <c>Geometry</c> to which the filter is applied.</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.IGeometryFilter">
            <summary>
            <c>GeometryCollection</c> classes support the concept of
            applying a <c>IGeometryFilter</c> to the <c>Geometry</c>.
            The filter is applied to every element <c>Geometry</c>.
            A <c>IGeometryFilter</c> can either record information about the <c>Geometry</c>
            or change the <c>Geometry</c> in some way.
            <c>IGeometryFilter</c> is an example of the Gang-of-Four Visitor pattern.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.IGeometryFilter.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Performs an operation with or on <c>geom</c>.
            </summary>
            <param name="geom">A <c>Geometry</c> to which the filter is applied.</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.IIntersectable`1">
            <summary>
            Interface describing objects that can perform an intersects predicate with <typeparamref name="T"/> objects.
            </summary>
            <typeparam name="T">The type of the component that can intersect</typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.IIntersectable`1.Intersects(`0)">
            <summary>
            Predicate function to test if <paramref name="other"/> intersects with this object.
            </summary>
            <param name="other">The object to test</param>
            <returns><c>true</c> if this objects intersects with <paramref name="other"/></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.ILineal">
            <summary>
            Interface to identify all <c>Geometry</c> subclasses that have a <c>Dimension</c> of <see cref="F:NetTopologySuite.Geometries.Dimension.Curve"/> 
            and have components which are <see cref="T:NetTopologySuite.Geometries.LineString"/>s.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Geometries.IPuntal"/>
            <seealso cref="T:NetTopologySuite.Geometries.IPolygonal"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence">
            <summary>
            A <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> backed by an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            This is the implementation that <see cref="T:NetTopologySuite.Geometries.Geometry"/>s use by default.
            <para/>
            Coordinates returned by <see cref="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.ToCoordinateArray"/>, <see cref="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32)"/> and <see cref="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)"/> are live --
            modifications to them are actually changing the
            CoordinateSequence's underlying data.
            A dimension may be specified for the coordinates in the sequence,
            which may be 2 or 3.
            The actual coordinates will always have 3 ordinates,
            but the dimension is useful as metadata in some situations.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.Coordinates">
            <summary>
            Array of coordinates in sequence
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Constructs a sequence based on the given array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            The coordinate dimension defaults to 2
            </summary>
            <remarks>
            The array is not copied.
            </remarks>
            <param name="coordinates">The coordinate array that will be referenced.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Constructs a sequence based on the given array
            of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <remarks>The Array is not copied</remarks>
            <param name="coordinates">The coordinate array that will be referenced.</param>
            <param name="dimension">The dimension of the coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Constructs a sequence based on the given array
            of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            <para/>
            The Array is <b>not</b> copied
            <para/>
            It is your responsibility to ensure the array contains Coordinates of the
            indicated dimension and measures (See <see cref="M:NetTopologySuite.Geometries.CoordinateArrays.EnforceConsistency(NetTopologySuite.Geometries.Coordinate[])"/>).
            </summary>
            <param name="coordinates">The coordinate array that will be referenced.</param>
            <param name="dimension">The dimension of the coordinates</param>
            <param name="measures">The number of measure ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(System.Int32)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a sequence of a given <paramref name="size"/>, populated
            with new <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s of the given <paramref name="dimension"/>.
            </summary>
            <param name="size">The size of the sequence to create.</param>
            <param name="dimension">the dimension of the coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a sequence of a given <paramref name="size"/>, populated
            with new <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s of the given <paramref name="dimension"/>
            with the given number of <paramref name="measures"/>
            </summary>
            <param name="size">The size of the sequence to create.</param>
            <param name="dimension">the dimension of the coordinates</param>
            <param name="measures">the number of measures of the coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.#ctor(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a new sequence based on a deep copy of the given <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <param name="coordSeq">The coordinate sequence that will be copied</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.EnforceArrayConsistency(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Ensure array contents of the same type, making use of <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.CreateCoordinate"/> as needed.
            <para>
            A new array will be created if needed to return a consistent result.
            </para>
            </summary>
            <param name="array">array containing consistent coordinate instances</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32)">
            <summary>
            Get the Coordinate with index i.
            </summary>
            <param name="i">The index of the coordinate.</param>
            <returns>The requested Coordinate instance.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinateCopy(System.Int32)">
            <summary>
            Get a copy of the Coordinate with index i.
            </summary>
            <param name="i">The index of the coordinate.</param>
            <returns>A copy of the requested Coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Copies the i'th coordinate in the sequence to the supplied Coordinate.
            </summary>
            <param name="index">The index of the coordinate to copy.</param>
            <param name="coord">A Coordinate to receive the value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetX(System.Int32)">
            <summary>
            Returns ordinate X (0) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the X ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetY(System.Int32)">
            <summary>
            Returns ordinate Y (1) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the Y ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetZ(System.Int32)">
            <summary>
            Returns ordinate Z of the specified coordinate if available.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the Z ordinate in the index'th coordinate, or Double.NaN if not defined.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetM(System.Int32)">
            <summary>
            Returns ordinate M of the specified coordinate if available.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the M ordinate in the index'th coordinate, or Double.NaN if not defined.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetOrdinate(System.Int32,System.Int32)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinate indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.Copy">
            <summary>
            Creates a deep copy of the <c>CoordinateArraySequence</c>.
            </summary>
            <returns>The deep copy.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetClonedCoordinates">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.ToCoordinateArray">
             <summary>
            This method exposes the internal Array of Coordinate Objects.
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.Reversed">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.Reversed"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.ToString">
            <summary>
            Returns the string representation of the coordinate array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory">
            <summary>
            Creates CoordinateSequences represented as an array of Coordinates.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.Instance">
            <summary>
            Returns the singleton instance of CoordinateArraySequenceFactory.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.Create(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
             Returns a CoordinateArraySequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">the coordinates, which may not be null nor contain null elements.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.Create(NetTopologySuite.Geometries.CoordinateSequence)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(NetTopologySuite.Geometries.CoordinateSequence)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.Create(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequenceFactory.Create(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence">
            <summary>
            A coordinate sequence that follows the dotspatial shape range
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.#ctor(System.Collections.Generic.IReadOnlyCollection{NetTopologySuite.Geometries.Coordinate},NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="coordinates">The coordinates</param>
            <param name="ordinates"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
            <param name="dimension">The number of dimensions.</param>
            <param name="measures">The number of measures.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.#ctor(System.Int32,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
            <param name="ordinates">The kind of ordinates.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.#ctor(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a sequence based on the given coordinate sequence.
            </summary>
            <param name="coordSeq">The coordinate sequence.</param>
            <param name="ordinates">The ordinates to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.#ctor(System.Double[],System.Double[],System.Double[])">
             <summary>
            
             </summary>
             <param name="xy"></param>
             <param name="z"></param>
             <param name="m"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.Copy">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.Copy"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetCoordinateCopy(System.Int32)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinateCopy(System.Int32)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetCoordinate(System.Int32,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetX(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetY(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetZ(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetM(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.SetX(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.SetY(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.SetZ(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.SetM(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.GetOrdinate(System.Int32,System.Int32)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.GetOrdinate(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ToCoordinateArray">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.ToCoordinateArray"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.Reversed">
            <summary>
            Creates a reversed version of this coordinate sequence with cloned <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s
            </summary>
            <returns>A reversed version of this sequence</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.XY">
            <summary>
            Gets the vector with x- and y-ordinate values;
            </summary>
            <remarks>If you modify the values of this vector externally, you need to call <see cref="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ReleaseCoordinateArray"/>!</remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.Z">
            <summary>
            Gets the vector with z-ordinate values
            </summary>
            <remarks>If you modify the values of this vector externally, you need to call <see cref="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ReleaseCoordinateArray"/>!</remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.M">
            <summary>
            Gets the vector with measure values
            </summary>
            <remarks>If you modify the values of this vector externally, you need to call <see cref="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ReleaseCoordinateArray"/>!</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.ReleaseCoordinateArray">
            <summary>
            Releases the weak reference to the weak referenced coordinate array
            </summary>
            <remarks>This is necessary if you modify the values of the <see cref="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.XY"/>, <see cref="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.Z"/>, <see cref="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.M"/> arrays externally.</remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory">
            <summary>
            A coordinate sequence factory class that creates DotSpatial's Shape/ShapeRange like coordinate sequences.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Instance">
            <summary>
            Returns the singleton instance of DotSpatialAffineCoordinateSequenceFactory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
             Returns a CoordinateArraySequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">the coordinates, which may not be null nor contain null elements.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />  which is a copy
            of the given <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" />.
            This method must handle null arguments by creating an empty sequence.
            </summary>
            <param name="coordSeq"></param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(System.Int32,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> of the specified size and ordinates.
            For this to be useful, the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence" /> implementation must be mutable.
            </summary>
            <param name="size">The number of coordinates.</param>
            <param name="ordinates">
            The ordinates each coordinate has. <see cref="F:NetTopologySuite.Geometries.Ordinates.XY"/> is fix,
            <see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/> and <see cref="F:NetTopologySuite.Geometries.Ordinates.M"/> can be set.
            </param>
            <returns>A coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(System.Double[])">
            <summary>
            Creates an instance of this class using the provided <paramref name="xy"/> array for x- and y ordinates
            </summary>
            <param name="xy">The x- and y-ordinates</param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(System.Double[],System.Double[],System.Boolean)">
            <summary>
            Creates an instance of this class using the provided <paramref name="xy"/> array for x- and y ordinates,
            the <paramref name="zm"/> array for either z-ordinates or measure values. This is indicated by <paramref name="isMeasure"/>.
            </summary>
            <param name="xy">The x- and y-ordinates</param>
            <param name="zm">An array of z- or measure values</param>
            <param name="isMeasure">A value indicating if <paramref name="zm"/> contains z-ordinates or measure values.</param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.Create(System.Double[],System.Double[],System.Double[])">
            <summary>
            Creates an instance of this class using the provided <paramref name="xy"/> array for x- and y ordinates,
            the <paramref name="z"/> array for z ordinates and <paramref name="m"/> for measure values.
            </summary>
            <param name="xy">The x- and y-ordinates</param>
            <param name="z">An array of z- or measure values</param>
            <param name="m">An array of measure values.</param>
            <returns>A coordinate sequence</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence">
            <summary>
            A <c>CoordinateSequence</c> implementation based on a packed arrays.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.CoordRef">
            <summary>
            A soft reference to the Coordinate[] representation of this sequence.
            Makes repeated coordinate array accesses more efficient.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="count">The number of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s in the sequence.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">the number of measure-ordinates each {<see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.GetCoordinate(System.Int32)">
            <summary>
            Returns (possibly a copy of) the ith Coordinate in this collection.
            Whether or not the Coordinate returned is the actual underlying
            Coordinate or merely a copy depends on the implementation.
            Note that in the future the semantics of this method may change
            to guarantee that the Coordinate returned is always a copy. Callers are
            advised not to assume that they can modify a CoordinateSequence by
            modifying the Coordinate returned by this method.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.ToCoordinateArray">
            <summary>
            Returns (possibly copies of) the Coordinates in this collection.
            Whether or not the Coordinates returned are the actual underlying
            Coordinates or merely copies depends on the implementation.
            Note that if this implementation does not store its data as an array of Coordinates,
            this method will incur a performance penalty because the array needs to
            be built from scratch.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.ReleaseCoordinateArray">
            <summary>
            Releases the weak reference to the coordinate array.
            </summary>
            <remarks>
            This is necessary if you directly modify the array from <c>GetRawCoordinates</c>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.GetCoordinateInternal(System.Int32)">
            <summary>
            Returns a Coordinate representation of the specified coordinate, by always
            building a new Coordinate object.
            </summary>
            <param name="index">The coordinate index</param>
            <returns>The <see cref="T:NetTopologySuite.Geometries.Coordinate"/> at the given index</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence">
            <summary>
            Packed coordinate sequence implementation based on doubles.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence._coords">
            <summary>
            The packed coordinate array
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <c>double</c> values that contains the ordinate values of the sequence.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(System.Single[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <c>float</c> values that contains the ordinate values of the sequence.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="size">The number of coordinates in this sequence</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.GetRawCoordinates">
            <summary>
            Gets the underlying array containing the coordinate values.
            </summary>
            <returns>The array of coordinate values</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.Copy">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.Copy"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.GetOrdinate(System.Int32,System.Int32)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinate indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <remarks>
            Beware, for performance reasons the ordinate index is not checked, if
            it's over dimensions you may not get an exception but a meaningless
            value.
            </remarks>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate, 0 based,
            smaller than the number of dimensions.</param>
            <param name="value">The new ordinate value.</param>
            <remarks>
            Warning: for performance reasons the ordinate index is not checked.
            If it is larger than the dimension a meaningless value may be returned.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence">
            <summary>
            Packed coordinate sequence implementation based on floats.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence._coords">
            <summary>
            The packed coordinate array
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(System.Single[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <c>float</c> values that contains the ordinate values of the sequence.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <c>double</c> values that contains the ordinate values of the sequence.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> class.
            </summary>
            <param name="coords">An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.</param>
            <param name="dimension">The total number of ordinates that make up a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence.</param>
            <param name="measures">The number of measure-ordinates each <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this sequence has.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence"/> class.
            </summary>
            <param name="size"></param>
            <param name="dimension"></param>
            <param name="measures"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.GetRawCoordinates">
            <summary>
            Gets the underlying array containing the coordinate values.
            </summary>
            <returns>The array of coordinate values</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.Copy">
            <inheritdoc cref="M:NetTopologySuite.Geometries.CoordinateSequence.Copy"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.GetOrdinate(System.Int32,System.Int32)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinate indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <remarks>
            Beware, for performance reasons the ordinate index is not checked, if
            it's over dimensions you may not get an exception but a meaningless
            value.
            </remarks>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index.</param>
            <param name="ordinateIndex">The ordinate index in the coordinate, 0 based,
            smaller than the number of dimensions.</param>
            <param name="value">The new ordinate value.</param>
            <remarks>
            Warning: for performance reasons the ordinate index is not checked:
            if it is over dimensions you may not get an exception but a meaningless value.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory">
            <summary>
            Builds packed array coordinate sequences.
            The array data type can be either
            <c>double</c> or <c>float</c>,
            and defaults to <c>double</c>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType">
            <summary>
            An enumeration of valid type codes
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Double">
            <summary>
            Type code for arrays of type <c>double</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Float">
            <summary>
            Type code for arrays of type <c>float</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.DoubleFactory">
            <summary>
            A factory creating <see cref="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Double"/> coordinate sequences
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.FloatFactory">
            <summary>
            A factory creating <see cref="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Float"/> coordinate sequences
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory"/> class,
            using double values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.#ctor(NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type">
            <summary>
            Gets the type of packed coordinate sequence this factory builds, either
            <see cref="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Float"/> or <see cref="F:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.Double"/>
            </summary>
            <value>The type of packed array built.</value>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns a CoordinateSequence based on the given array; whether or not the
            array is copied is implementation-dependent.
            </summary>
            <param name="coordinates">Coordinates array, which may not be null nor contain null elements</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Returns a CoordinateSequence based on the given coordinate sequence; whether or not the
            array is copied is implementation-dependent.
            </summary>
            <param name="coordSeq"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(System.Double[],System.Int32)">
            <summary>
            Creates a packed coordinate sequence of type <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/> from the provided <c>double</c> array
            using the provided dimension and a measure of <c>0</c>.
            </summary>
            <param name="packedCoordinates">The array containing coordinate values</param>
            <param name="dimension">The coordinate dimension</param>
            <returns>A packed coordinate sequence of <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(System.Double[],System.Int32,System.Int32)">
            <summary>
            Creates a packed coordinate sequence of type <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/> from the provided <c>double</c> array
            using the provided dimension and a measure of <c>0</c>.
            </summary>
            <param name="packedCoordinates">The array containing coordinate values</param>
            <param name="dimension">The coordinate dimension</param>
            <param name="measures">The coordinate measure count</param>
            <returns>A packed coordinate sequence of <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(System.Single[],System.Int32)">
            <summary>
            Creates a packed coordinate sequence of type <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/> from the provided <c>float</c> array
            using the provided dimension and a measure of <c>0</c>.
            </summary>
            <param name="packedCoordinates">The array containing coordinate values</param>
            <param name="dimension">The coordinate dimension</param>
            <returns>A packed coordinate sequence of <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(System.Single[],System.Int32,System.Int32)">
            <summary>
            Creates a packed coordinate sequence of type <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/> from the provided <c>float</c> array
            using the provided dimension and a measure of <c>0</c>.
            </summary>
            <param name="packedCoordinates">The array containing coordinate values</param>
            <param name="dimension">The coordinate dimension</param>
            <param name="measures">The coordinate measure count</param>
            <returns>A packed coordinate sequence of <see cref="P:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Type"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.Create(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence">
            <summary>
            An implementation of <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> that packs its contents in a way that
            can be customized by the creator.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.#ctor(System.Memory{System.Double}[],System.ValueTuple{System.Int32,System.Int32}[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> class.
            </summary>
            <param name="rawData">
            Contains the raw data for this sequence.
            </param>
            <param name="dimensionMap">
            Contains a pair of indexes to tell us, for each dimension, where to find its data in
            <paramref name="rawData"/>.
            </param>
            <param name="measures">
            The value for <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Measures"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.GetRawCoordinatesAndStride(System.Int32)">
            <summary>
            Gets the underlying <see cref="T:System.Memory`1"/> for the ordinates at the given index, along
            with a "stride" value that represents how many slots there are between elements.
            </summary>
            <param name="ordinateIndex">
            The index of the ordinate whose values to get, from
            <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.TryGetOrdinateIndex(NetTopologySuite.Geometries.Ordinate,System.Int32@)"/>.
            </param>
            <returns>
            The underlying <see cref="T:System.Memory`1"/> and stride.
            </returns>
            <remarks>
            Assuming <see cref="P:NetTopologySuite.Geometries.CoordinateSequence.Count"/> is nonzero, the first element of the
            returned array holds the first coordinate's value for the requested ordinate, and the
            last element of the returned array holds the last coordinate's value for the requested
            ordinate.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.GetOrdinate(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.Copy">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.Reversed">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.ExpandEnvelope(NetTopologySuite.Geometries.Envelope)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.ToCoordinateArray">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory">
            <summary>
            Factory for creating <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instances.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Ordinates})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory"/> class.
            </summary>
            <param name="ordinateGroups">
            A sequence of zero or more <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags representing ordinate values
            that should be allocated together.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="ordinateGroups"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when a given flag appears in more than one element of
            <paramref name="ordinateGroups"/>.
            </exception>
            <remarks>
            Any flags not represented in <paramref name="ordinateGroups"/>, and any spatial or
            measure dimensions beyond the 16th, will be allocated together, SoA-style.
            <para/>
            Elements without any bits set will be silently ignored.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXY(System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given arrays for reading
            and writing X and Y data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="x">
            An array of X values, laid out as
            <c>[x0, x1, x2, ..., xn]</c>.
            </param>
            <param name="y">
            An array of Y values, laid out as
            <c>[y0, y1, y2, ..., yn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given arrays.
            </returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXY(System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X and Y data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xy">
            An array of X and Y values, laid out as
            <c>[x0, y0, x1, y1, x2, y2, ..., xn, yn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xy"/> is not a multiple of 2.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZ(System.Memory{System.Double},System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given arrays for reading
            and writing X, Y, and Z data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="x">
            An array of X values, laid out as
            <c>[x0, x1, x2, ..., xn]</c>.
            </param>
            <param name="y">
            An array of Y values, laid out as
            <c>[y0, y1, y2, ..., yn]</c>.
            </param>
            <param name="z">
            An array of Z values, laid out as
            <c>[z0, z1, z2, ..., zn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given arrays.
            </returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZ(System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, and Z data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xy">
            An array of X and Y values, laid out as
            <c>[x0, y0, x1, y1, x2, y2, ..., xn, yn]</c>.
            </param>
            <param name="z">
            An array of Z values, laid out as
            <c>[z0, z1, z2, ..., zn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xy"/> is not a multiple of 2, or when the
            input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZ(System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, and Z data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xyz">
            An array of X, Y, and Z values, laid out as
            <c>[x0, y0, z0, x1, y1, z1, x2, y2, z2, ..., xn, yn, zn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xyz"/> is not a multiple of 3.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYM(System.Memory{System.Double},System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given arrays for reading
            and writing X, Y, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="x">
            An array of X values, laid out as
            <c>[x0, x1, x2, ..., xn]</c>.
            </param>
            <param name="y">
            An array of Y values, laid out as
            <c>[y0, y1, y2, ..., yn]</c>.
            </param>
            <param name="m">
            An array of M values, laid out as
            <c>[m0, m1, m2, ..., mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given arrays.
            </returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYM(System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xy">
            An array of X and Y values, laid out as
            <c>[x0, y0, x1, y1, x2, y2, ..., xn, yn]</c>.
            </param>
            <param name="m">
            An array of M values, laid out as
            <c>[m0, m1, m2, ..., mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xy"/> is not a multiple of 2, or when the
            input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYM(System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xym">
            An array of X, Y, and M values, laid out as
            <c>[x0, y0, m0, x1, y1, m1, x2, y2, m2, ..., xn, yn, mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xym"/> is not a multiple of 3.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZM(System.Memory{System.Double},System.Memory{System.Double},System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given arrays for reading
            and writing X, Y, Z, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="x">
            An array of X values, laid out as
            <c>[x0, x1, x2, ..., xn]</c>.
            </param>
            <param name="y">
            An array of Y values, laid out as
            <c>[y0, y1, y2, ..., yn]</c>.
            </param>
            <param name="z">
            An array of Z values, laid out as
            <c>[z0, z1, z2, ..., zn]</c>.
            </param>
            <param name="m">
            An array of M values, laid out as
            <c>[m0, m1, m2, ..., mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given arrays.
            </returns>
            <exception cref="T:System.ArgumentException">
            Thrown when the input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZM(System.Memory{System.Double},System.Memory{System.Double},System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, Z, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xy">
            An array of X and Y values, laid out as
            <c>[x0, y0, x1, y1, x2, y2, ..., xn, yn]</c>.
            </param>
            <param name="z">
            An array of Z values, laid out as
            <c>[z0, z1, z2, ..., zn]</c>.
            </param>
            <param name="m">
            An array of M values, laid out as
            <c>[m0, m1, m2, ..., mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xy"/> is not a multiple of 2, or when the
            input arrays do not contain data for the same number of coordinates.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.CreateXYZM(System.Memory{System.Double})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> that uses the given array for reading
            and writing X, Y, Z, and M data ignoring the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> flags that were passed
            into the constructor for this factory instance.
            </summary>
            <param name="xyzm">
            An array of X, Y, Z, and M values, laid out as
            <c>[x0, y0, z0, m0, x1, y1, z1, m1, x2, y2, z2, m2, ..., xn, yn, zn, mn]</c>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Implementation.RawCoordinateSequence"/> instance that's backed by the given array.
            </returns>
            <remarks>
            The resulting instance is essentially a <see cref="T:NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence"/>
            with slightly more overhead, so the main reason to prefer this over that one would be if
            you <b>really</b> need to avoid copying the data to fit it into that format.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of <paramref name="xyzm"/> is not a multiple of 4.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.Create(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Geometries.IntersectionMatrix">
            <summary>  
            Models a <b>Dimensionally Extended Nine-Intersection Model (DE-9IM)</b> matrix. 
            </summary>
            <remarks>
            DE-9IM matrix values (such as "212FF1FF2")
            specify the topological relationship between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s. 
            This class can also represent matrix patterns (such as "T*T******")
            which are used for matching instances of DE-9IM matrices.
            <para/>
            DE-9IM matrices are 3x3 matrices with integer entries.
            The matrix indices {0,1,2}
            represent the topological locations
            that occur in a geometry(Interior, Boundary, Exterior).
            These are provided by the constants
            <see cref="F:NetTopologySuite.Geometries.Location.Interior"/>, <see cref="F:NetTopologySuite.Geometries.Location.Boundary"/>, and <see cref="F:NetTopologySuite.Geometries.Location.Exterior"/>.
            <para/>
            When used to specify the topological relationship between two geometries,
            the matrix entries represent the possible dimensions of each intersection:
            <see cref="F:NetTopologySuite.Geometries.Dimension.A"/> = 2, <see cref="F:NetTopologySuite.Geometries.Dimension.L"/> = 1, <see cref="F:NetTopologySuite.Geometries.Dimension.P"/> = 0 and <see cref="F:NetTopologySuite.Geometries.Dimension.False"/> = -1.<br/>
            When used to represent a matrix pattern entries can have the additional values
            <see cref="F:NetTopologySuite.Geometries.Dimension.True"/> ("T") and <see cref="F:NetTopologySuite.Geometries.Dimension.Dontcare"/> ("*"). 
            <para/>
            For a description of the DE-9IM and the spatial predicates derived from it, see the following references:
            <list type="bullet">
            <item><description><i><see href="http://portal.opengeospatial.org/files/?artifact_id=829">OGC 99-049 OpenGIS Simple Features Specification for SQL.</see></i></description></item>
            <item><description>
                <i><a href="http://portal.opengeospatial.org/files/?artifact_id=25355">OGC 06-103r4 OpenGIS Implementation Standard for Geographic information - Simple feature access - Part 1: Common architecture</a></i>, 
                Section 6.1.15 (which provides some further details on certain predicate specifications).</description></item>
            <item><description>Wikipedia article on <a href="https://en.wikipedia.org/wiki/DE-9IM">DE-9IM</a></description></item>
            </list>
            <para/>
            Methods are provided to:
            <list type="bullet">
            <item><description>set and query the elements of the matrix in a convenient fashion</description></item>
            <item><description>convert to and from the standard string representation(specified in SFS Section 2.1.13.2).</description></item>
            <item><description>test if a matrix matches a given pattern string.</description></item>
            <item><description>test if a matrix(possibly with geometry dimensions) matches a standard named spatial predicate</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.IntersectionMatrix._matrix">
            <summary>  
            Internal representation of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.#ctor">
            <summary>  
            Creates an <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> with <c>null</c> location values.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.#ctor(System.String)">
            <summary>
            Creates an <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> with the given dimension
            symbols.
            </summary>
            <param name="elements">A string of nine dimension symbols in row major order.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.#ctor(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary> 
            Creates an <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> with the same elements as
            <c>other</c>.
            </summary>
            <param name="other">An <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> to copy.</param>         
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Add(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary> 
            Adds one matrix to another.
            Addition is defined by taking the maximum dimension value of each position
            in the summand matrices.
            </summary>
            <param name="im">The matrix to add.</param>        
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsTrue(NetTopologySuite.Geometries.Dimension)">
            <summary>
            Tests if the dimension value matches <tt>TRUE</tt>
            (i.e.  has value 0, 1, 2 or TRUE).
            </summary>
            <param name="actualDimensionValue">A number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>{<see cref="F:NetTopologySuite.Geometries.Dimension.True"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.False"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Dontcare"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Point"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Curve"/>, <see cref="F:NetTopologySuite.Geometries.Dimension.Surface"/>}</c></param>
            <returns><c>true</c> if the dimension value matches <see cref="F:NetTopologySuite.Geometries.Dimension.True"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Matches(NetTopologySuite.Geometries.Dimension,System.Char)">
            <summary>  
            Tests if the dimension value satisfies the dimension symbol.
            </summary>
            <param name="actualDimensionValue">
            a number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>{True, False, Dontcare, 0, 1, 2}</c>.
            </param>
            <param name="requiredDimensionSymbol">
            A character used in the string
            representation of an <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />. 
            Possible values are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <returns>
            <c>true</c> if the dimension symbol encompasses the dimension value.        
            </returns>        
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Matches(System.String,System.String)">
            <summary>
            Tests if each of the actual dimension symbols in a matrix string satisfies the
            corresponding required dimension symbol in a pattern string.
            </summary>
            <param name="actualDimensionSymbols">
            Nine dimension symbols to validate.
            Possible values are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <param name="requiredDimensionSymbols">
            Nine dimension symbols to validate
            against. Possible values are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <returns>
            <c>true</c> if each of the required dimension
            symbols encompass the corresponding actual dimension symbol.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Set(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Changes the value of one of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> elements.
            </summary>
            <param name="row">
            The row of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />,
            indicating the interior, boundary or exterior of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            </param>
            <param name="column">
            The column of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />,
            indicating the interior, boundary or exterior of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            </param>
            <param name="dimensionValue">The new value of the element</param>        
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Set(System.String)">
            <summary>
            Changes the elements of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> to the
            dimension symbols in <c>dimensionSymbols</c>.
            </summary>
            <param name="dimensionSymbols">
            Nine dimension symbols to which to set this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />
            s elements. Possible values are <c>{T, F, * , 0, 1, 2}</c>
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.SetAtLeast(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Changes the specified element to <c>minimumDimensionValue</c> if the element is less.
            </summary>
            <param name="row">
            The row of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />, 
            indicating the interior, boundary or exterior of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </param>
            <param name="column">
            The column of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />, 
            indicating the interior, boundary or exterior of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </param>
            <param name="minimumDimensionValue">
            The dimension value with which to compare the
            element. The order of dimension values from least to greatest is
            <c>True, False, Dontcare, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.SetAtLeastIfValid(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Dimension)">
            <summary>
            If row >= 0 and column >= 0, changes the specified element to <c>minimumDimensionValue</c>
            if the element is less. Does nothing if row is smaller to 0 or column is smaller to 0.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="minimumDimensionValue"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.SetAtLeast(System.String)">
            <summary>
            For each element in this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />, changes the
            element to the corresponding minimum dimension symbol if the element is
            less.
            </summary>
            <param name="minimumDimensionSymbols"> 
            Nine dimension symbols with which to
            compare the elements of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />. The
            order of dimension values from least to greatest is <c>Dontcare, True, False, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.SetAll(NetTopologySuite.Geometries.Dimension)">
            <summary>  
            Changes the elements of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> to <c>dimensionValue</c>.
            </summary>
            <param name="dimensionValue">
            The dimension value to which to set this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />
            s elements. Possible values <c>True, False, Dontcare, 0, 1, 2}</c>.
            </param>         
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Get(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Returns the value of one of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />s
            elements.
            </summary>
            <param name="row">
            The row of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />, indicating
            the interior, boundary or exterior of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </param>
            <param name="column">
            The column of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />,
            indicating the interior, boundary or exterior of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </param>
            <returns>The dimension value at the given matrix position.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.IntersectionMatrix.Item(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            See methods Get(int, int) and Set(int, int, int value)
            </summary>         
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsDisjoint">
            <summary>
            Tests if this matrix matches <c>[FF*FF****]</c>.
            </summary>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>'s related by
            this matrix are disjoint.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsIntersects">
            <summary>
            Tests if <c>isDisjoint</c> returns <see langword="false"/>.
            </summary>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>'s related by
            this matrix intersect.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsTouches(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Tests if this matrix matches
            <c>[FT*******]</c>, <c>[F**T*****]</c> or <c>[F***T****]</c>.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            s related by this matrix touch; Returns false
            if both <see cref="T:NetTopologySuite.Geometries.Geometry"/>s are points.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsCrosses(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Tests whether this geometry crosses the
            specified geometry.
            </summary>
            <remarks>
            The <c>crosses</c> predicate has the following equivalent definitions:
            <list type="bullet">
            <item><description>The geometries have some but not all interior points in common.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches</description></item>
              <list type="bullet">
                <item><description><c>[T*T******]</c> (for P/L, P/A, and L/A situations)</description></item>
                <item><description><c>[T*****T**]</c> (for L/P, L/A, and A/L situations)</description></item>
                <item><description><c>[0********]</c> (for L/L situations)</description></item>
              </list>
            </list>
            For any other combination of dimensions this predicate returns <c>false</c>.
            <para/>
            The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
            JTS extends the definition to apply to L/P, A/P and A/L situations as well.
            This makes the relation symmetric.
            </remarks>
            <param name="dimensionOfGeometryA">The dimension of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            s related by this matrix cross. 
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsWithin">
            <summary>  
            Tests whether this matrix matches <c>[T*F**F***]</c>.
            </summary>
            <returns><c>true</c> if the first <see cref="T:NetTopologySuite.Geometries.Geometry"/> is within the second.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsContains">
            <summary> 
            Tests whether this matrix matches <c>[T*****FF*]</c>
            </summary>
            <returns><c>true</c> if the first <see cref="T:NetTopologySuite.Geometries.Geometry"/> contains the second.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsCovers">
            <summary>
            Tests if this matrix matches
               <c>[T*****FF*]</c>
            or <c>[*T****FF*]</c>
            or <c>[***T**FF*]</c>
            or <c>[****T*FF*]</c>.
            </summary>
            <returns><c>true</c> if the first <see cref="T:NetTopologySuite.Geometries.Geometry"/> covers the second</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsCoveredBy">
            <summary>
            Tests if this matrix matches
               <c>[T*F**F***]</c>
            or <c>[*TF**F***]</c>
            or <c>[**FT*F***]</c>
            or <c>[**F*TF***]</c>.
            </summary>
            <returns><c>true</c> if the first <see cref="T:NetTopologySuite.Geometries.Geometry"/> is covered by the second</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsEquals(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)">
            <summary> 
            Tests whether the argument dimensions are equal and 
            this matrix matches the pattern <c>[T*F**FFF*]</c>.
            <para/>
            <b>Note:</b> This pattern differs from the one stated in 
            <i>Simple feature access - Part 1: Common architecture</i>.
            That document states the pattern as <c>[TFFFTFFFT]</c>.  This would
            specify that
            two identical <tt>POINT</tt>s are not equal, which is not desirable behaviour.
            The pattern used here has been corrected to compute equality in this situation.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            related by this matrix are equal; the
            <see cref="T:NetTopologySuite.Geometries.Geometry"/>s must have the same dimension to be equal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.IsOverlaps(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Tests if this matrix matches
            <list type="bullet">
            <item><description><c>[T*T***T**]</c> (for two points or two surfaces)</description></item>
            <item><description><c>[1*T***T**]</c> (for two curves)</description></item>
            </list>
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</param>
            <returns>
            <c>true</c> if the two <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            s related by this matrix overlap. For this
            function to return <c>true</c>, the <see cref="T:NetTopologySuite.Geometries.Geometry"/>s must
            be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Matches(System.String)">
            <summary> 
            Tests whether this matrix matches the given matrix pattern
            </summary>
            <param name="pattern"> 
            A pattern containing nine dimension symbols with which to
            compare the entries of this matrix.Possible
            symbol values are <c>{ T, F, * , 0, 1, 2}</c>.
            </param>
            <returns>
            <c>true</c> if this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />
            matches the required dimension symbols.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.Transpose">
            <summary>  
            Transposes this IntersectionMatrix.
            </summary>
            <returns>This <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" /> as a convenience,</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.IntersectionMatrix.ToString">
            <summary>
            Returns a nine-character <c>String</c> representation of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />.
            </summary>
            <returns>
            The nine dimension symbols of this <see cref="T:NetTopologySuite.Geometries.IntersectionMatrix" />
            in row-major order.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.IPolygonal">
            <summary>
            Interface to identify all <c>Geometry</c> subclasses that have a <c>Dimension</c> of <see cref="F:NetTopologySuite.Geometries.Dimension.Surface"/>
            and have components that are <see cref="T:NetTopologySuite.Geometries.Polygon"/>s.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Geometries.IPuntal"/>
            <seealso cref="T:NetTopologySuite.Geometries.ILineal"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.IPuntal">
            <summary>
            Interface to identify all <c>Geometry</c> subclasses that have a <c>Dimension</c> of <see cref="F:NetTopologySuite.Geometries.Dimension.Point"/>
            and have components that ar <see cref="T:NetTopologySuite.Geometries.Point"/>s.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Geometries.ILineal"/>
            <seealso cref="T:NetTopologySuite.Geometries.IPolygonal"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.LinearRing">
            <summary>
            Models an OGC SFS <c>LinearRing</c>.
            </summary>
            <remarks>
            A <c>LinearRing</c> is a <see cref="T:NetTopologySuite.Geometries.LineString"/> which is both closed and simple.
            In other words,
            the first and last coordinate in the ring must be equal,
            and the ring must not self-intersect.
            Either orientation of the ring is allowed.
            <para/>
            A ring must have either 0 or 3 or more points.
            The first and last points must be equal (in 2D).
            If these conditions are not met, the constructors throw
            an <see cref="T:System.ArgumentException"/><br/>
            A ring with 3 points is invalid, because it is collapsed
            and thus has a self-intersection. It is allowed to be constructed
            so that it can be represented, and repaired if needed.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRing.MinimumValidSize">
            <summary>
            The minimum number of vertices allowed in a valid non-empty ring.
            Empty rings with 0 vertices are also valid.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.#ctor(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>LinearRing</c> with the vertices specified
            by the given <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <param name="points">A sequence points forming a closed and simple linestring,
            or <c>null</c> to create the empty geometry.</param>
            <param name="factory">The factory that creates this <c>LinearRing</c></param>
            <exception cref="T:System.ArgumentException">If the ring is not closed, or has too few points</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.ValidateConstruction">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing.BoundaryDimension">
            <summary>
            Returns <c>Dimensions.False</c>, since by definition LinearRings do not have a boundary.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"LinearRing"</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.Reverse">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function for <c>LINEARRING</c>s.
            </summary>
            <returns>A reversed geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing.IsCCW">
            <summary>
            Gets a value indicating if this <c>LINEARRING</c> is oriented <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.LinearRing"/> class.
            </summary>
            <param name="points">The points used for create this instance.</param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">If the ring is not closed, or has too few points</exception>
        </member>
        <member name="T:NetTopologySuite.Geometries.LinearRingOrientation">
            <summary>
            An enumeration of ring orientation values
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.CounterClockwise">
            <summary>
            The orientation of the ring's coordinates is counter-clockwise.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.LeftHandRule">
            <summary>
            The orientation of the ring's coordinates follows the left-hand-rule,
            saying that if you follow the ring in the direction of its coordinates
            your left hand will be inside the ring.
            </summary>
            <seealso cref="F:NetTopologySuite.Geometries.LinearRingOrientation.CounterClockwise"/>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.CCW">
            <summary>
            The orientation of the ring's coordinates is counter-clockwise.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.DontCare">
            <summary>
            The orientation of the rings coordinates does not matter.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.Default">
            <summary>
            The default orientation of the rings coordinates.
            Set to <see cref="F:NetTopologySuite.Geometries.LinearRingOrientation.CounterClockwise"/>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.Clockwise">
            <summary>
            The orientation of the ring's coordinates is clockwise.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.RightHandRule">
            <summary>
            The orientation of the ring's coordinates follows the right-hand-rule,
            saying that if you follow the ring in the direction of its coordinates
            your right hand will be inside the ring.
            </summary>
            <seealso cref="F:NetTopologySuite.Geometries.LinearRingOrientation.Clockwise"/>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRingOrientation.CW">
            <summary>
            The orientation of the ring's coordinates is clockwise.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.LineSegment">
            <summary>
            Represents a line segment defined by two <c>Coordinate</c>s.
            Provides methods to compute various geometric properties
            and relationships of line segments.
            This class is designed to be easily mutable (to the extent of
            having its contained points public).
            This supports a common pattern of reusing a single LineSegment
            object as a way of computing segment properties on the
            segments defined by arrays or lists of <c>Coordinate</c>s.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.P1">
            <summary>
            The end-point
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.P0">
            <summary>
            The start-point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this class using two coordinates
            </summary>
            <param name="p0">The start-point</param>
            <param name="p1">The end-point</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.#ctor(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Creates an instance of this class using another instance
            </summary>
            <param name="ls"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.SetCoordinates(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="ls"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.SetCoordinates(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.MinX">
            <summary>
            Gets the minimum X ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.MaxX">
            <summary>
            Gets the maximum X ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.MinY">
            <summary>
            Gets the minimum Y ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.MaxY">
            <summary>
            Gets the maximum Y ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.Length">
            <summary>
            Computes the length of the line segment.
            </summary>
            <returns>The length of the line segment.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.IsHorizontal">
            <summary>
            Tests whether the segment is horizontal.
            </summary>
            <returns><c>true</c> if the segment is horizontal.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.IsVertical">
            <summary>
            Tests whether the segment is vertical.
            </summary>
            <returns><c>true</c> if the segment is vertical.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.OrientationIndex(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Determines the orientation of a LineSegment relative to this segment.
            The concept of orientation is specified as follows:
            Given two line segments A and L,
            A is to the left of a segment L if A lies wholly in the
            closed half-plane lying to the left of L
            A is to the right of a segment L if A lies wholly in the
            closed half-plane lying to the right of L
            otherwise, A has indeterminate orientation relative to L. This
            happens if A is collinear with L or if A crosses the line determined by L.
            </summary>
            <param name="seg">The <c>LineSegment</c> to compare.</param>
            <returns>
            1 if <c>seg</c> is to the left of this segment,
            -1 if <c>seg</c> is to the right of this segment,
            0 if <c>seg</c> is collinear to or crosses this segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.OrientationIndex(NetTopologySuite.Geometries.Coordinate)">
             <summary>
             Determines the orientation index of a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> relative to this segment.
             The orientation index is as defined in <see cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>.
             </summary>
            
             <returns>
             <list type="table">
             <item><term>1</term><description>if <c>p</c> is to the left of this segment</description></item>
             <item><term>-1</term><description>if <c>p</c> is to the right of this segment</description></item>
             <item><term>0</term><description>if <c>p</c> is collinear with this segment</description></item>
             </list>"
             </returns>
            
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Reverse">
            <summary>
            Reverses the direction of the line segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Normalize">
            <summary>
            Puts the line segment into a normalized form.
            This is useful for using line segments in maps and indexes when
            topological equality rather than exact equality is desired.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.Angle">
            <returns>
            The angle this segment makes with the x-axis (in radians).
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment.MidPoint">
            <summary>The midpoint of the segment</summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Distance(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Computes the distance between this line segment and another one.
            </summary>
            <param name="ls"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Distance(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the distance between this line segment and a point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.DistancePerpendicular(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the perpendicular distance between the (infinite) line defined
            by this line segment and a point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.PointAlong(System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> that lies a given
            fraction along the line defined by this segment.
            </summary>
            <remarks>
            A fraction of <c>0.0</c> returns the start point of the segment;
            A fraction of <c>1.0</c> returns the end point of the segment.
            If the fraction is &lt; 0.0 or &gt; 1.0 the point returned
            will lie before the start or beyond the end of the segment.
            </remarks>
            <param name="segmentLengthFraction"> the fraction of the segment length along the line</param>
            <returns> the point at that distance</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.PointAlongOffset(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> that lies a given
            </summary>
            <remarks>
            A fraction along the line defined by this segment and offset from
            the segment by a given distance.
            A fraction of <c>0.0</c> offsets from the start point of the segment;
            A fraction of <c>1.0</c> offsets from the end point of the segment.
            The computed point is offset to the left of the line if the offset distance is
            positive, to the right if negative.
            </remarks>
            <param name="segmentLengthFraction"> the fraction of the segment length along the line</param>
            <param name="offsetDistance"> the distance the point is offset from the segment</param>
            (positive is to the left, negative is to the right)
            <returns> the point at that distance and offset</returns>
            <exception cref="T:System.ApplicationException"> if the segment has zero length</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.ProjectionFactor(NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the Projection Factor for the projection of the point p
            onto this LineSegment.  The Projection Factor is the constant r
            by which the vector for this segment must be multiplied to
            equal the vector for the projection of <tt>p</tt> on the line
            defined by this segment.
            <para/>
            The projection factor will lie in the range <tt>(-inf, +inf)</tt>,
            or be <c>NaN</c> if the line segment has zero length.
            </summary>
            <param name="p">The point to compute the factor for</param>
            <returns>The projection factor for the point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.SegmentFraction(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the fraction of distance (in [0.0, 1.0])
            that the projection of a point occurs along this line segment.
            If the point is beyond either ends of the line segment,
            the closest fractional value (0.0 or 1.0) is returned.
            </summary>
            <remarks>
            Essentially, this is the <see cref="M:NetTopologySuite.Geometries.LineSegment.ProjectionFactor(NetTopologySuite.Geometries.Coordinate)" /> clamped to
            the range [0.0, 1.0].
            </remarks>
            <param name="inputPt"> the point</param>
            <returns> the fraction along the line segment the projection of the point occurs</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Project(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Compute the projection of a point onto the line determined
            by this line segment.
            Note that the projected point  may lie outside the line segment.
            If this is the case,  the projection factor will lie outside the range [0.0, 1.0].
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Project(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Project a line segment onto this line segment and return the resulting
            line segment.  The returned line segment will be a subset of
            the target line line segment.  This subset may be null, if
            the segments are oriented in such a way that there is no projection.
            Note that the returned line may have zero length (i.e. the same endpoints).
            This can happen for instance if the lines are perpendicular to one another.
            </summary>
            <param name="seg">The line segment to project.</param>
            <returns>The projected line segment, or <c>null</c> if there is no overlap.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Offset(System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.LineSegment"/> that is offset from
            the segment by a given distance.
            The computed segment is offset to the left of the line if the offset distance is
            positive, to the right if negative.
            </summary>
            <param name="offsetDistance">The distance the point is offset from the segment
            (positive is to the left, negative is to the right)</param>
            <returns>A line segment offset by the specified distance</returns>
            <exception cref="T:System.ApplicationException">Thrown if the segment has zero length</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.ClosestPoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the closest point on this line segment to another point.
            </summary>
            <param name="p">The point to find the closest point to.</param>
            <returns>
            A Coordinate which is the closest point on the line segment to the point p.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.ClosestPoints(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Computes the closest points on a line segment.
            </summary>
            <param name="line"></param>
            <returns>
            A pair of Coordinates which are the closest points on the line segments.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Reflect(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the reflection of a point in the line defined
            by this line segment.
            </summary>
            <param name="p">The point to reflect</param>
            <returns>The reflected point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Intersection(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Computes an intersection point between two segments, if there is one.
            There may be 0, 1 or many intersection points between two segments.
            If there are 0, null is returned. If there is 1 or more, a single one
            is returned (chosen at the discretion of the algorithm).  If
            more information is required about the details of the intersection,
            the <see cref="T:NetTopologySuite.Algorithm.RobustLineIntersector"/> class should be used.
            </summary>
            <param name="line">A line segment</param>
            <returns> An intersection point, or <c>null</c> if there is none.</returns>
            <see cref="T:NetTopologySuite.Algorithm.RobustLineIntersector"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.LineIntersection(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Computes the intersection point of the lines defined by two segments, if there is one.
            </summary>
            <remarks>
            There may be 0, 1 or an infinite number of intersection points between two lines.
            If there is a unique intersection point, it is returned.
            Otherwise, <c>null</c> is returned.
            If more information is required about the details of the intersection,
            the <see cref="T:NetTopologySuite.Algorithm.RobustLineIntersector"/> class should be used.
            </remarks>
            <param name="line">A line segment defining a straight line</param>
            <returns>An intersection point, or <c>null</c> if there is none or an infinite number</returns>
            <seealso cref="T:NetTopologySuite.Algorithm.RobustLineIntersector"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.ToGeometry(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a LineString with the same coordinates as this segment
            </summary>
            <param name="geomFactory">the geometry factory to use</param>
            <returns>A LineString with the same geometry as this segment</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <c>o</c> has the same values for its points.
            </summary>
            <param name="o">A <c>LineSegment</c> with which to do the comparison.</param>
            <returns>
            <c>true</c> if <c>o</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.op_Equality(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.op_Inequality(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.CompareTo(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Compares this object with the specified object for order.
            Uses the standard lexicographic ordering for the points in the LineSegment.
            </summary>
            <param name="other">
            The <c>LineSegment</c> with which this <c>LineSegment</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineSegment</c>
            is less than, equal to, or greater than the specified <c>LineSegment</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.EqualsTopologically(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Returns <c>true</c> if <c>other</c> is
            topologically equal to this LineSegment (e.g. irrespective
            of orientation).
            </summary>
            <param name="other">
            A <c>LineSegment</c> with which to do the comparison.
            </param>
            <returns>
            <c>true</c> if <c>other</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.ToString">
             <summary>
            
             </summary>
             <returns></returns>
            
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.LineString">
            <summary>
            Models an OGC-style <c>LineString</c>
            </summary>
            <remarks>
            A LineString consists of a sequence of two or more vertices,
            along with all points along the linearly-interpolated curves
            (line segments) between each
            pair of consecutive vertices.
            Consecutive vertices may be equal.
            The line segments in the line may intersect each other (in other words,
            the <c>LineString</c> may "curl back" in itself and self-intersect.
            <c>LineString</c>s with exactly two identical points are invalid.
            <para>A <c>LineString</c> must have either 0 or <see cref="F:NetTopologySuite.Geometries.LineString.MinimumValidSize"/> or more points.
            If these conditions are not met, the constructors throw an <see cref="T:System.ArgumentException"/>.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.LineString.MinimumValidSize">
            <summary>
            The minimum number of vertices allowed in a valid non-empty linestring.
            Empty linestrings with 0 vertices are also valid.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LineString.Empty">
            <summary>
            Represents an empty <c>LineString</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.LineString._points">
            <summary>
            The points of this <c>LineString</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.LineString"/> class.
            </summary>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
            <param name="points">The coordinates used for create this <see cref="T:NetTopologySuite.Geometries.LineString" />.</param>
            <exception cref="T:System.ArgumentException">If too few points are provided</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.#ctor(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.LineString"/> class.
            </summary>
            <param name="points">
            The points of the <c>LineString</c>, or <c>null</c>
            to create the empty point. Consecutive points may not be equal.
            </param>
            <param name="factory"></param>
            <exception cref="T:System.ArgumentException">If too few points are provided</exception>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Coordinates">
            <summary>
            Returns an array containing the values of all the vertices for
            this geometry.
            </summary>
            <remarks>
            If the geometry is a composite, the array will contain all the vertices
            for the components, in the order in which the components occur in the geometry.
            <para>
            In general, the array cannot be assumed to be the actual internal
            storage for the vertices.  Thus modifying the array
            may not modify the geometry itself.
            Use the <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/> method
            (possibly on the components) to modify the underlying data.
            If the coordinates are modified,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> must be called afterwards.
            </para>
            </remarks>
            <returns>The vertices of this <c>Geometry</c>.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate,System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.GetOrdinates(NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Gets an array of <see cref="T:System.Double"/> ordinate values
            </summary>
            <param name="ordinate">The ordinate index</param>
            <returns>An array of ordinate values</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.CoordinateSequence">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.GetCoordinateN(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.IsEmpty">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.GetPointN(System.Int32)">
            <summary>
            Gets 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.StartPoint">
            <summary>
            Gets a value indicating the start point of this <c>LINESTRING</c>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.EndPoint">
            <summary>
            Gets a value indicating the end point of this <c>LINESTRING</c>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.IsClosed">
            <summary>
            Gets a value indicating if this <c>LINESTRING</c> is closed.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.IsRing">
            <summary>
            Gets a value indicating if this <c>LINESTRING</c> forms a ring.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"LineString"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.OgcGeometryType">
            <summary>
            Gets the OGC geometry type
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Length">
            <summary>
            Returns the length of this <c>LineString</c>
            </summary>
            <returns>The length of the polygon.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Boundary">
            <summary>
            Returns the boundary, or an empty geometry of appropriate dimension
            if this <c>Geometry</c> is empty.
            For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Reverse">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.LineString" /> whose coordinates are in the reverse order of this objects.
            </summary>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LineString" /> with coordinates in the reverse order.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function for <c>LINESTRING</c>s.
            </summary>
            <returns>A reversed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.IsCoordinate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns true if the given point is a vertex of this <c>LineString</c>.
            </summary>
            <param name="pt">The <c>Coordinate</c> to check.</param>
            <returns><c>true</c> if <c>pt</c> is one of this <c>LineString</c>'s vertices.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Apply(NetTopologySuite.Geometries.ICoordinateFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)">
            <summary>
            Performs an operation on the coordinates in this <c>Geometry</c>'s <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s.
            </summary>
            <remarks>
            If the filter reports that a coordinate value has been changed,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> will be called automatically.
            </remarks>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Apply(NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Apply(NetTopologySuite.Geometries.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.Normalize">
            <summary>
            Normalizes a <c>LineString</c>.  A normalized <c>LineString</c>
            has the first point which is not equal to it's reflected point
            less than the reflected point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.IsEquivalentClass(NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.IsEquivalentClass(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.CompareToSameClass(System.Object)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Item(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString.Count">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="T:NetTopologySuite.Geometries.Location">
            <summary>
            The location of a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> relative to a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Location.Interior">
            <summary>
            DE-9IM row index of the interior of the first point and column index of
            the interior of the second point. Location value for the interior of a
            point.
            </summary>
            <remarks>int value = 0;</remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Location.Boundary">
            <summary>
            DE-9IM row index of the boundary of the first point and column index of
            the boundary of the second point. Location value for the boundary of a
            point.
            </summary>
            <remarks>int value = 1;</remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Location.Exterior">
            <summary>
            DE-9IM row index of the exterior of the first point and column index of
            the exterior of the second point. Location value for the exterior of a
            point.
            </summary>
            <remarks>int value = 2;</remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Location.Null">
            <summary>
            Used for uninitialized location values.
            </summary>
            <remarks>int value = 1;</remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.LocationUtility">
            <summary>
            Utility class for <see cref="T:NetTopologySuite.Geometries.Location"/> enumeration
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LocationUtility.ToLocationSymbol(NetTopologySuite.Geometries.Location)">
            <summary>
            Converts the location value to a location symbol, for example, <c>EXTERIOR => 'e'</c>.
            </summary>
            <param name="locationValue"></param>
            <returns>Either 'e', 'b', 'i' or '-'.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiLineString">
            <summary>
            Models a collection of <see cref="T:NetTopologySuite.Geometries.LineString"/>s.
            <para/>
            Any collection of <c>LineString</c>s is a valid <c>MultiLineString</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.MultiLineString.Empty">
            <summary>
            Represents an empty <c>MultiLineString</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.#ctor(NetTopologySuite.Geometries.LineString[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.#ctor(NetTopologySuite.Geometries.LineString[])">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.Dimension">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.BoundaryDimension">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"MultiLineString"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.OgcGeometryType">
            <summary>
            Gets the OGC geometry type
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString.IsClosed">
            <summary>
            Gets a value indicating whether this instance is closed.
            </summary>
            <value><c>true</c> if this instance is closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.Reverse">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiLineString" /> in the reverse order to this object.
            Both the order of the component LineStrings
            and the order of their coordinate sequences are reversed.
            </summary>
            <returns>a <see cref="T:NetTopologySuite.Geometries.MultiLineString" /> in the reverse order.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.ReverseInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.MultiLineString.ReverseInternal"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiPoint">
            <summary>
            Models a collection of <c>Point</c>s.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.MultiPoint.Empty">
            <summary>
            Represents an empty <c>MultiPoint</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.#ctor(NetTopologySuite.Geometries.Point[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>MultiPoint</c>.
            </summary>
            <param name="points">
            The <c>Point</c>s for this <c>MultiPoint</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Point</c>s, but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.#ctor(NetTopologySuite.Geometries.Point[])">
            <summary>
            Constructs a <c>MultiPoint</c>.
            </summary>
            <param name="points">
            The <c>Point</c>s for this <c>MultiPoint</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Point</c>s, but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"MultiPoint"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.Boundary">
            <summary>
            Gets the boundary of this geometry.
            Zero-dimensional geometries have no boundary by definition,
            so an empty GeometryCollection is returned.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.ReverseInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.MultiPoint.ReverseInternal"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint.IsValid">
            <inheritdoc cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint.GetCoordinate(System.Int32)">
            <summary>
            Returns the <c>Coordinate</c> at the given position.
            </summary>
            <param name="n">The index of the <c>Coordinate</c> to retrieve, beginning at 0.
            </param>
            <returns>The <c>n</c>th <c>Coordinate</c>.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiPolygon">
            <summary>
            Basic implementation of <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.MultiPolygon.Empty">
            <summary>
            Represents an empty <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.#ctor(NetTopologySuite.Geometries.Polygon[])">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Polygon</c>s, but not <c>null</c>
            s. The polygons must conform to the assertions specified in the
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.#ctor(NetTopologySuite.Geometries.Polygon[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Polygon</c>s, but not <c>null</c>
            s. The polygons must conform to the assertions specified in the
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"MultiPolygon"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.OgcGeometryType">
            <inheritdoc cref="P:NetTopologySuite.Geometries.Geometry.OgcGeometryType"/>>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPolygon.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.Reverse">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> with every component reversed.
            </summary>
            <remarks>The order of the components in the collection are not reversed.</remarks>
            <returns>An <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> in the reverse order</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon.ReverseInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.MultiPolygon.ReverseInternal"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.OctagonalEnvelope">
            <summary>
            A bounding container for a <see cref="T:NetTopologySuite.Geometries.Geometry"/> which is in the shape of a general octagon.
            </summary>
            <remarks>
            The OctagonalEnvelope of a geometric object
            is a geometry which is tight bound along the (up to) four extremal rectilinear parallels
            and along the (up to) four extremal diagonal parallels.
            Depending on the shape of the contained
            geometry, the octagon may be degenerate to any extreme
            (e.g. it may be a rectangle, a line, or a point).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.GetOctagonalEnvelope(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the octagonal envelope of a geometry
            </summary>
            <param name="geom">The geometry</param>
            <returns>The octagonal envelope of the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor">
            <summary>
            Creates a new null bounding octagon
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new null bounding octagon bounding a <see cref="T:NetTopologySuite.Geometries.Coordinate" />
            </summary>
            <param name="p">The coordinate to bound</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new null bounding octagon bounding a pair of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s
            </summary>
            <param name="p0">A coordinate to bound</param>
            <param name="p1">A coordinate to bound</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates a new null bounding octagon bounding an <see cref="T:NetTopologySuite.Geometries.Envelope" />
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor(NetTopologySuite.Geometries.OctagonalEnvelope)">
            <summary>
            Creates a new null bounding octagon bounding an <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope" />
            (the copy constructor).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new null bounding octagon bounding a <see cref="T:NetTopologySuite.Geometries.Geometry" />
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MinX">
            <summary>
            Gets a value indicating the minimal x-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MaxX">
            <summary>
            Gets a value indicating the maximal x-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MinY">
            <summary>
            Gets a value indicating the minimal y-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MaxY">
            <summary>
            Gets a value indicating the maximal y-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MinA">
            <summary>
            Gets a value indicating the minimal <c>a</c> value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MaxA">
            <summary>
            Gets a value indicating the maximal <c>a</c> value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MinB">
            <summary>
            Gets a value indicating the minimal <c>b</c> value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.MaxB">
            <summary>
            Gets a value indicating the maximal <c>b</c> value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.IsNull">
            <summary>
            Gets a value indicating that this object is null
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Method to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="g"/> geometry.
            </summary>
            <param name="g">The geometry</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Method to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="seq"/> coordinate sequence.
            </summary>
            <param name="seq">The coordinate sequence</param>
            <returns>A reference to <c>this</c> octagonal envelope, expanded by <paramref name="seq"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(NetTopologySuite.Geometries.OctagonalEnvelope)">
            <summary>
            Method to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="oct"/> OctogonalEnvelope.
            </summary>
            <param name="oct">The OctogonalEnvelope</param>
            <returns>A reference to <c>this</c> octagonal envelope, expanded by <paramref name="oct"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Function to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="p"/> coordinate.
            </summary>
            <param name="p">The coordinate</param>
            <returns>A reference to <c>this</c> octagonal envelope, expanded by <paramref name="p"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Function to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="env"/> envelope.
            </summary>
            <param name="env">The envelope</param>
            <returns>A reference to <c>this</c> octagonal envelope, expanded by <paramref name="env"/></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ExpandToInclude(System.Double,System.Double)">
            <summary>
            Function to expand this <see cref="T:NetTopologySuite.Geometries.OctagonalEnvelope"/> to include the provided <paramref name="x"/>- and <paramref name="y"/> ordinates.
            </summary>
            <param name="x">A x-ordinate value</param>
            <param name="y">A y-ordinate value</param>
            <returns>A reference to <c>this</c> octagonal envelope, expanded by <paramref name="x"/> and <paramref name="y"/></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.OctagonalEnvelope.IsValid">
            <summary>
            Gets a value indicating if the extremal values for this octagon are valid.
            </summary>
            <returns><c>true</c> if this object has valid values</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.Intersects(NetTopologySuite.Geometries.OctagonalEnvelope)">
            <summary>
            Function to test if <c>this</c> octagonal envelope intersects <paramref name="other"/> octagonal envelope .
            </summary>
            <param name="other">An octagonal envelope </param>
            <returns><c>true</c> if <c>this</c> octagonal envelope intersects <paramref name="other"/> octagonal envelope .</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.Intersects(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Function to test if <c>this</c> octagonal envelope contains <paramref name="p"/> coordinate.
            </summary>
            <param name="p">A coordinate</param>
            <returns><c>true</c> if <c>this</c> octagonal envelope contains <paramref name="p"/> coordinate.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.Contains(NetTopologySuite.Geometries.OctagonalEnvelope)">
            <summary>
            Function to test if <c>this</c> octagonal envelope contains <paramref name="other"/> octagonal envelope.
            </summary>
            <param name="other">An octagonal envelope</param>
            <returns><c>true</c> if <c>this</c> octagonal envelope contains <paramref name="other"/> octagonal envelope.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OctagonalEnvelope.ToGeometry(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Function to convert <c>this</c> octagonal envelope into a geometry
            </summary>
            <param name="geomFactory">The factory to create the geometry</param>
            <returns>A geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.OgcCompliantGeometryFactory">
            <summary>
            OGC compliant geometry factory
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.#ctor">
            <summary>
            Creates an instance of this class using the default
            values for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/>,
            <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel"/> and
            <see cref="P:NetTopologySuite.Geometries.GeometryFactory.CoordinateSequenceFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Creates an instance of this class using the default
            values for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/>,
            <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel"/>,
            but the specified <paramref name="factory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            Creates an instance of this class using the default
            values for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/>,
            <see cref="P:NetTopologySuite.Geometries.GeometryFactory.CoordinateSequenceFactory"/> but the
            specified <paramref name="pm"/>.
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.ToGeometry(NetTopologySuite.Geometries.Envelope)">
            <inheritdoc/>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.CreatePolygon(NetTopologySuite.Geometries.Coordinate[])">
            <inheritdoc/>
            <remarks>
            The <see cref="P:NetTopologySuite.Geometries.Polygon.ExteriorRing"/> is guaranteed to be orientated counter-clockwise.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.CreatePolygon(NetTopologySuite.Geometries.CoordinateSequence)">
            <inheritdoc/>
            <remarks>
            The <see cref="P:NetTopologySuite.Geometries.Polygon.ExteriorRing"/> is guaranteed to be orientated counter-clockwise.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing)">
            <inheritdoc/>
            <remarks>
            The <see cref="P:NetTopologySuite.Geometries.Polygon.ExteriorRing"/> is guaranteed to be orientated counter-clockwise.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.OgcCompliantGeometryFactory.CreatePolygon(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[])">
            <inheritdoc/>
            <remarks>
            The <see cref="P:NetTopologySuite.Geometries.Polygon.ExteriorRing"/> is guaranteed to be orientated counter-clockwise.
            <br/>The <see cref="P:NetTopologySuite.Geometries.Polygon.InteriorRings"/> are guaranteed to be orientated clockwise.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.OgcGeometryType">
            <summary>
            Enumeration of OGC Geometry Types
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.Point">
            <summary>
            Point.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.LineString">
            <summary>
            LineString.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.Polygon">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.MultiPoint">
            <summary>
            MultiPoint.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.MultiLineString">
            <summary>
            MultiLineString.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.MultiPolygon">
            <summary>
            MultiPolygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.GeometryCollection">
            <summary>
            GeometryCollection.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.CircularString">
            <summary>
            CircularString
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.CompoundCurve">
            <summary>
            CompoundCurve
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.CurvePolygon">
            <summary>
            CurvePolygon
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.MultiCurve">
            <summary>
            MultiCurve
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.MultiSurface">
            <summary>
            MultiSurface
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.Curve">
            <summary>
            Curve
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.Surface">
            <summary>
            Surface
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.PolyhedralSurface">
            <summary>
            PolyhedralSurface
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.OgcGeometryType.TIN">
            <summary>
            TIN
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Ordinate">
            <summary>
            Identifies the different well-supported components of coordinate values.
            <para>
            All supported coordinates define values for at least the X and the Y components.
            </para>
            <para>
            The first 16 spatial and 16 measure dimensions may also be accessed this way.
            </para>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial1">
            <summary>
            The 1st spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.X">
            <summary>
            The "X" ordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial2">
            <summary>
            The 2nd spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Y">
            <summary>
            The "Y" ordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial3">
            <summary>
            The 3rd spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Z">
            <summary>
            The "Z" ordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial4">
            <summary>
            The 4th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial5">
            <summary>
            The 5th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial6">
            <summary>
            The 6th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial7">
            <summary>
            The 7th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial8">
            <summary>
            The 8th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial9">
            <summary>
            The 9th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial10">
            <summary>
            The 10th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial11">
            <summary>
            The 11th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial12">
            <summary>
            The 12th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial13">
            <summary>
            The 13th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial14">
            <summary>
            The 14th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial15">
            <summary>
            The 15th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Spatial16">
            <summary>
            The 16th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure1">
            <summary>
            The 1st measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.M">
            <summary>
            The "M" ordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure2">
            <summary>
            The 2nd measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure3">
            <summary>
            The 3rd measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure4">
            <summary>
            The 4th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure5">
            <summary>
            The 5th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure6">
            <summary>
            The 6th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure7">
            <summary>
            The 7th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure8">
            <summary>
            The 8th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure9">
            <summary>
            The 9th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure10">
            <summary>
            The 10th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure11">
            <summary>
            The 11th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure12">
            <summary>
            The 12th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure13">
            <summary>
            The 13th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure14">
            <summary>
            The 14th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure15">
            <summary>
            The 15th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinate.Measure16">
            <summary>
            The 16th measure dimension.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Ordinates">
            <summary>
            Flags for Ordinate values
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.None">
            <summary>
            No ordinates
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.X">
            <summary>
            Flag for the x-ordinate 
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Y">
            <summary>
            Flag for the y-ordinate 
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Z">
            <summary>
            Flag for the z-ordinate 
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.M">
            <summary>
            Flag for the m-ordinate 
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.XY">
            <summary>
            Flag for both x- and y-ordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.XYZ">
            <summary>
            Flag for x-, y- and z-ordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.XYM">
            <summary>
            Flag for x-, y- and m-ordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.XYZM">
            <summary>
            Flag for x-, y-, z- and m-ordinate
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial1">
            <summary>
            Flag for the 1st spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial2">
            <summary>
            Flag for the 2nd spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial3">
            <summary>
            Flag for the 3rd spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial4">
            <summary>
            Flag for the 4th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial5">
            <summary>
            Flag for the 5th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial6">
            <summary>
            Flag for the 6th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial7">
            <summary>
            Flag for the 7th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial8">
            <summary>
            Flag for the 8th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial9">
            <summary>
            Flag for the 9th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial10">
            <summary>
            Flag for the 10th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial11">
            <summary>
            Flag for the 11th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial12">
            <summary>
            Flag for the 12th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial13">
            <summary>
            Flag for the 13th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial14">
            <summary>
            Flag for the 14th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial15">
            <summary>
            Flag for the 15th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Spatial16">
            <summary>
            Flag for the 16th spatial dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.AllSpatialOrdinates">
            <summary>
            Flags for all spatial ordinates.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure1">
            <summary>
            Flag for the 1st measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure2">
            <summary>
            Flag for the 2nd measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure3">
            <summary>
            Flag for the 3rd measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure4">
            <summary>
            Flag for the 4th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure5">
            <summary>
            Flag for the 5th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure6">
            <summary>
            Flag for the 6th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure7">
            <summary>
            Flag for the 7th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure8">
            <summary>
            Flag for the 8th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure9">
            <summary>
            Flag for the 9th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure10">
            <summary>
            Flag for the 10th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure11">
            <summary>
            Flag for the 11th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure12">
            <summary>
            Flag for the 12th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure13">
            <summary>
            Flag for the 13th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure14">
            <summary>
            Flag for the 14th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure15">
            <summary>
            Flag for the 15th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.Measure16">
            <summary>
            Flag for the 16th measure dimension.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.AllMeasureOrdinates">
            <summary>
            Flags for all non-spatial ordinates.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Ordinates.AllOrdinates">
            <summary>
            Flags for all recognized ordinates.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.OrdinatesUtility">
            <summary>
            Static utility functions for dealing with <see cref="T:NetTopologySuite.Geometries.Ordinates"/> and dimension
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.OrdinatesUtility.OrdinatesToDimension(NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Translates the <paramref name="ordinates"/>-flag to a number of dimensions.
            </summary>
            <param name="ordinates">The ordinates flag</param>
            <returns>The number of dimensions</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.OrdinatesUtility.OrdinatesToMeasures(NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Translates the <paramref name="ordinates"/>-flag to a number of measures.
            </summary>
            <param name="ordinates">The ordinates flag</param>
            <returns>The number of measures</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Point">
             <summary>
             Represents a single point.
             <para/>
             A <c>Point</c> is topologically valid if and only if:
             <list type="bullet">
             <item><description>The coordinate which defines it if any) is a valid coordinate
             (i.e. does not have an <c>NaN</c> X- or Y-ordinate</description></item>
             </list>
             </summary>
            
        </member>
        <member name="F:NetTopologySuite.Geometries.Point.Empty">
            <summary>
            Represents an empty <c>Point</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Point._coordinates">
            <summary>
            The <c>Coordinate</c> wrapped by this <c>Point</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.CoordinateSequence">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Point"/> class.
            </summary>
            <param name="coordinate">The coordinate used for create this <see cref="T:NetTopologySuite.Geometries.Point" />.</param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.#ctor(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>Point</c> with the given coordinate.
            </summary>
            <param name="coordinates">
            Contains the single coordinate on which to base this <c>Point</c>,
            or <c>null</c> to create the empty point.
            </param>
            <param name="factory"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.IsEmpty">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.X">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Y">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"Point"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.OgcGeometryType">
            <summary>
            Gets the OGC geometry type
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Boundary">
             <summary>
            Gets the boundary of this geometry.
            Zero-dimensional geometries have no boundary by definition,
            so an empty GeometryCollection is returned.
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Apply(NetTopologySuite.Geometries.ICoordinateFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Apply(NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Apply(NetTopologySuite.Geometries.IGeometryFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Reverse">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function for <c>POINT</c>s.
            </summary>
            <returns>A reversed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.Normalize">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Point.Normalize"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.CompareToSameClass(System.Object)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="comparer"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Point"/> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="z">The z coordinate.</param>
            /// <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> set to </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Point"/> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            /// <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> set to </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Point.Z">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Polygon">
            <summary>
            Represents a polygon with linear edges, which may include holes.
            The outer boundary (shell)
            and inner boundaries (holes) of the polygon are represented by {@link LinearRing}s.
            The boundary rings of the polygon may have any orientation.
            Polygons are closed, simple geometries by definition.
            <para/>
            The polygon model conforms to the assertions specified in the
            <a href="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
            Specification for SQL</a>.
            <para/>
            A <c>Polygon</c> is topologically valid if and only if:
            <list type="bullet">
            <item><description>the coordinates which define it are valid coordinates</description></item>
            <item><description>the linear rings for the shell and holes are valid
            (i.e. are closed and do not self-intersect)</description></item>
            <item><description>holes touch the shell or another hole at at most one point
            (which implies that the rings of the shell and holes must not cross)</description></item>
            <item><description>the interior of the polygon is connected,
            or equivalently no sequence of touching holes
            makes the interior of the polygon disconnected
            (i.e. effectively split the polygon into two pieces).</description></item>
            </list>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Polygon.Empty">
            <summary>
            Represents an empty <c>Polygon</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Polygon._shell">
            <summary>
            The exterior boundary, or <c>null</c> if this <c>Polygon</c>
            is the empty point.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Polygon._holes">
            <summary>
            The interior boundaries, if any.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.#ctor(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Polygon"/> class.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
            point is to be created.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            with <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> <c> == </c> <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.#ctor(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.LinearRing[],NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
            point is to be created.
            </param>
            <param name="factory"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.SortIndex">
            <summary>
            Gets a value to sort the geometry
            </summary>
            <remarks>
            NOTE:<br/>
            For JTS v1.17 this property's getter has been renamed to <c>getTypeCode()</c>.
            In order not to break binary compatibility we did not follow.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Coordinate">
            <summary>
            Returns a vertex of this <c>Geometry</c>
            (usually, but not necessarily, the first one).
            </summary>
            <remarks>
            The returned coordinate should not be assumed to be an actual Coordinate object used in the internal representation.
            </remarks>
            <returns>a Coordinate which is a vertex of this <c>Geometry</c>.</returns>
            <returns><c>null</c> if this Geometry is empty.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Coordinates">
            <summary>
            Returns an array containing the values of all the vertices for
            this geometry.
            </summary>
            <remarks>
            If the geometry is a composite, the array will contain all the vertices
            for the components, in the order in which the components occur in the geometry.
            <para>
            In general, the array cannot be assumed to be the actual internal
            storage for the vertices.  Thus modifying the array
            may not modify the geometry itself.
            Use the <see cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/> method
            (possibly on the components) to modify the underlying data.
            If the coordinates are modified,
            <see cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/> must be called afterwards.
            </para>
            </remarks>
            <returns>The vertices of this <c>Geometry</c>.</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Geometry.GeometryChanged"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,System.Int32,System.Double)"/>
            <seealso cref="M:NetTopologySuite.Geometries.CoordinateSequence.SetOrdinate(System.Int32,NetTopologySuite.Geometries.Ordinate,System.Double)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.GetOrdinates(NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Gets an array of <see cref="T:System.Double"/> ordinate values
            </summary>
            <param name="ordinate">The ordinate index</param>
            <returns>An array of ordinate values</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.NumPoints">
            <summary>
            Returns the count of this <c>Geometry</c>s vertices. The <c>Geometry</c>
            s contained by composite <c>Geometry</c>s must be
            Geometry's; that is, they must implement <c>NumPoints</c>.
            </summary>
            <returns>The number of vertices in this <c>Geometry</c>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Dimension">
            <summary>
            Returns the dimension of this geometry.
            </summary>
            <remarks>
            The dimension of a geometry is is the topological
            dimension of its embedding in the 2-D Euclidean plane.
            In the NTS spatial model, dimension values are in the set {0,1,2}.
            <para>
            Note that this is a different concept to the dimension of
            the vertex <see cref="P:NetTopologySuite.Geometries.Polygon.Coordinate"/>s.
            The geometry dimension can never be greater than the coordinate dimension.
            For example, a 0-dimensional geometry (e.g. a Point)
            may have a coordinate dimension of 3 (X,Y,Z).
            </para>
            </remarks>
            <returns>
            The topological dimensions of this geometry
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.BoundaryDimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
            NOTE: make abstract and remove setter
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.IsEmpty">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.ExteriorRing">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.NumInteriorRings">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.InteriorRings">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.GetInteriorRingN(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.GeometryType">
            <summary>
            Returns the name of this object's interface.
            </summary>
            <returns>"Polygon"</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.OgcGeometryType">
            <inheritdoc cref="P:NetTopologySuite.Geometries.Geometry.OgcGeometryType"/>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Area">
            <summary>
            Returns the area of this <c>Polygon</c>
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Length">
            <summary>
            Returns the perimeter of this <c>Polygon</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.EqualsExact(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Apply(NetTopologySuite.Geometries.ICoordinateFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.ICoordinateSequenceFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Apply(NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter)">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Apply(NetTopologySuite.Geometries.IGeometryFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.IGeometryFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Apply(NetTopologySuite.Geometries.IGeometryComponentFilter)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.CopyInternal">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.CopyInternal"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.ConvexHull">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Normalize">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.CompareToSameClass(System.Object)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.CompareToSameClass(System.Object,System.Collections.Generic.IComparer{NetTopologySuite.Geometries.CoordinateSequence})">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="comparer"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.IsRectangle">
            <summary>
            Tests whether this is a rectangular <see cref="T:NetTopologySuite.Geometries.Polygon"/>.
            </summary>
            <returns><c>true</c> if the geometry is a rectangle.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.Reverse">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.ReverseInternal">
            <summary>
            The actual implementation of the <see cref="M:NetTopologySuite.Geometries.Geometry.Reverse"/> function for <c>POLYGON</c>s
            </summary>
            <returns>A reversed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.#ctor(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon.#ctor(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Shell">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon.Holes">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Position">
            <summary>
            Indicates the position of a location relative to a
            node or edge component of a planar topological structure.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Position.On">
            <summary>
            Specifies that a location is <c>on</c> a component
            </summary>
            <value>0</value>
        </member>
        <member name="F:NetTopologySuite.Geometries.Position.Left">
            <summary>
            Specifies that a location is to the <c>left</c> of a component
            </summary>
            <value>1</value>
        </member>
        <member name="F:NetTopologySuite.Geometries.Position.Right">
            <summary>
            Specifies that a location is to the <c>right</c> of a component
            </summary>
            <value>2</value>
        </member>
        <member name="F:NetTopologySuite.Geometries.Position.Parallel">
            <summary>
            Specifies that a location is <c>is parallel to x-axis</c> of a component
            </summary>
            <value>-1</value>
        </member>
        <member name="M:NetTopologySuite.Geometries.Position.#ctor(System.Int32)">
            <summary>
            Creates a new position index
            </summary>
            <param name="index">A position index</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Position.Index">
            <summary>
            Gets a value indicating the position index
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Position.Opposite">
            <summary>
            Returns <see cref="F:NetTopologySuite.Geometries.Position.Left"/> if the position is <see cref="F:NetTopologySuite.Geometries.Position.Right"/>,
            <see cref="F:NetTopologySuite.Geometries.Position.Right"/> if the position is <see cref="F:NetTopologySuite.Geometries.Position.Left"/>, or the position
            otherwise.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Position.op_Equality(NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Position)">
            <summary>
            Equality comparer for <see cref="T:NetTopologySuite.Geometries.Position"/> indices
            </summary>
            <param name="lhs">The position index on the left-hand-side</param>
            <param name="rhs">The position index on the right-hand-side</param>
            <returns><c>true</c> if both indices are equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Position.op_Inequality(NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Position)">
            <summary>
            Inequality comparer for <see cref="T:NetTopologySuite.Geometries.Position"/> indices
            </summary>
            <param name="lhs">The position index on the left-hand-side</param>
            <param name="rhs">The position index on the right-hand-side</param>
            <returns><c>true</c> if both indices are <b>not</b> equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Position.op_Implicit(NetTopologySuite.Geometries.Position)~System.Int32">
            <summary>
            Implicit conversion operator for <see cref="T:NetTopologySuite.Geometries.Position"/> to <see cref="T:System.Int32"/> conversion.
            </summary>
            <param name="pos">The position index</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.PrecisionModel">
            <summary>
            Specifies the precision model of the <c>Coordinate</c>s in a <c>Geometry</c>.
            In other words, specifies the grid of allowable points for a <c>Geometry</c>.
            A precision model may be<b>floating</b> (<see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> or <see cref="F:NetTopologySuite.Geometries.PrecisionModels.FloatingSingle"/>),
            in which case normal floating-point value semantics apply.
            </summary>
            <remarks>
            For a <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Fixed"/> precision model the
            <see cref="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(NetTopologySuite.Geometries.Coordinate)"/> method allows rounding a
            coordinate to a "precise" value; that is, one whose precision
            is known exactly.
            <para/>
            Coordinates are assumed to be precise in geometries.
            That is, the coordinates are assumed to be rounded to the
            precision model given for the geometry.
            <para/>
            All internal operations
            assume that coordinates are rounded to the precision model.
            Constructive methods (such as bool operations) always round computed
            coordinates to the appropriate precision model.<br/>
            Three types of precision model are supported:
            <list type="table">
            <item><term>Floating</term><description>Represents full double precision floating point.
            This is the default precision model used in NTS</description></item>
            <item><term>FloatingSingle</term><description>Represents single precision floating point</description></item>
            <item><term>Fixed</term><description>Represents a model with a fixed number of decimal places.
            A Fixed Precision Model is specified by a <b>scale factor</b>.
            The scale factor specifies the size of the grid which numbers are rounded to.</description></item>
            </list>
            Input coordinates are mapped to fixed coordinates according to the following
            equations:
            <list type="bullet">
            <item><description><c>jtsPt.X = Math.Round( inputPt.X * scale, MidPointRounding.AwayFromZero ) / scale )</c></description></item>
            <item><description><c>jtsPt.Y = Math.Round( inputPt.Y * scale, MidPointRounding.AwayFromZero ) / scale )</c></description></item>
            </list>
            <para>
            For example, to specify 3 decimal places of precision, use a scale factor
            of 1000. To specify -3 decimal places of precision (i.e. rounding to
            the nearest 1000), use a scale factor of 0.001.
            </para>
            It is also supported to specify a precise <b>grid size</b>
            by providing it as a negative scale factor.
            This allows setting a precise grid size rather than using a fractional scale,
            which provides more accurate and robust rounding.
            For example, to specify rounding to the nearest 1000 use a scale factor of -1000.
            <para/>
            Coordinates are represented internally as Java double-precision values.
            .NET uses the IEEE-394 floating point standard, which
            provides 53 bits of precision. (Thus the maximum precisely representable
            <i>integer</i> is 9,007,199,254,740,992 - or almost 16 decimal digits of precision).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.MostPrecise(NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Determines which of two <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>s is the most precise
            </summary>
            <param name="pm1">A precision model</param>
            <param name="pm2">A precision model</param>
            <returns>The PrecisionModel which is most precise</returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModel.MaximumPreciseValue">
            <summary>
            The maximum precise value representable in a double. Since IEE754
            double-precision numbers allow 53 bits of mantissa, the value is equal to
            2^53 - 1.  This provides <i>almost</i> 16 decimal digits of precision.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModel._modelType">
            <summary>
            The type of PrecisionModel this represents.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModel._scale">
            <summary>
            The scale factor which determines the number of decimal places in fixed precision.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModel._gridSize">
            <summary>
            If non-zero, the precise grid size specified.
            In this case, the scale is also valid and is computed from the grid size.
            If zero, the scale is used to compute the grid size where needed.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.Floating">
            <summary>
            Gets a value indicating a precision model with double precision.
            </summary>
            <returns>A double precision model</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.FloatingSingle">
            <summary>
            Gets a value indicating a precision model with single precision.
            </summary>
            <returns>A single precision model</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.Fixed">
            <summary>
            Gets a value indicating a precision model with a scale of <c>1</c>.
            </summary>
            <returns>A fixed precision model</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.#ctor">
            <summary>
            Creates a <c>PrecisionModel</c> with a default precision
            of Floating.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.#ctor(NetTopologySuite.Geometries.PrecisionModels)">
            <summary>
            Creates a <c>PrecisionModel</c> that specifies
            an explicit precision model type.
            If the model type is Fixed the scale factor will default to 1.
            </summary>
            <param name="modelType">
            The type of the precision model.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.#ctor(System.Double)">
            <summary>
            Creates a <c>PrecisionModel</c> that specifies Fixed precision.
            Fixed-precision coordinates are represented as precise internal coordinates,
            which are rounded to the grid defined by the scale factor.
            <para/>
            The provided scale may be negative, to specify an exact grid size.
            The scale is then computed as the reciprocal.
            </summary>
            <param name="scale">
            Amount by which to multiply a coordinate, to obtain a precise coordinate.
            Must be non-zero
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Copy constructor to create a new <c>PrecisionModel</c>
            from an existing one.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.IsFloating">
            <summary>
            Tests whether the precision model supports floating point.
            </summary>
            <returns><c>true</c> if the precision model supports floating point.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.MaximumSignificantDigits">
            <summary>
            Returns the maximum number of significant digits provided by this
            precision model.
            Intended for use by routines which need to print out precise values.
            </summary>
            <returns>
            The maximum number of decimal places provided by this precision model.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.Scale">
            <summary>
            Returns the scale factor used to specify a fixed precision model.
            </summary>
            <remarks>
            The number of decimal places of precision is
            equal to the base-10 logarithm of the scale factor.
            Non-integral and negative scale factors are supported.
            Negative scale factors indicate that the places
            of precision is to the left of the decimal point.
            </remarks>
            <returns>
            The scale factor for the fixed precision model
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.GridSize">
            <summary>
            Computes the grid size for a fixed precision model.
            This is equal to the reciprocal of the scale factor.
            If the grid size has been set explicity (via a negative scale factor)
            it will be returned.
            </summary>
            <returns>The grid size at a fixed precision scale.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.PrecisionModel.PrecisionModelType">
            <summary>
            Gets the type of this PrecisionModel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(System.Double)">
            <summary>
            Rounds a numeric value to the PrecisionModel grid.
            Symmetric Arithmetic Rounding is used, to provide
            uniform rounding behaviour no matter where the number is
            on the number line.
            </summary>
            <remarks>
            This method has no effect on NaN values
            </remarks>
            <param name="val"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Rounds a Coordinate to the PrecisionModel grid.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.Equals(System.Object)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.Equals(NetTopologySuite.Geometries.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="otherPrecisionModel"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.op_Equality(NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Geometries.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.op_Inequality(NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Geometries.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.CompareTo(System.Object)">
            <summary>
            Compares this <c>PrecisionModel</c> object with the specified object for order.
            A PrecisionModel is greater than another if it provides greater precision.
            The comparison is based on the value returned by the
            {getMaximumSignificantDigits) method.
            This comparison is not strictly accurate when comparing floating precision models
            to fixed models; however, it is correct when both models are either floating or fixed.
            </summary>
            <param name="o">
            The <c>PrecisionModel</c> with which this <c>PrecisionModel</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>PrecisionModel</c>
            is less than, equal to, or greater than the specified <c>PrecisionModel</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.PrecisionModel.CompareTo(NetTopologySuite.Geometries.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.PrecisionModels">
            <summary>
            
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModels.Floating">
            <summary> 
            Floating precision corresponds to the standard 
            double-precision floating-point representation, which is
            based on the IEEE-754 standard
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModels.FloatingSingle">
            <summary>
            Floating single precision corresponds to the standard
            single-precision floating-point representation, which is
            based on the IEEE-754 standard
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.PrecisionModels.Fixed">
            <summary> 
            Fixed Precision indicates that coordinates have a fixed number of decimal places.
            The number of decimal places is determined by the log10 of the scale factor.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains">
            <summary>
            A base class containing the logic for computes the <i>contains</i>
            and <i>covers</i> spatial relationship predicates
            for a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> relative to all other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            Uses short-circuit tests and indexing to improve performance.
            </summary>
            <remarks>
            <para>
            Contains and covers are very similar, and differ only in how certain
            cases along the boundary are handled.  These cases require
            full topological evaluation to handle, so all the code in
            this class is common to both predicates.
            </para>
            <para>
            It is not possible to short-circuit in all cases, in particular
            in the case where line segments of the test geometry touches the polygon linework.
            In this case full topology must be computed.
            (However, if the test geometry consists of only points, this
            <i>can</i> be evaluated in an optimized fashion.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.RequireSomePointInInterior">
            <summary>
            This flag controls a difference between contains and covers.
            For contains the value is true.
            For covers the value is false.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">The PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.Eval(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Evaluate the <i>contains</i> or <i>covers</i> relationship
            for the given geometry.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry is contained</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.EvalPoints(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Evaluation optimized for Point geometries.
            This provides about a 2x performance increase, and less memory usage.
            </summary>
            <param name="geom">A Point or MultiPoint geometry</param>
            <returns>The value of the predicate being evaluated</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.IsSingleShell(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether a geometry consists of a single polygon with no holes.
            </summary>
            <returns>True if the geometry is a single polygon with no holes</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains.FullTopologicalPredicate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the full topological predicate.
            Used when short-circuit tests are not conclusive.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if this prepared polygon has the relationship with the test geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry">
            <summary>
            A base class for <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry"/> subclasses.
            </summary>
            <remarks>
            <para>Contains default implementations for methods, which simply delegate to the equivalent <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> methods.</para>
            <para>This class may be used as a "no-op" class for Geometry types which do not have a corresponding <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry"/> implementation.</para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.RepresentativePoints">
            <summary>
            Gets the list of representative points for this geometry.
            One vertex is included for every component of the geometry
            (i.e. including one for every ring of polygonal geometries).
            <para/>
            Do not modify the returned list!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.IsAnyTargetComponentInTest(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any representative of the target geometry intersects the test geometry.
            This is useful in A/A, A/L, A/P, L/P, and P/P cases.
            </summary>
            <param name="testGeom">The test geometry</param>
            <returns>true if any component intersects the areal test geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.EnvelopesIntersect(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines whether a Geometry g interacts with this geometry by testing the geometry envelopes.
            </summary>
            <param name="g">A geometry</param>
            <returns>true if the envelopes intersect</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.EnvelopeCovers(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines whether the envelope of this geometry covers the Geometry g.
            </summary>
            <param name="g">A geometry</param>
            <returns>true if g is contained in this envelope</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Contains(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> contains a given geometry.
            </summary>
            <param name="g">The Geometry to test</param>
            <returns>true if this Geometry contains the given Geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.ContainsProperly(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> properly contains a given geometry.
            <para/>
            The <c>ContainsProperly</c> predicate has the following equivalent definitions:
            <list>
            <item><description>Every point of the other geometry is a point of this geometry's interior.</description></item>
            <item><description>The DE-9IM Intersection Matrix for the two geometries matches <c>>[T**FF*FF*]</c></description></item>
            </list>
            In other words, if the test geometry has any interaction with the boundary of the target
            geometry the result of <c>ContainsProperly</c> is <c>false</c>.
            This is different semantics to the <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/> predicate,
            in which test geometries can intersect the target's boundary and still be contained.
            <para/>
            The advantage of using this predicate is that it can be computed
            efficiently, since it avoids the need to compute the full topological relationship
            of the input boundaries in cases where they intersect.
            <para/>
            An example use case is computing the intersections
            of a set of geometries with a large polygonal geometry.
            Since <i>intersection</i> is a fairly slow operation, it can be more efficient
            to use <see cref="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.ContainsProperly(NetTopologySuite.Geometries.Geometry)" /> to filter out test geometries which lie
            wholly inside the area.  In these cases the intersection is
            known <c>a priori</c> to be simply the original test geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry properly contains the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.ContainsProperly(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
            <seealso cref="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Contains(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.CoveredBy(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> is covered by a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry is covered by the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Covers(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> covers a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry covers the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Crosses(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> crosses a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry crosses the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Crosses(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Disjoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> is disjoint from given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry is disjoint from the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Disjoint(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Standard implementation for all geometries.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> intersects a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry intersects the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Intersects(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Overlaps(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> overlaps a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry overlaps the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Overlaps(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Touches(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> touches a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry touches the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Touches(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Within(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.Geometry"/> is within a given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <returns>true if this geometry is within the given geometry</returns>
            <see cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>
            <remarks>Default implementation.</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry">
            <summary>
             An interface for classes which prepare <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/>s 
             in order to optimize the performance of repeated calls to specific geometric operations.
            </summary>
             <remarks>
             <para>
             A given implementation may provide optimized implementations 
             for only some of the specified methods, and delegate the remaining
             methods to the original <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> operations.
             </para>
             <para>
             An implementation may also only optimize certain situations, and delegate others.
             See the implementing classes for documentation about which methods and situations 
             they optimize.</para>
             <para>
             Subclasses are intended to be thread-safe, to allow <c>IPreparedGeometry</c>
             to be used in a multi-threaded context 
             (which allows extracting maximum benefit from the prepared state).
             </para>
             </remarks>
             <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry">
            <summary>
             Gets the original <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> which has been prepared.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Contains(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> contains a given geometry.
            </summary>
             <param name="geom">The Geometry to test</param>
             <returns>true if this Geometry contains the given Geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Contains(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.ContainsProperly(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> contains a given geometry.
            </summary>
             <remarks>
             <para>
             The <c>ContainsProperly</c> predicate has the following equivalent definitions:
             <list type="bullet">
             <item><description>Every point of the other geometry is a point of this geometry's interior.</description></item>
             <item><description>The DE-9IM Intersection Matrix for the two geometries matches <c>>[T**FF*FF*]</c></description></item>
             </list>
             The advantage to using this predicate is that it can be computed
             efficiently, with no need to compute topology at individual points.
             </para>
             <para>
             An example use case for this predicate is computing the intersections
             of a set of geometries with a large polygonal geometry.  
             Since <tt>intersection</tt> is a fairly slow operation, it can be more efficient
             to use <tt>containsProperly</tt> to filter out test geometries which lie
             wholly inside the area.  In these cases the intersection 
             known a priori to be simply the original test geometry. 
             </para>
             </remarks>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry properly contains the given geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.CoveredBy(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> is covered by a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry is covered by the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.CoveredBy(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Covers(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> covers a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry covers the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Covers(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Crosses(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> crosses a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry crosses the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Crosses(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Disjoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> is disjoint from given geometry.
            </summary>
             <remarks>
             This method supports <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s as input
             </remarks>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry is disjoint from the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Disjoint(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> intersects a given geometry.
            </summary>
             <remarks>
             This method supports <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s as input
             </remarks>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry intersects the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Intersects(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Overlaps(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> overlaps a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry overlaps the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Overlaps(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Touches(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> touches a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry touches the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Touches(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Within(NetTopologySuite.Geometries.Geometry)">
            <summary>
             Tests whether the base <see cref="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry"/> is within a given geometry.
            </summary>
             <param name="geom">The geometry to test</param>
             <returns>true if this geometry is within the given geometry</returns>
             <see cref="M:NetTopologySuite.Geometries.Geometry.Within(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory">
            <summary>
            A factory for creating <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry"/>s. It chooses an appropriate implementation of PreparedGeometry
            based on the geometric type of the input geometry.
            <para/>
            In the future, the factory may accept hints that indicate
            special optimizations which can be performed.
            <para/>
            Instances of this class are thread-safe.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory.Prepare(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry"/> appropriate for the argument <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The geometry to prepare</param>
            <returns>
            the prepared geometry
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory.Create(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry"/> appropriate for the argument <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The geometry to prepare</param>
            <returns>
            the prepared geometry
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedLineString">
            <summary>
            A prepared version for <see cref="T:NetTopologySuite.Geometries.ILineal"/> geometries.
            <para>Instances of this class are thread-safe</para>.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects">
            <summary>
            Computes the <i>intersects</i> spatial relationship predicate
            for a target <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedLineString"/> relative to other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            </summary>
            <remarks>
            Uses short-circuit tests and indexing to improve performance.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects.Intersects(NetTopologySuite.Geometries.Prepared.PreparedLineString,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the intersects predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedLineString"/>
            and a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="prep">The prepared linestring</param>
            <param name="geom">A test geometry</param>
            <returns>true if the linestring intersects the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects.#ctor(NetTopologySuite.Geometries.Prepared.PreparedLineString)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepLine">The target PreparedLineString</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this geometry intersects a given geometry.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if the test geometry intersects</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects.IsAnyTestPointInTarget(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any representative point of the test Geometry intersects
            the target geometry.
            </summary>
            <remarks>
            Only handles test geometries which are Puntal (dimension 0)
            </remarks>
            <param name="testGeom">A Puntal geometry to test</param>
            <returns>true if any point of the argument intersects the prepared geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPoint">
            <summary>
            A prepared version for <see cref="T:NetTopologySuite.Geometries.IPuntal"/> geometries.
            <para>Instances of this class are thread-safe.</para>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPoint.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this point intersects a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <remarks>
            The optimization here is that computing topology for the test geometry
            is avoided. This can be significant for large geometries.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon">
            <summary>
            A prepared version for <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometries.
            This class supports both <see cref="T:NetTopologySuite.Geometries.Polygon"/>s and <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/>s.
            <para>This class does <b>not</b> support MultiPolygons which are non-valid
            (e.g. with overlapping elements).
            </para>
            <para/>
            Instances of this class are thread-safe and immutable.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains">
            <summary>
            Computes the <c>contains</c> spatial relationship predicate for a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> relative to all other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            Uses short-circuit tests and indexing to improve performance.
            </summary>
            <remarks>
            <para>
            It is not possible to short-circuit in all cases, in particular
            in the case where the test geometry touches the polygon linework.
            In this case full topology must be computed.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains.Contains(NetTopologySuite.Geometries.Prepared.PreparedPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the <c>contains</c> spatial relationship predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> and a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="prep">The prepared polygon</param>
            <param name="geom">A test geometry</param>
            <returns>true if the polygon contains the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains.Contains(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this PreparedPolygon <c>contains</c> a given geometry.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if the test geometry is contained</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains.FullTopologicalPredicate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the full topological <c>contains</c> predicate.<br/>
            Used when short-circuit tests are not conclusive.
            </summary>
            <param name="geom">The test geometry </param>
            <returns>true if this prepared polygon contains the test geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly">
            <summary>
            Computes the <c>containsProperly</c> spatial relationship predicate for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon" />s relative to all other {@link Geometry} classes.<br/>
            Uses short-circuit tests and indexing to improve performance.
            </summary>
            <remarks>
            <para>
            A Geometry A <c>containsProperly</c> another Geometry B if
            all points of B are contained in the Interior of A.
            Equivalently, B is contained in A AND B does not intersect
            the Boundary of A.
            </para>
            <para>
            The advantage to using this predicate is that it can be computed
            efficiently, with no need to compute topology at individual points.
            In a situation with many geometries intersecting the boundary
            of the target geometry, this can make a performance difference.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly.ContainsProperly(NetTopologySuite.Geometries.Prepared.PreparedPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>Computes the <c>containsProperly</c> predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> and a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="prep">The prepared polygon</param>
            <param name="geom">A test geometry</param>
            <returns>true if the polygon properly contains the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">The PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly.ContainsProperly(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this PreparedPolygon containsProperly a given geometry.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if the polygon properly contains the geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers">
            <summary>
            Computes the <c>Covers</c> spatial relationship predicate for a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> relative to all other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            </summary>
            <remarks>
            Uses short-circuit tests and indexing to improve performance.
            <para>
            It is not possible to short-circuit in all cases, in particular in the case where the test geometry touches the polygon linework.
            In this case full topology must be computed.
            </para></remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers.Covers(NetTopologySuite.Geometries.Prepared.PreparedPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the <c>Covers</c> spatial relationship predicate for a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/> relative to all other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            </summary>
            <param name="prep">The prepared polygon</param>
            <param name="geom">A test geometry</param>
            <returns>true if the polygon covers the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">The PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers.Covers(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this PreparedPolygon <c>covers</c> a given geometry.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if the test geometry is covered</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers.FullTopologicalPredicate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the full topological <c>covers</c> predicate. Used when short-circuit tests are not conclusive.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if this prepared polygon covers the test geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects">
            <summary>
            Computes the <i>intersects</i> spatial relationship predicate
            for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/>s relative to all other <see cref="T:NetTopologySuite.Geometries.Geometry"/> classes.
            </summary>
            <remarks>Uses short-circuit tests and indexing to improve performance.</remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects.Intersects(NetTopologySuite.Geometries.Prepared.PreparedPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the intersects predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/>
            and a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="prep">The prepared polygon</param>
            <param name="geom">A test geometry</param>
            <returns>true if the polygon intersects the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">The prepared polygon</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this PreparedPolygon intersects a given geometry.
            </summary>
            <param name="geom">The test geometry</param>
            <returns>true if the test geometry intersects</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate">
            <summary>
            A base class for predicate operations on <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon"/>s.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon)">
            <summary>
            Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAllTestComponentsInTarget(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether all components of the test Geometry are contained in the target geometry.
            </summary>
            <remarks>Handles both linear and point components.</remarks>
            <param name="testGeom">A geometry to test</param>
            <returns>
            true if all components of the argument are contained in the target geometry
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAllTestComponentsInTargetInterior(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether all components of the test Geometry are contained in the interior of the target geometry.
            </summary>
            <remarks>Handles both linear and point components.</remarks>
            <param name="testGeom">A geometry to test</param>
            <returns>true if all components of the argument are contained in the target geometry interior</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAnyTestComponentInTarget(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any component of the test Geometry intersects
            the area of the target geometry.
            Handles test geometries with both linear and point components.
            </summary>
            <param name="testGeom">A geometry to test</param>
            <returns>true if any component of the argument intersects the prepared area geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAllTestPointsInTarget(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any point of the test Geometry intersects the interior of the target geometry.
            </summary>
            <remarks>Handles test geometries with both linear and point components.</remarks>
            <param name="testGeom">A geometry to test</param>
            <returns>true if any point of the argument intersects the prepared area geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAnyTestPointInTargetInterior(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any point of the test Geometry intersects the interior of the target geometry.
            </summary>
            <param name="testGeom">A geometry to test</param>
            <returns>true if any point of the argument intersects the prepared area geometry interior</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAnyTestComponentInTargetInterior(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether any component of the test Geometry intersects the interior of the target geometry.
            </summary>
            <remarks>Handles test geometries with both linear and point components.</remarks>
            <param name="testGeom">A geometry to test</param>
            <returns>true if any component of the argument intersects the prepared area geometry interior</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAllTestPointsInTargetInterior(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether all points of the test Pointal geometry
            are contained in the target geometry.
            </summary>
            <param name="testGeom">A geometry to test</param>
            <returns>true if all points of the argument are contained in the target geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate.IsAnyTargetComponentInAreaTest(NetTopologySuite.Geometries.Geometry,System.Collections.Generic.IList{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Tests whether any component of the target geometry intersects the test geometry (which must be an areal geometry)
            </summary>
            <param name="testGeom">The test geometry</param>
            <param name="targetRepPts">The representative points of the target geometry</param>
            <returns>true if any component intersects the areal test geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Quadrant">
            <summary>
            Quadrant values
            </summary>
            <remarks>
            The quadants are numbered as follows:
            <para>
            <code>
            1 - NW | 0 - NE <br/>
            -------+------- <br/>
            2 - SW | 3 - SE
            </code>
            </para>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.Undefined">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.NE">
            <summary>
            North-East
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.NW">
            <summary>
            North-West
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.SW">
            <summary>
            South-West
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.SE">
            <summary>
            South-East
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.#ctor(System.Int32)">
            <summary>
            Creates a quadrant with t
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.#ctor(System.Double,System.Double)">
            <summary>
            Creates a quadrant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
            <exception cref="T:System.ArgumentException">If the displacements are both 0</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the quadrant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <exception cref="T:System.ArgumentException"> if the points are equal</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.IsOpposite(NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Returns true if the quadrants are 1 and 3, or 2 and 4.
            </summary>
            <param name="quad">A quadrant</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.CommonHalfPlane(NetTopologySuite.Geometries.Quadrant,NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Returns the right-hand quadrant of the halfplane defined by the two quadrants,
            or -1 if the quadrants are opposite, or the quadrant if they are identical.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.IsInHalfPlane(NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Returns whether this quadrant lies within the given halfplane (specified
            by its right-hand quadrant).
            </summary>
            <param name="halfPlane"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Quadrant.IsNorthern">
            <summary>
            Returns <c>true</c> if the given quadrant is 0 or 1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.op_Equality(NetTopologySuite.Geometries.Quadrant,NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Equality operator for quadrants
            </summary>
            <param name="lhs">Quadrant value on the left-hand-side</param>
            <param name="rhs">Quadrant value on the right-hand-side</param>
            <returns><c>true</c> if quadrant value of <paramref name="lhs"/> and <paramref name="rhs"/> are equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.op_Inequality(NetTopologySuite.Geometries.Quadrant,NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Inequality operator for quadrants
            </summary>
            <param name="lhs">Quadrant value on the left-hand-side</param>
            <param name="rhs">Quadrant value on the right-hand-side</param>
            <returns><c>true</c> if quadrant value of <paramref name="lhs"/> and <paramref name="rhs"/> are <b>not</b> equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.op_GreaterThan(NetTopologySuite.Geometries.Quadrant,NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Greater than (&gt;) operator for quadrants
            </summary>
            <param name="lhs">Quadrant value on the left-hand-side</param>
            <param name="rhs">Quadrant value on the right-hand-side</param>
            <returns><c>true</c> if quadrant value of <paramref name="lhs"/> and <paramref name="rhs"/> are <b>not</b> equal.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Quadrant.op_LessThan(NetTopologySuite.Geometries.Quadrant,NetTopologySuite.Geometries.Quadrant)">
            <summary>
            Less than (&lt;) operator for quadrants
            </summary>
            <param name="lhs">Quadrant value on the left-hand-side</param>
            <param name="rhs">Quadrant value on the right-hand-side</param>
            <returns><c>true</c> if quadrant value of <paramref name="lhs"/> and <paramref name="rhs"/> are <b>not</b> equal.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.TopologyException">
            <summary>
            Indicates an invalid or inconsistent topological situation encountered during processing
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.TopologyException.MsgWithCoord(System.String,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="msg"></param>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.TopologyException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="msg"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.TopologyException.#ctor(System.String,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="msg"></param>
             <param name="pt"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.TopologyException.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Triangle">
            <summary>
            Represents a planar triangle, and provides methods for calculating various
            properties of triangles.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Triangle.P0">
            <summary>
            A corner point of the triangle
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Triangle.P1">
            <summary>
            A corner point of the triangle
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Triangle.P2">
            <summary>
            A corner point of the triangle
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.IsAcute(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a triangle is acute. A triangle is acute if all interior
            angles are acute. This is a strict test - right triangles will return
            <tt>false</tt> A triangle which is not acute is either right or obtuse.
            <para/>
            Note: this implementation is not robust for angles very close to 90 degrees.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>True if the triangle is acute.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.IsCCW(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a triangle is oriented counter-clockwise.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns><c>true</c> if the triangle orientation is counter-clockwise</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a triangle intersects a point.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns><c>true</c> if the triangle intersects the point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.PerpendicularBisector(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the line which is the perpendicular bisector of the
            </summary>
            <param name="a">A point</param>
            <param name="b">Another point</param>
            <returns>The perpendicular bisector, as an HCoordinate line segment a-b.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Circumcentre(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the circumcentre of a triangle.</summary>
            <remarks>
            The circumcentre is the centre of the circumcircle,
            the smallest circle which encloses the triangle.
            It is also the common intersection point of the
            perpendicular bisectors of the sides of the triangle,
            and is the only point which has equal distance to all three
            vertices of the triangle.
            <para>
            The circumcentre does not necessarily lie within the triangle. For example,
            the circumcentre of an obtuse isosceles triangle lies outside the triangle.
            </para>
            <para>This method uses an algorithm due to J.R.Shewchuk which uses normalization
            to the origin to improve the accuracy of computation. (See <i>Lecture Notes
            on Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
            </para>
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The circumcentre of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.CircumcentreDD(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the circumcentre of a triangle. The circumcentre is the centre of
            the circumcircle, the smallest circle which encloses the triangle.It is
            also the common intersection point of the perpendicular bisectors of the
            sides of the triangle, and is the only point which has equal distance to
            all three vertices of the triangle.
            <para/>
            The circumcentre does not necessarily lie within the triangle. For example,
            the circumcentre of an obtuse isosceles triangle lies outside the triangle.
            <para/>
            This method uses <see cref="T:NetTopologySuite.Mathematics.DD"/> extended-precision arithmetic to
            provide more accurate results than
            <see cref="M:NetTopologySuite.Geometries.Triangle.Circumcentre(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The circumcentre of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Det(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the determinant of a 2x2 matrix. Uses standard double-precision
            arithmetic, so is susceptible to round-off error.
            </summary>
            <param name="m00">the [0,0] entry of the matrix</param>
            <param name="m01">the [0,1] entry of the matrix</param>
            <param name="m10">the [1,0] entry of the matrix</param>
            <param name="m11">the [1,1] entry of the matrix</param>
            <returns>The determinant</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.InCentre(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the incentre of a triangle.
            </summary>
            <remarks>
            The <c>InCentre</c> of a triangle is the point which is equidistant
            from the sides of the triangle.
            It is also the point at which the bisectors of the triangle's angles meet.
            It is the centre of the triangle's <c>InCircle</c>, which is the unique circle
            that is tangent to each of the triangle's three sides.
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The point which is the incentre of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Centroid(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the centroid (centre of mass) of a triangle.</summary>
            <remarks>
            This is also the point at which the triangle's three
            medians intersect (a triangle median is the segment from a vertex of the triangle to the
            midpoint of the opposite side).
            The centroid divides each median in a ratio of 2:1.
            The centroid always lies within the triangle.
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The centroid of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Length(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Compute the length of the perimeter of a triangle
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The length of the perimeter of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.LongestSideLength(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the length of the longest side of a triangle</summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The length of the longest side of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.AngleBisector(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Computes the point at which the bisector of the angle ABC cuts the segment AC.</summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The angle bisector cut point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Area(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the 2D area of a triangle.
            The area value is always non-negative.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The area of the triangle</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Triangle.SignedArea(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.SignedArea(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the signed 2D area of a triangle.
            </summary>
            <remarks>
            <para>
            The area value is positive if the triangle is oriented CW,
            and negative if it is oriented CCW.
            </para>
            <para>
            The signed area value can be used to determine point orientation, but
            the implementation in this method is susceptible to round-off errors.
            Use <see cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/> for robust orientation
            calculation.
            </para>
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The area of the triangle</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Triangle.Area(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
            <seealso cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Area3D(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the 3D area of a triangle.
            The value computed is always non-negative.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The 3D area of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.InterpolateZ(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the Z-value (elevation) of an XY point
            on a three-dimensional plane defined by a triangle
            whose vertices have Z-values.
            The defining triangle must not be degenerate
            (in other words, the triangle must enclose a
            non-zero area),
            and must not be parallel to the Z-axis.
            <para/>
            This method can be used to interpolate
            the Z-value of a point inside a triangle
            (for example, of a TIN facet with elevations on the vertices).
            </summary>
            <param name="p">The point to compute the Z-value of</param>
            <param name="v0">A vertex of a triangle, with a Z ordinate</param>
            <param name="v1">A vertex of a triangle, with a Z ordinate</param>
            <param name="v2">A vertex of a triangle, with a Z ordinate</param>
            <returns>The computed Z-value (elevation) of the point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new triangle with the given vertices.
            </summary>
            <param name="p0">A vertex</param>
            <param name="p1">A vertex</param>
            <param name="p2">A vertex</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.InCentre">
            <summary>
            Computes the <c>InCentre</c> of this triangle
            </summary>
            <remarks>The <c>InCentre</c> of a triangle is the point which is equidistant
            from the sides of the triangle.
            This is also the point at which the bisectors of the angles meet.
            It is the centre of the triangle's <c>InCircle</c>,
            which is the unique circle that is tangent to each of the triangle's three sides.
            </remarks>
            <returns>
            The point which is the InCentre of the triangle.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.IsAcute">
            <summary>
            Tests whether this triangle is acute. A triangle is acute if all interior
            angles are acute. This is a strict test - right triangles will return
            <tt>false</tt> A triangle which is not acute is either right or obtuse.
            <para/>
            Note: this implementation is not robust for angles very close to 90
            degrees.
            </summary>
            <returns><c>true</c> if this triangle is acute</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.IsCCW">
            <summary>
            Tests whether this triangle is oriented counter-clockwise.
            </summary>
            <returns><c>true</c> if the triangle orientation is counter-clockwise</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Circumcentre">
            <summary>
            Computes the circumcentre of this triangle. The circumcentre is the centre
            of the circumcircle, the smallest circle which encloses the triangle. It is
            also the common intersection point of the perpendicular bisectors of the
            sides of the triangle, and is the only point which has equal distance to
            all three vertices of the triangle.
            <para/>
            The circumcentre does not necessarily lie within the triangle.
            <para/>
            This method uses an algorithm due to J.R.Shewchuk which uses normalization
            to the origin to improve the accuracy of computation. (See <i>Lecture Notes
            on Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
            </summary>
            <returns>The circumcentre of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Centroid">
            <summary>
            Computes the centroid (centre of mass) of this triangle. This is also the
            point at which the triangle's three medians intersect (a triangle median is
            the segment from a vertex of the triangle to the midpoint of the opposite
            side). The centroid divides each median in a ratio of 2:1.
            <para/>
            The centroid always lies within the triangle.
            </summary>
            <returns>The centroid of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Length">
            <summary>
            Computes the length of the perimeter of this triangle.
            </summary>
            <returns>The length of the perimeter</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.LongestSideLength">
            <summary>
            Computes the length of the longest side of this triangle
            </summary>
            <returns>The length of the longest side of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Area">
            <summary>
            Computes the 2D area of this triangle. The area value is always
            non-negative.
            </summary>
            <returns>The area of this triangle</returns>
            <seealso cref="M:NetTopologySuite.Geometries.Triangle.SignedArea"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.SignedArea">
            <summary>
            Computes the signed 2D area of this triangle. The area value is positive if
            the triangle is oriented CW, and negative if it is oriented CCW.
            <para/>
            The signed area value can be used to determine point orientation, but the
            implementation in this method is susceptible to round-off errors. Use
            <see cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
            for robust orientation calculation.
            </summary>
            <returns>The signed 2D area of this triangle</returns>
            <seealso cref="M:NetTopologySuite.Algorithm.Orientation.Index(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.Area3D">
            <summary>
            Computes the 3D area of this triangle. The value computed is always
            non-negative.
            </summary>
            <returns>The 3D area of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle.InterpolateZ(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the Z-value (elevation) of an XY point on a three-dimensional
            plane defined by this triangle (whose vertices must have Z-values). This
            triangle must not be degenerate (in other words, the triangle must enclose
            a non-zero area), and must not be parallel to the Z-axis.
            <para/>
            This method can be used to interpolate the Z-value of a point inside this
            triangle (for example, of a TIN facet with elevations on the vertices).
            </summary>
            <param name="p">The point to compute the Z-value of</param>
            <returns>The computed Z-value (elevation) of the point</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.AffineTransformation">
            <summary>
            Represents an affine transformation on the 2D Cartesian plane.
            </summary>
            <remarks>
            <para>
            It can be used to transform a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> or <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            An affine transformation is a mapping of the 2D plane into itself
            via a series of transformations of the following basic types:
            <ul>
            <li>reflection (through a line)</li>
            <li>rotation (around the origin)</li>
            <li>scaling (relative to the origin)</li>
            <li>shearing (in both the X and Y directions)</li>
            <li>translation</li>
            </ul>
            </para>
            <para>
            In general, affine transformations preserve straightness and parallel lines,
            but do not preserve distance or shape.
            </para>
            <para>
            An affine transformation can be represented by a 3x3
            matrix in the following form:
            <blockquote><code>
            T = | m00 m01 m02 |<br/>
                | m10 m11 m12 |<br/>
                |  0   0   1  |
            </code></blockquote>
            A coordinate P = (x, y) can be transformed to a new coordinate P' = (x', y')
            by representing it as a 3x1 matrix and using matrix multiplication to compute:
            <blockquote><code>
            | x' |  = T x | x |<br/>
            | y' |        | y |<br/>
            | 1  |        | 1 |
            </code></blockquote>
            </para>
            <h3>Transformation Composition</h3>
            <para>
            Affine transformations can be composed using the <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Compose(NetTopologySuite.Geometries.Utilities.AffineTransformation)"/> method.
            Composition is computed via multiplication of the
            transformation matrices, and is defined as:
            <blockquote><pre>
            A.compose(B) = T<sub>B</sub> x T<sub>A</sub>
            </pre></blockquote>
            </para>
            <para>
            This produces a transformation whose effect is that of A followed by B.
            The methods <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Reflect(System.Double,System.Double,System.Double,System.Double)"/>, <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Rotate(System.Double)"/>,
            <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Scale(System.Double,System.Double)"/>, <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Shear(System.Double,System.Double)"/>, and <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Translate(System.Double,System.Double)"/>
            have the effect of composing a transformation of that type with
            the transformation they are invoked on.
            The composition of transformations is in general <i>not</i> commutative.
            </para>
            <h3>Transformation Inversion</h3>
            <para>
            Affine transformations may be invertible or non-invertible.
            If a transformation is invertible, then there exists
            an inverse transformation which when composed produces
            the identity transformation.
            The <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.GetInverse"/> method
            computes the inverse of a transformation, if one exists.
            </para>
            <para>
            @author Martin Davis
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ReflectionInstance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a transformation for a reflection about the
            line (x0,y0) - (x1,y1).
            </summary>
            <param name="x0"> the x-ordinate of a point on the reflection line</param>
            <param name="y0"> the y-ordinate of a point on the reflection line</param>
            <param name="x1"> the x-ordinate of a another point on the reflection line</param>
            <param name="y1"> the y-ordinate of a another point on the reflection line</param>
            <returns> a transformation for the reflection</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ReflectionInstance(System.Double,System.Double)">
            <summary>
            Creates a transformation for a reflection about the
            line (0,0) - (x,y).
            </summary>
            <param name="x"> the x-ordinate of a point on the reflection line</param>
            <param name="y"> the y-ordinate of a point on the reflection line</param>
            <returns> a transformation for the reflection</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.RotationInstance(System.Double)">
            <summary>
            Creates a transformation for a rotation
            about the origin
            by an angle <i>theta</i>.
            </summary>
            <remarks>
            Positive angles correspond to a rotation
            in the counter-clockwise direction.
            </remarks>
            <param name="theta"> the rotation angle, in radians</param>
            <returns> a transformation for the rotation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.RotationInstance(System.Double,System.Double)">
            <summary>
            Creates a transformation for a rotation
            by an angle <i>theta</i>,
            specified by the sine and cosine of the angle.
            </summary>
            <remarks>
            This allows providing exact values for sin(theta) and cos(theta)
            for the common case of rotations of multiples of quarter-circles.
            </remarks>
            <param name="sinTheta"> the sine of the rotation angle</param>
            <param name="cosTheta"> the cosine of the rotation angle</param>
            <returns> a transformation for the rotation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.RotationInstance(System.Double,System.Double,System.Double)">
            <summary>
            Creates a transformation for a rotation
            about the point (x,y) by an angle <i>theta</i>.
            </summary>
            <remarks>
            Positive angles correspond to a rotation
            in the counter-clockwise direction.
            </remarks>
            <param name="theta"> the rotation angle, in radians</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> a transformation for the rotation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.RotationInstance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a transformation for a rotation
            about the point (x,y) by an angle <i>theta</i>,
            specified by the sine and cosine of the angle.
            </summary>
            <remarks>
            This allows providing exact values for sin(theta) and cos(theta)
            for the common case of rotations of multiples of quarter-circles.
            </remarks>
            <param name="sinTheta"> the sine of the rotation angle</param>
            <param name="cosTheta"> the cosine of the rotation angle</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> a transformation for the rotation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ScaleInstance(System.Double,System.Double)">
            <summary>
            Creates a transformation for a scaling relative to the origin.
            </summary>
            <param name="xScale"> the value to scale by in the x direction</param>
            <param name="yScale"> the value to scale by in the y direction</param>
            <returns> a transformation for the scaling</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ScaleInstance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a transformation for a scaling relative to the point (x,y).
            </summary>
            <param name="xScale">The value to scale by in the x direction</param>
            <param name="yScale">The value to scale by in the y direction</param>
            <param name="x">The x-ordinate of the point to scale around</param>
            <param name="y">The y-ordinate of the point to scale around</param>
            <returns>A transformation for the scaling</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ShearInstance(System.Double,System.Double)">
            <summary>
            Creates a transformation for a shear.
            </summary>
            <param name="xShear"> the value to shear by in the x direction</param>
            <param name="yShear"> the value to shear by in the y direction</param>
            <returns> a transformation for the shear</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.TranslationInstance(System.Double,System.Double)">
            <summary>
            Creates a transformation for a translation.
            </summary>
            <param name="x"> the value to translate by in the x direction</param>
            <param name="y"> the value to translate by in the y direction</param>
            <returns> a transformation for the translation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.#ctor">
            <summary>
            Constructs a new identity transformation
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.#ctor(System.Double[])">
            <summary>
            Constructs a new transformation whose
            matrix has the specified values.
            </summary>
            <param name="matrix"> an array containing the 6 values { m00, m01, m02, m10, m11, m12 }</param>
            <exception cref="T:System.NullReferenceException"> if matrix is null</exception>
            <exception cref="T:System.IndexOutOfRangeException"> if matrix is too small</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a new transformation whose
            matrix has the specified values.
            </summary>
            <param name="m00"> the entry for the [0, 0] element in the transformation matrix</param>
            <param name="m01"> the entry for the [0, 1] element in the transformation matrix</param>
            <param name="m02"> the entry for the [0, 2] element in the transformation matrix</param>
            <param name="m10"> the entry for the [1, 0] element in the transformation matrix</param>
            <param name="m11"> the entry for the [1, 1] element in the transformation matrix</param>
            <param name="m12"> the entry for the [1, 2] element in the transformation matrix</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.#ctor(NetTopologySuite.Geometries.Utilities.AffineTransformation)">
            <summary>
            Constructs a transformation which is
            a copy of the given one.
            </summary>
            <param name="trans"> the transformation to copy</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a transformation
            which maps the given source
            points into the given destination points.
            </summary>
            <param name="src0"> source point 0</param>
            <param name="src1"> source point 1</param>
            <param name="src2"> source point 2</param>
            <param name="dest0"> the mapped point for source point 0</param>
            <param name="dest1"> the mapped point for source point 1</param>
            <param name="dest2"> the mapped point for source point 2</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToIdentity">
            <summary>
            Sets this transformation to be the identity transformation.
            </summary>
            <remarks>
            The identity transformation has the matrix:
            <blockquote><code>
            | 1 0 0 |<br/>
            | 0 1 0 |<br/>
            | 0 0 1 |
            </code></blockquote>
            </remarks>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetTransformation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets this transformation's matrix to have the given values.
            </summary>
            <param name="m00"> the entry for the [0, 0] element in the transformation matrix</param>
            <param name="m01"> the entry for the [0, 1] element in the transformation matrix</param>
            <param name="m02"> the entry for the [0, 2] element in the transformation matrix</param>
            <param name="m10"> the entry for the [1, 0] element in the transformation matrix</param>
            <param name="m11"> the entry for the [1, 1] element in the transformation matrix</param>
            <param name="m12"> the entry for the [1, 2] element in the transformation matrix</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetTransformation(NetTopologySuite.Geometries.Utilities.AffineTransformation)">
            <summary>
            Sets this transformation to be a copy of the given one
            </summary>
            <param name="trans"> a transformation to copy</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.AffineTransformation.MatrixEntries">
            <summary>
            Gets an array containing the entries
            of the transformation matrix.
            </summary>
            <remarks>
            Only the 6 non-trivial entries are returned,
            in the sequence:
            <pre>
            m00, m01, m02, m10, m11, m12
            </pre>
            </remarks>
            <returns> an array of length 6</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.AffineTransformation.Determinant">
             <summary>
             Computes the determinant of the transformation matrix.
             </summary>
             <remarks>
             <para>
             The determinant is computed as:
             <blockquote><code>
             | m00 m01 m02 |<br/>
             | m10 m11 m12 | = m00 * m11 - m01 * m10<br/>
             |  0   0   1  |
             </code></blockquote>
             </para>
             <para>
             If the determinant is zero,
             the transform is singular (not invertible),
             and operations which attempt to compute
             an inverse will throw a <see cref="T:NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException"/>.
             </para>
             </remarks>
             <returns> the determinant of the transformation</returns>
             <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.GetInverse" />
            
             <returns>The determinant of the transformation</returns>
             <see cref="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.GetInverse"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.GetInverse">
            <summary>
            Computes the inverse of this transformation, if one
            exists.
            </summary>
            <remarks>
            <para>
            The inverse is the transformation which when
            composed with this one produces the identity
            transformation.
            A transformation has an inverse if and only if it
            is not singular (i.e. its
            determinant is non-zero).
            Geometrically, an transformation is non-invertible
            if it maps the plane to a line or a point.
            If no inverse exists this method
            will throw a <see cref="T:NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException"/>.
            </para>
            <para>
            The matrix of the inverse is equal to the
            inverse of the matrix for the transformation.
            It is computed as follows:
            <blockquote><code>
                            1
            inverse(A)  =  ---   x  adjoint(A)
                           det
            
            
                        =   1       |  m11  -m01   m01*m12-m02*m11  |
                           ---   x  | -m10   m00  -m00*m12+m10*m02  |
                           det      |  0     0     m00*m11-m10*m01  |
            
            
            
                        = |  m11/det  -m01/det   m01*m12-m02*m11/det |
                          | -m10/det   m00/det  -m00*m12+m10*m02/det |
                          |   0           0          1               |
            </code></blockquote>
            </para>
            </remarks>
            <returns>A new inverse transformation</returns>
            <see cref="P:NetTopologySuite.Geometries.Utilities.AffineTransformation.Determinant"/>
            <exception cref="T:NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException"></exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToReflectionBasic(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Explicitly computes the math for a reflection.  May not work.
            </summary>
            <param name="x0">The x-ordinate of one point on the reflection line</param>
            <param name="y0">The y-ordinate of one point on the reflection line</param>
            <param name="x1">The x-ordinate of another point on the reflection line</param>
            <param name="y1">The y-ordinate of another point on the reflection line</param>
            <returns>This transformation with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToReflection(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets this transformation to be a reflection about the line defined by a line <tt>(x0,y0) - (x1,y1)</tt>.
            </summary>
            <param name="x0">The x-ordinate of one point on the reflection line</param>
            <param name="y0">The y-ordinate of one point on the reflection line</param>
            <param name="x1">The x-ordinate of another point on the reflection line</param>
            <param name="y1">The y-ordinate of another point on the reflection line</param>
            <returns>This transformation with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToReflection(System.Double,System.Double)">
            <summary>
            Sets this transformation to be a reflection
            about the line defined by vector (x,y).
            </summary>
            <remarks>
            The transformation for a reflection
            is computed by:
            <blockquote><code>
            d = sqrt(x<sup>2</sup> + y<sup>2</sup>)
            sin = x / d;
            cos = x / d;
            T<sub>ref</sub> = T<sub>rot(sin, cos)</sub> x T<sub>scale(1, -1)</sub> x T<sub>rot(-sin, cos)</sub>
            </code></blockquote>
            </remarks>
            <param name="x"> the x-component of the reflection line vector</param>
            <param name="y"> the y-component of the reflection line vector</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToRotation(System.Double)">
            <summary>
            Sets this transformation to be a rotation around the orign.
            </summary>
            <remarks>
            A positive rotation angle corresponds
            to a counter-clockwise rotation.
            The transformation matrix for a rotation
            by an angle <c>theta</c>
            has the value:
            <blockquote><pre>
            |  cos(theta)  -sin(theta)   0 |
            |  sin(theta)   cos(theta)   0 |
            |           0            0   1 |
            </pre></blockquote>
            </remarks>
            <param name="theta"> the rotation angle, in radians</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToRotation(System.Double,System.Double)">
            <summary>
            Sets this transformation to be a rotation around the origin
            by specifying the sin and cos of the rotation angle directly.
            </summary>
            <remarks>
            The transformation matrix for the rotation
            has the value:
            <blockquote><pre>
            |  cosTheta  -sinTheta   0 |
            |  sinTheta   cosTheta   0 |
            |         0          0   1 |
            </pre></blockquote>
            </remarks>
            <param name="sinTheta"> the sine of the rotation angle</param>
            <param name="cosTheta"> the cosine of the rotation angle</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToRotation(System.Double,System.Double,System.Double)">
            <summary>
            Sets this transformation to be a rotation
            around a given point (x,y).
            </summary>
            <remarks>
            A positive rotation angle corresponds
            to a counter-clockwise rotation.
            The transformation matrix for a rotation
            by an angle <paramref name="theta" />
            has the value:
            <blockquote><pre>
            |  cosTheta  -sinTheta   x-x*cos+y*sin |
            |  sinTheta   cosTheta   y-x*sin-y*cos |
            |           0            0   1 |
            </pre></blockquote>
            </remarks>
            <param name="theta"> the rotation angle, in radians</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToRotation(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets this transformation to be a rotation
            around a given point (x,y)
            by specifying the sin and cos of the rotation angle directly.
            </summary>
            <remarks>
            The transformation matrix for the rotation
            has the value:
            <blockquote><pre>
            |  cosTheta  -sinTheta   x-x*cos+y*sin |
            |  sinTheta   cosTheta   y-x*sin-y*cos |
            |         0          0         1       |
            </pre></blockquote>
            </remarks>
            <param name="sinTheta"> the sine of the rotation angle</param>
            <param name="cosTheta"> the cosine of the rotation angle</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToScale(System.Double,System.Double)">
            <summary>
            Sets this transformation to be a scaling.
            </summary>
            <remarks>
            The transformation matrix for a scale
            has the value:
            <blockquote><pre>
            |  xScale      0  dx |
            |  0      yScale  dy |
            |  0           0   1 |
            </pre></blockquote>
            </remarks>
            <param name="xScale"> the amount to scale x-ordinates by</param>
            <param name="yScale"> the amount to scale y-ordinates by</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToShear(System.Double,System.Double)">
            <summary>
            Sets this transformation to be a shear.
            </summary>
            <remarks>
            The transformation matrix for a shear
            has the value:
            <blockquote><pre>
            |  1      xShear  0 |
            |  yShear      1  0 |
            |  0           0  1 |
            </pre></blockquote>
            Note that a shear of (1, 1) is <i>not</i>
            equal to shear(1, 0) composed with shear(0, 1).
            Instead, shear(1, 1) corresponds to a mapping onto the
            line x = y.
            </remarks>
            <param name="xShear"> the x component to shear by</param>
            <param name="yShear"> the y component to shear by</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.SetToTranslation(System.Double,System.Double)">
            <summary>
            Sets this transformation to be a translation.
            </summary>
            <remarks>
            For a translation by the vector (x, y)
            the transformation matrix has the value:
            <blockquote><pre>
            |  1  0  dx |
            |  1  0  dy |
            |  0  0   1 |
            </pre></blockquote>
            </remarks>
            <param name="dx"> the x component to translate by</param>
            <param name="dy"> the y component to translate by</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Reflect(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a reflection transformation composed
            with the current value.
            </summary>
            <param name="x0"> the x-ordinate of a point on the line to reflect around</param>
            <param name="y0"> the y-ordinate of a point on the line to reflect around</param>
            <param name="x1"> the x-ordinate of a point on the line to reflect around</param>
            <param name="y1"> the y-ordinate of a point on the line to reflect around</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Reflect(System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a reflection transformation composed
            with the current value.
            </summary>
            <param name="x"> the x-ordinate of the line to reflect around</param>
            <param name="y"> the y-ordinate of the line to reflect around</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Rotate(System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a rotation transformation composed
            with the current value.
            </summary>
            <remarks>
            Positive angles correspond to a rotation
            in the counter-clockwise direction.
            </remarks>
            <param name="theta"> the angle to rotate by in radians</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Rotate(System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a rotation around the origin composed
            with the current value,
            with the sin and cos of the rotation angle specified directly.
            </summary>
            <param name="sinTheta"> the sine of the angle to rotate by</param>
            <param name="cosTheta"> the cosine of the angle to rotate by</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a rotation around a given point composed
            with the current value.
            </summary>
            <remarks>
            Positive angles correspond to a rotation
            in the counter-clockwise direction.
            </remarks>
            <param name="theta"> the angle to rotate by, in radians</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Rotate(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a rotation around a given point composed
            with the current value,
            with the sin and cos of the rotation angle specified directly.
            </summary>
            <param name="sinTheta"> the sine of the angle to rotate by</param>
            <param name="cosTheta"> the cosine of the angle to rotate by</param>
            <param name="x"> the x-ordinate of the rotation point</param>
            <param name="y"> the y-ordinate of the rotation point</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Scale(System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a scale transformation composed
            with the current value.
            </summary>
            <param name="xScale"> the value to scale by in the x direction</param>
            <param name="yScale"> the value to scale by in the y direction</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Shear(System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a shear transformation composed
            with the current value.
            </summary>
            <param name="xShear"> the value to shear by in the x direction</param>
            <param name="yShear"> the value to shear by in the y direction</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Translate(System.Double,System.Double)">
            <summary>
            Updates the value of this transformation
            to that of a translation transformation composed
            with the current value.
            </summary>
            <param name="x"> the value to translate by in the x direction</param>
            <param name="y"> the value to translate by in the y direction</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Compose(NetTopologySuite.Geometries.Utilities.AffineTransformation)">
            <summary>
            Updates this transformation to be
            the composition of this transformation with the given <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation" />.
            </summary>
            <remarks>
            This produces a transformation whose effect
            is equal to applying this transformation
            followed by the argument transformation.
            Mathematically,
            <blockquote><pre>
            A.compose(B) = T<sub>B</sub> x T<sub>A</sub>
            </pre></blockquote>
            </remarks>
            <param name="trans"> an affine transformation</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ComposeBefore(NetTopologySuite.Geometries.Utilities.AffineTransformation)">
            <summary>
            Updates this transformation to be the composition
            of a given <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation" /> with this transformation.
            </summary>
            <remarks>
            This produces a transformation whose effect
            is equal to applying the argument transformation
            followed by this transformation.
            Mathematically,
            <blockquote><pre>
            A.composeBefore(B) = T<sub>A</sub> x T<sub>B</sub>
            </pre></blockquote>
            </remarks>
            <param name="trans"> an affine transformation</param>
            <returns> this transformation, with an updated matrix</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Transform(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
             Applies this transformation to the <paramref name="src" /> coordinate
             and places the results in the <paramref name="dest" /> coordinate
             (which may be the same as the source).
             </summary>
             <param name="src"> the coordinate to transform</param>
             <param name="dest"> the coordinate to accept the results</param>
             <returns> the <c>dest</c> coordinate</returns>
            
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Transform(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.Geometry"/> which is the result of this transformation applied to the input Geometry.
            </summary>
            <param name="g">A <c>Geometry</c></param>
            <returns>The transformed Geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Transform(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Applies this transformation to the i'th coordinate
            in the given CoordinateSequence.
            </summary>
            <param name="seq"> a <c>CoordinateSequence</c></param>
            <param name="i"> the index of the coordinate to transform</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Transforms the i'th coordinate in the input sequence
            </summary>
            <param name="seq">A <c>CoordinateSequence</c></param>
            <param name="i">The index of the coordinate to transform</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.AffineTransformation.Done">
            <summary>
            Reports that this filter should continue to be executed until
            all coordinates have been transformed.
            </summary>
            <returns> false</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.AffineTransformation.IsIdentity">
            <summary>Tests if this transformation is the identity transformation.</summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Equals(System.Object)">
            <summary>
            Tests if an object is an <c>AffineTransformation</c> and has the same matrix as this transformation.
            </summary>
            <param name="obj">An object to test</param>
            <returns>true if the given object is equal to this object</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.ToString">
            <summary>
            Gets a text representation of this transformation.
            The string is of the form:
            <code>
            AffineTransformation[[m00, m01, m02], [m10, m11, m12]]
            </code>
            </summary>
            <returns>A string representing this transformation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformation.Clone">
            <summary>
            Clones this transformation
            </summary>
            <returns>A copy of this transformation</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder">
            <summary>
            Builds an <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation"/> defined by a set of control vectors.
            </summary>
            <remarks>
            <para>
            A control vector consists of a source point and a destination point,
            which is the image of the source point under the desired transformation.
            </para>
            <para>
            A transformation is well-defined
            by a set of three control vectors
            if and only if the source points are not collinear.
            (In particular, the degenerate situation
            where two or more source points are identical will not produce a well-defined transformation).
            A well-defined transformation exists and is unique.
            If the control vectors are not well-defined, the system of equations
            defining the transformation matrix entries is not solvable,
            and no transformation can be determined.</para>
            <para>
            No such restriction applies to the destination points.
            However, if the destination points are collinear or non-unique,
            a non-invertible transformations will be generated.
            </para>
            <para>
            This technique of recovering a transformation
            from its effect on known points is used in the Bilinear Interpolated Triangulation
            algorithm for warping planar surfaces.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a new builder for the transformation defined by the given set of control point mappings.
            </summary>
            <param name="src0">A control point</param>
            <param name="src1">A control point</param>
            <param name="src2">A control point</param>
            <param name="dest0">The image of <paramref name="src0"/> under the required transformation</param>
            <param name="dest1">The image of <paramref name="src1"/> under the required transformation</param>
            <param name="dest2">The image of <paramref name="src2"/> under the required transformation</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.GetTransformation">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation"/>
            determined by the control point mappings,
            or <c>null</c> if the control vectors do not determine a well-defined transformation.
            </summary>
            <returns>
            An affine transformation, or <see langword="null"/> if the control vectors do not
            determine a well-defined transformation.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.Compute">
            <summary>
            Computes the transformation matrix by
            solving the two systems of linear equations
            defined by the control point mappings,
            if this is possible.
            </summary>
            <returns>True if the transformation matrix is solvable</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.Solve(System.Double[])">
            <summary>
            Solves the transformation matrix system of linear equations
            for the given right-hand side vector.
            </summary>
            <param name="b">The vector for the right-hand side of the system</param>
            <returns>The solution vector, or <see langword="null"/> if no solution could be determined.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory">
            <summary>
            Supports creating <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation"/>s defined by various kinds of inputs and transformation mapping rules.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.CreateFromControlVectors(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a transformation from a set of three control vectors. A control
            vector consists of a source point and a destination point, which is the
            image of the source point under the desired transformation. Three control
            vectors allows defining a fully general affine transformation.
            </summary>
            <param name="src0"></param>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dest0"></param>
            <param name="dest1"></param>
            <param name="dest2"></param>
            <returns>The computed transformation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.CreateFromControlVectors(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an AffineTransformation defined by a pair of control vectors. A
            control vector consists of a source point and a destination point, which is
            the image of the source point under the desired transformation. The
            computed transformation is a combination of one or more of a uniform scale,
            a rotation, and a translation (i.e. there is no shear component and no
            reflection)
            </summary>
            <param name="src0"></param>
            <param name="src1"></param>
            <param name="dest0"></param>
            <param name="dest1"></param>
            <returns>The computed transformation</returns>
            <returns><c>null</c> if the control vectors do not determine a well-defined transformation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.CreateFromControlVectors(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an AffineTransformation defined by a single control vector. A
            control vector consists of a source point and a destination point, which is
            the image of the source point under the desired transformation. This
            produces a translation.
            </summary>
            <param name="src0">The start point of the control vector</param>
            <param name="dest0">The end point of the control vector</param>
            <returns>The computed transformation</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.CreateFromControlVectors(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates an AffineTransformation defined by a set of control vectors.
            Between one and three vectors must be supplied.
            </summary>
            <param name="src">The source points of the vectors</param>
            <param name="dest">The destination points of the vectors</param>
            <returns>The computed transformation</returns>
            <exception cref="T:System.ArgumentException">if the control vector arrays are too short, long or of different lengths</exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.CreateFromBaseLines(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an AffineTransformation defined by a mapping between two baselines.
            The computed transformation consists of:
            <list type="bullet">
            <item><description>a translation from the start point of the source baseline to the start point of the destination baseline,</description></item>
            <item><description>a rotation through the angle between the baselines about the destination start point,</description></item>
            <item><description>and a scaling equal to the ratio of the baseline lengths.</description></item>
            </list>
            If the source baseline has zero length, an identity transformation is returned.
            </summary>
            <param name="src0">The start point of the source baseline</param>
            <param name="src1">The end point of the source baseline</param>
            <param name="dest0">The start point of the destination baseline</param>
            <param name="dest1">The end point of the destination baseline</param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter">
            <summary>
            Extracts a representative <see cref="T:NetTopologySuite.Geometries.Coordinate"/>
            from each connected component of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <version>1.9</version>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter.GetCoordinates(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts a representative <see cref="T:NetTopologySuite.Geometries.Coordinate"/>
            from each connected component in a geometry.
            <para/>
            If more than one geometry is to be processed, it is more
            efficient to create a single <see cref="T:NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter"/>
            instance and pass it to each geometry.
            </summary>
            <param name="geom">The Geometry from which to extract</param>
            <returns>A list of representative Coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter.#ctor(System.Collections.Generic.List{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner">
            <summary>
            Utility to combine just the <see cref="T:NetTopologySuite.Geometries.Envelope"/>s of a list of geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Gets the smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </summary>
            <param name="geoms">
            The list of input geometries.
            </param>
            <returns>
            The smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Gets the smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </summary>
            <param name="geoms">
            The list of input geometries.
            </param>
            <returns>
            The smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.CombineAsGeometry(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(NetTopologySuite.Geometries.Geometry[])"/>.
            </summary>
            <param name="geoms">
            The list of input geometries.
            </param>
            <returns>
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(NetTopologySuite.Geometries.Geometry[])"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.CombineAsGeometry(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})"/>.
            </summary>
            <param name="geoms">
            The list of input geometries.
            </param>
            <returns>
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.#ctor(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner"/> class.
            </summary>
            <param name="geoms">
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> instances to combine.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner"/> class.
            </summary>
            <param name="geoms">
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> instances to combine.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine">
            <summary>
            Gets the smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </summary>
            <returns>
            The smallest <see cref="T:NetTopologySuite.Geometries.Envelope"/> within which all input geometries fit, or a
            <see cref="P:NetTopologySuite.Geometries.Envelope.IsNull">null</see> envelope if no non-empty geometries were found in
            the input list.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.CombineAsGeometry">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine"/>.
            </summary>
            <returns>
            The <see cref="T:NetTopologySuite.Geometries.Geometry"/> representation of the result of <see cref="M:NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.Combine"/>.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper">
            <summary>
            Maps the members of a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            into another <tt>GeometryCollection</tt> via a defined
            mapping function.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.Map(NetTopologySuite.Geometries.GeometryCollection,System.Func{NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry})">
             <summary>
            
             </summary>
             <param name="gc"></param>
             <param name="op"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.#ctor(System.Func{NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry})">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="mapOp"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.Map(NetTopologySuite.Geometries.GeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryCombiner">
            <summary>
            Combines <see cref="T:NetTopologySuite.Geometries.Geometry"/>s to produce a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> of the most appropriate type.
            </summary>
            <remarks>
            <para>Input geometries which are already collections will have their elements extracted first.</para>
            <para>No validation of the result geometry is performed.
            (The only case where invalidity is possible is where <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometries are combined and result in a self-intersection).</para>
            </remarks>
            <author>mbdavis</author>
            <seealso cref="M:NetTopologySuite.Geometries.GeometryFactory.BuildGeometry(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.Combine(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>Combines a collection of geometries.</summary>
            <param name="geoms">The geometries to combine</param>
            <returns>The combined geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.Combine(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            Combines two geometries.
             </summary>
             <param name="g0">A geometry to combine</param>
             <param name="g1">A geometry to combine</param>
             <returns>The combined geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.Combine(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            Combines three geometries.
             </summary>
             <param name="g0">A geometry to combine</param>
             <param name="g1">A geometry to combine</param>
             <param name="g2">A geometry to combine</param>
             <returns>The combined geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.CreateList(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a list from two items
            </summary>
            <param name="obj0"></param>
            <param name="obj1"></param>
            <returns>A list from two geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.CreateList(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a list from three items
            </summary>
            <param name="obj0"></param>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns>A list from three geometries</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryCombiner.SkipEmpty">
            <summary>
            Value indicating whether empty geometries should be skipped
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Creates a new combiner for a collection of geometries
            </summary>
            <param name="geoms">The geometries to combine</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.ExtractFactory(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Extracts the GeometryFactory used by the geometries in a collection
            </summary>
            <param name="geoms"></param>
            <returns>a GeometryFactory</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryCombiner.Combine">
            <summary>
            Computes the combination of the input geometries to produce the most appropriate <see cref="T:NetTopologySuite.Geometries.Geometry"/> or <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            </summary>
            <returns>A Geometry which is the combination of the inputs</returns>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor">
            <summary>
            A class which supports creating new <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            which are modifications of existing ones,
            maintaining the same type structure.
            </summary>
            <remarks>
            Geometry objects are intended to be treated as immutable.
            This class allows you to "modifies" a Geometrys
            by traversing them, applying a user-defined
            <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation"/>, <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation"/> or <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation"/>
            and creating a new Geometrys with the same structure but
            (possibly) modified components.
            <para>
            Examples of the kinds of modifications which can be made are:
            <list type="bullet">
            <item><description>
            The values of the coordinates may be changed.
            The editor does not check whether changing coordinate values makes the result Geometry invalid
            </description></item>
            <item><description>
            The coordinate lists may be changed (e.g. by adding, deleting or modifying coordinates).
            The modified coordinate lists must be consistent with their original parent component
            (e.g. a <tt>LinearRing</tt> must always have at least 4 coordinates, and the first and last
            coordinate must be equal).
            </description></item>
            <item><description>
            Components of the original point may be deleted
            (e.g. holes may be removed from a Polygon, or LineStrings removed from a MultiLineString).
            Deletions will be propagated up the component tree appropriately.
            </description></item></list>
            </para>
            <para>
            All changes must be consistent with the original Geometry's structure
            (e.g. a <c>Polygon</c> cannot be collapsed into a <c>LineString</c>).
            If changing the structure is required, use a <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer"/>.
            </para>
            <para>
            This class supports creating an edited Geometry
            using a different <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> via the <see cref="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.#ctor(NetTopologySuite.Geometries.GeometryFactory)"/>
            constructor.
            Examples of situations where this is required is if the geometry is
            transformed to a new SRID and/or a new PrecisionModel.</para>
            <para>
            Usage notes
            <list type="bullet">
            <item><description>The resulting Geometry is not checked for validity.
            If validity needs to be enforced, the new Geometry's
            <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/> method should be called.</description></item>
            <item><description>By default the UserData of the input geometry is not copied to the result.</description></item>
            </list>
            </para>
            </remarks>
            <seealso cref="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer"/>
            <seealso cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryEditor._factory">
            <summary>
            The factory used to create the modified Geometry.
            </summary>
            <remarks>
            If <tt>null</tt> the GeometryFactory of the input is used.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.#ctor">
            <summary>
            Creates a new GeometryEditor object which will create
            edited <see cref="T:NetTopologySuite.Geometries.Geometry"/> with the same <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> as the input Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a new GeometryEditor object which will create
            edited <see cref="T:NetTopologySuite.Geometries.Geometry"/>s with the given <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="factory">The GeometryFactory to create the edited Geometry with.</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryEditor.CopyUserData">
            <summary>
            Gets or sets a value indicating if the User Data is copied to the edit result.
            If so, only the object reference is copied.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.Edit(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation)">
            <summary>
            Edit the input <c>Geometry</c> with the given edit operation.
            Clients can create subclasses of GeometryEditorOperation or
            CoordinateOperation to perform required modifications.
            </summary>
            <param name="geometry">The Geometry to edit.</param>
            <param name="operation">The edit operation to carry out.</param>
            <returns>A new <c>Geometry</c> which is the result of the editing (which may be empty).</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation">
            <summary>
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation.Edit(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Edits a Geometry by returning a new Geometry with a modification.
            The returned Geometry may be the input geometry itself.
            It may be <c>null</c> if the geometry is to be deleted.
            </summary>
            <param name="geometry">The Geometry to modify.</param>
            <param name="factory">
            The factory with which to construct the modified Geometry
            (may be different to the factory of the input point).
            </param>
            <returns>A new Geometry which is a modification of the input Geometry.</returns>
            <returns><c>null</c> if the Geometry is to be deleted completely</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.NoOpGeometryOperation">
            <summary>
            A GeometryEditorOperation which does not modify
            the input geometry.
            This can be used for simple changes of
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> (including PrecisionModel and SRID).
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which edits the coordinate list of a <c>Geometry</c>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation.Edit(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <param name="factory"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation.Edit(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Geometry)">
            <summary>
            Edits the array of <c>Coordinate</c>s from a <c>Geometry</c>.
            </summary>
            <param name="coordinates">The coordinate array to operate on.</param>
            <param name="geometry">The point containing the coordinate list.</param>
            <returns>An edited coordinate array (which may be the same as the input).</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation">
            <summary>
            A <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation"/> which edits the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>
            of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            <para/>
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation.EditSequence">
            <returns>An edited coordinate sequence (which may be the same as the input)</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryExtracter">
            <summary>
            Extracts the components of a given type from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracter.Extract``1(NetTopologySuite.Geometries.Geometry,System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Extracts the <c>T</c> components from an <see cref="T:NetTopologySuite.Geometries.Geometry"/> and adds them to the provided <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="geom">the geometry from which to extract</param>
            <param name="list">the list to add the extracted elements to</param>
            <typeparam name="T">The geometry type to extract</typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracter.Extract``1(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the <c>T</c> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> and returns them in a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="geom">the geometry from which to extract</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracter.Extract(NetTopologySuite.Geometries.Geometry,System.String)">
            <summary>
            Extracts the components of <tt>geometryType</tt> from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="geometryType">Geometry type to extract (null or all white-space means all types)</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracter.Extract(NetTopologySuite.Geometries.Geometry,System.String,System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Extracts the components of <tt>geometryType</tt> from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and adds them to the provided <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="geometryType">Geometry type to extract (null or all white-space means all types)</param>
            <param name="list">The list to add the extracted elements to</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName">
            <summary>
            Extracts the components of type <c>T</c> from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.#ctor(System.String,System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a filter with a list in which to store the elements found.
            </summary>
            <param name="geometryType">Geometry type to extract (null means all types)</param>
            <param name="comps">The list to extract into</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.IsOfType(NetTopologySuite.Geometries.Geometry,System.String)">
            <summary>
            Y
            </summary>
            <param name="geom"></param>
            <param name="geometryType"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.Filter(NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.IGeometryFilter.Filter(NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryExtracter`1">
            <summary>
            Extracts the components of type <c>T</c> from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryExtracter`1.#ctor(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a filter with a list in which to store the elements found.
            </summary>
            <param name="comps">The list to extract into</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryFixer">
            <summary>
            Fixes a geometry to be a valid geometry, while preserving as much as
            possible of the shape and location of the input.
            Validity is determined according to <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>.
            <para/>
            Input geometries are always processed, so even valid inputs may
            have some minor alterations.The output is always a new geometry object.
            <h2>Semantic Rules</h2>
            <list type="number">
            <item><description>Vertices with non-finite X or Y ordinates are removed (as per <see cref="P:NetTopologySuite.Geometries.Coordinate.IsValid"/>)</description></item>
            <item><description>Repeated points are reduced to a single point</description></item>
            <item><description>Empty atomic geometries are valid and are returned unchanged</description></item>
            <item><description>Empty elements are removed from collections</description></item>
            <item><description><c>Point</c>: keep valid coordinate, or EMPTY</description></item>
            <item><description><c>LineString</c>: coordinates are fixed</description></item>
            <item><description><c>LinearRing</c>: coordinates are feixed, keep valid ring or else convert into <c>LineString</c></description></item>
            <item><description><c>Polygon</c>: transform into a valid polygon, 
            preserving as much of the extent and vertices as possible.
            <list type="bullet">
            <item><description>Rings are fixed to ensure they are valid</description></item>
            <item><description>Holes intersection the shell are subtracted from the shell</description></item>
            <item><description>Holes outside the shell are converted into polygons</description></item>
            </list></description></item>
            <item><description><c>MultiPolygon</c>: each polygon is fixed, 
            then result made non - overlapping (via union)</description></item>
            <item><description><c>GeometryCollection</c>: each element is fixed</description></item>
            <item><description>Collapsed lines and polygons are handled as follows,
            depending on the <c>keepCollapsed</c> setting:
            <list type="bullet">
            <item><description><c>false</c>: (default) collapses are converted to empty geometries
            (and removed if they are elements of collections)</description></item>
            <item><description><c>true</c>: collapses are converted to a valid geometry of lower dimension</description></item>
            </list></description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
            <seealso cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.Fix(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Fixes a geometry to be valid.
            </summary>
            <param name="geom">The geometry to be fixed</param>
            <returns>The valid fixed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.Fix(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Fixes a geometry to be valid, allowing to set a flag controlling how
            single item results from fixed <c>MULTI</c> geometries should be
            returned.
            </summary>
            <param name="geom">The geometry to be fixed</param>
            <param name="isKeepMulti">A flag indicating if <c>MULTI</c> geometries should not
            be converted to single instance types if they consist of only one item.</param>
            <returns>The valid fixed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>Creates a new instance to fix a given geometry</summary>
            <param name="geom">The geometry to be fixed</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryFixer.KeepCollapsed">
            <summary>
            Gets or sets a value indicating whether collapsed
            geometries are converted to empty,
            (which will be removed from collections),
            or to a valid geometry of lower dimension.
            The default is to convert collapses to empty geometries (<c>false</c>).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryFixer.KeepMulti">
            <summary>
            Gets or sets a value indicating whether collapsed
            geometries are converted to empty,
            (which will be removed from collections),
            or to a valid geometry of lower dimension.
            The default is to convert collapses to empty geometries (<c>false</c>).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.GetResult">
            <summary>
            Gets the fixed geometry.
            </summary>
            <returns>The fixed geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.FixCoordinates(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Returns a clean copy of the input coordinate array.
            </summary>
            <param name="pts">Coordinates to clean</param>
            <returns>An array of clean coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.Difference(NetTopologySuite.Geometries.Geometry,System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry})">
            <summary>Subtracts a list of polygonal geometries from a polygonal geometry.</summary>
            <param name="shell">polygonal geometry for shell</param>
            <param name="holes">polygonal geometries for holes</param>
            <returns>The result geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryFixer.Union(System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Unions a list of polygonal geometries.
            Optimizes case of zero or one input geometries.
            Requires that the inputs are net new objects.
            </summary>
            <param name="polys">The polygonal geometries to union</param>
            <returns>The union of the inputs</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryMapper">
            <summary>
            Methods to map various collections
            of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            via defined mapping functions.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.Map(NetTopologySuite.Geometries.Geometry,System.Func{NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry})">
            <summary>
            Maps the members of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            (which may be atomic or composite)
            into another <tt>Geometry</tt> of most specific type.
            <tt>null</tt> results are skipped.
            In the case of hierarchical <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s,
            only the first level of members are mapped.
            </summary>
            <param name="geom">The input atomic or composite geometry</param>
            <param name="op">The mapping operation delegate</param>
            <returns>A result collection or geometry of most specific type</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.Map(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp)">
            <summary>
            Maps the members of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            (which may be atomic or composite)
            into another <tt>Geometry</tt> of most specific type.
            <tt>null</tt> results are skipped.
            In the case of hierarchical <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s,
            only the first level of members are mapped.
            </summary>
            <param name="geom">The input atomic or composite geometry</param>
            <param name="op">The mapping operation</param>
            <returns>A result collection or geometry of most specific type</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.FlatMap(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp)">
            <summary>
            Maps the atomic elements of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            (which may be atomic or composite)
            using a <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp"/> mapping operation
            into an atomic <tt>Geometry</tt> or a flat collection
            of the most specific type.
            <tt>null</tt> and empty values returned from the mapping operation
            are discarded.
            </summary>
            <param name="geom">The geometry to map</param>
            <param name="emptyDim">The dimension of empy geometry to create</param>
            <param name="op">The mapping operation</param>
            <returns>The mapped result</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp">
            <summary>
            An interface for geometry functions used for mapping.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp.Map(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a new geometry value.
            </summary>
            <param name="g">The input geometry</param>
            <returns>A result geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp">
            <summary>
            Standard implementation of a geometry mapping 
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp.#ctor(System.Func{NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry})">
            <summary>
            Creates an instance of this class using the provided mapping operation function
            </summary>
            <param name="mapOp">A mapping operation function</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp.Map(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a new geometry value.
            </summary>
            <param name="g">The input geometry</param>
            <returns>A result geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer">
            <summary>
            A framework for processes which transform an input <c>Geometry</c> into
            an output <see cref="T:NetTopologySuite.Geometries.Geometry"/>, possibly changing its structure and type(s).
            </summary>
            <remarks>
            <para>
            This class is a framework for implementing subclasses
            which perform transformations on
            various different Geometry subclasses.
            </para>
            <para>
            It provides an easy way of applying specific transformations
            to given point types, while allowing unhandled types to be simply copied.
            Also, the framework handles ensuring that if subcomponents change type
            the parent geometries types change appropriately to maintain valid structure.
            Subclasses will override whichever <c>TransformX</c> methods
            they need to to handle particular Geometry types.
            </para>
            <para>
            A typically usage would be a transformation that may transform <c>Polygons</c> into
            <c>Polygons</c>, <c>LineStrings</c> or <c>Points</c>, depending on the geometry of the input
            (For instance, a simplification operation).
            This class would likely need to override the <see cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)"/>
            method to ensure that if input Polygons change type the result is a <c>GeometryCollection</c>,
            not a <c>MultiPolygon</c>.</para>
            <para>
            The default behaviour of this class is simply to recursively transform
            each Geometry component into an identical object by deep copying down
            to the level of, but not including, coordinates.
            </para>
            <para>
            Note that all <c>Transform<i>XXX</i></c> methods may return <c>null</c>,
            to avoid creating empty point objects. This will be handled correctly
            by the transformer. <c>Transform<i>XXX</i></c> methods should always return valid
            geometry - if they cannot do this they should return <c>null</c>
            (for instance, it may not be possible for a transformLineString implementation
            to return at least two points - in this case, it should return <c>null</c>).
            The <see cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.Transform(NetTopologySuite.Geometries.Geometry)"/> method itself will always
            return a non-null Geometry object (but this may be empty).</para>
            </remarks>>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer.Factory">
            <summary>
            The geometry factory
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer.pruneEmptyGeometry">
            <summary>
            <c>true</c> if empty geometries should not be included in the result.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer.preserveGeometryCollectionType">
            <summary>
            <c>true</c> if a homogenous collection result
            from a <c>GeometryCollection</c> should still
            be a general GeometryCollection.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer._preserveType">
            <summary>
            <c>true</c> if the type of the input should be preserved.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometryTransformer.InputGeometry">
            <summary>
            Makes the input geometry available
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.Transform(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="inputGeom"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.CreateCoordinateSequence(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Convenience method which provides standard way of
            creating a <c>CoordinateSequence</c>.
            </summary>
            <param name="coords">The coordinate array to copy.</param>
            <returns>A coordinate sequence for the array.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.Copy(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Convenience method which provides a standard way of copying <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>s.
            </summary>
            <param name="seq">The sequence to copy.</param>
            <returns>A deep copy of the sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            This method should always return a valid coordinate list for
            the desired result type.  (E.g. a coordinate list for a LineString
            must have 0 or at least 2 points).
            If this is not possible, return an empty sequence -
            this will be pruned out.
            </summary>
            <param name="coords">The coordinates to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>The transformed coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformPoint(NetTopologySuite.Geometries.Point,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.Point"/> geometry.
            </summary>
            <param name="geom">The <c>Point</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>Point</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiPoint(NetTopologySuite.Geometries.MultiPoint,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> geometry.
            </summary>
            <param name="geom">The <c>MultiPoint</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>MultiPoint</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformLinearRing(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.LinearRing"/>.
            <para/>
            The transformation of a <c>LinearRing</c> may result in a coordinate sequence
            which does not form a structurally valid ring (i.e. a degenerate ring of 3 or fewer points).
            In this case a <c>LineString</c> is returned.
            Subclasses may wish to override this method and check for this situation
            (e.g.a subclass may choose to eliminate degenerate linear rings)
            </summary>
            <param name="geom">The <c>LinearRing</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>
            A <c>LinearRing</c> if the transformation resulted in a structurally valid ring, otherwise,
            if the transformation caused the LinearRing to collapse to 3 or fewer points, a <c>LineString</c>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformLineString(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.LineString"/> geometry.
            </summary>
            <param name="geom">The <c>LineString</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>LineString</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiLineString(NetTopologySuite.Geometries.MultiLineString,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> geometry.
            </summary>
            <param name="geom">The <c>MultiLineString</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>MultiLineString</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.Polygon"/> geometry.
            </summary>
            <param name="geom">The <c>Polygon</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>Polygon</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> geometry.
            </summary>
            <param name="geom">The <c>MultiPolygon</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>MultiPolygon</c></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformGeometryCollection(NetTopologySuite.Geometries.GeometryCollection,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Transforms a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> geometry.
            </summary>
            <param name="geom">The <c>GeometryCollection</c> to transform</param>
            <param name="parent">The parent geometry</param>
            <returns>A <c>GeometryCollection</c></returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter">
            <summary>
            Extracts all the 1-dimensional (<see cref="T:NetTopologySuite.Geometries.LineString"/>) components from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            For polygonal geometries, this will extract all the component <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s.
            If desired, <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s can be forced to be returned as <see cref="T:NetTopologySuite.Geometries.LineString"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines``1(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},``0)">
            <summary>
            Extracts the linear components from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            and adds them to the provided <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geoms">The geometry from which to extract linear components</param>
            <param name="lines">The Collection to add the extracted linear components to</param>
            <returns>The Collection of linear components (LineStrings or LinearRings)</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines``1(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},``0,System.Boolean)">
            <summary>
            Extracts the linear components from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            and adds them to the provided <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geoms">The geometry from which to extract linear components</param>
            <param name="lines">The Collection to add the extracted linear components to</param>
            <param name="forceToLineString"></param>
            <returns>The Collection of linear components (LineStrings or LinearRings)</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines``1(NetTopologySuite.Geometries.Geometry,``0)">
            <summary>
            Extracts the linear components from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and adds them to the provided <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract linear components</param>
            <param name="lines">The Collection to add the extracted linear components to</param>
            <returns>The Collection of linear components (LineStrings or LinearRings)</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines``1(NetTopologySuite.Geometries.Geometry,``0,System.Boolean)">
            <summary>
            Extracts the linear components from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and adds them to the provided <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract linear components</param>
            <param name="lines">The Collection to add the extracted linear components to</param>
            <param name="forceToLineString"></param>
            <returns>The Collection of linear components (LineStrings or LinearRings)</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the linear components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>LineExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom">The point from which to extract linear components.</param>
            <returns>The list of linear components.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetLines(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Extracts the linear components from a single geometry.
            If more than one geometry is to be processed, it is more
            efficient to create a single <see cref="T:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter"/> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom">The geometry from which to extract linear components</param>
            <param name="forceToLineString"><c>true</c> if <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s should be converted to <see cref="T:NetTopologySuite.Geometries.LineString"/>s</param>
            <returns>The list of linear components</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetGeometry(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the linear components from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and returns them as either a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <returns>A linear geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.GetGeometry(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Extracts the linear components from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and returns them as either a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="forceToLineString"><c>true</c> if <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s should be converted to <see cref="T:NetTopologySuite.Geometries.LineString"/>s</param>
            <returns>A linear geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
            <param name="lines"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},System.Boolean)">
            <summary>
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
            <param name="lines"></param>
            <param name="isForcedToLineString"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.IsForcedToLineString">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.LineStringExtracter">
            <summary>
            Extracts all the <see cref="T:NetTopologySuite.Geometries.LineString"/> elements from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryExtracter"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LineStringExtracter.GetLines``1(NetTopologySuite.Geometries.Geometry,``0)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.LineString"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and adds them to the<see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="lines">The list to add the extracted elements to</param>
            <returns>The <paramref name="lines"/> list argument</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LineStringExtracter.GetLines(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.LineString"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and returns them in a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <returns>A list containing the linear elements</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LineStringExtracter.GetGeometry(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.LineString"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            and returns them as either a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <returns>A linear geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LineStringExtracter.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a filter with a list in which to store the elements found.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.Matrix">
            <summary>
            Implements some 2D matrix operations (in particular, solving systems of linear equations).
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.Matrix.Solve(System.Double[][],System.Double[])">
            <summary>
            Solves a system of equations using Gaussian Elimination.<br/>
            In order to avoid overhead the algorithm runs in-place
            on A - if A should not be modified the client must supply a copy.
            </summary>
            <param name="a">A an nxn matrix in row/column order )modified by this method)</param>
            <param name="b">A vector of length n</param>
            <exception cref="T:System.ArgumentException">if the matrix is the wrong size</exception>
            <returns>
            <list type="bullet">
            <item><description>A vector containing the solution (if any)</description></item>
            <item><description><c>null</c> if the system has no or no unique solution</description></item>
            </list>
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException">
            <summary>
            Indicates that an <see cref="T:NetTopologySuite.Geometries.Utilities.AffineTransformation"/> is non-invertible.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.PointExtracter">
            <summary>
            Extracts all the 0-dimensional (<c>Point</c>) components from a <c>Geometry</c>.
            </summary>
            <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryExtracter"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PointExtracter.GetPoints``1(NetTopologySuite.Geometries.Geometry,``0)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.Point"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> and adds them to the provided <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="list">The list to add the extracted elements to</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PointExtracter.GetPoints(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.Point"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> and returns them in a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="geom">the geometry from which to extract</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PointExtracter.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a PointExtracterFilter with a list in which to store Points found.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PointExtracter.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.PolygonExtracter">
            <summary>
            Extracts all the <see cref="T:NetTopologySuite.Geometries.Polygon"/> elements from a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryExtracter"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PolygonExtracter.GetPolygons(NetTopologySuite.Geometries.Geometry,System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.Polygon"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> and adds them to the provided <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
            <param name="list">The list to add the extracted elements to</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PolygonExtracter.GetPolygons(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the <see cref="T:NetTopologySuite.Geometries.Polygon"/> elements from a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> and returns them in a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="geom">The geometry from which to extract</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PolygonExtracter.#ctor(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a PolygonExtracterFilter with a list in which to store Polygons found.
            </summary>
            <param name="comps"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.PolygonExtracter.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor">
            <summary>
            A visitor to <see cref="T:NetTopologySuite.Geometries.Geometry"/> elements which  components, which
            allows short-circuiting when a defined condition holds.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.ApplyTo(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.Visit(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="element"></param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.IsDone">
            <summary>
            Reports whether visiting components can be terminated.
            Once this method returns <see langword="true"/>, it must
            continue to return <see langword="true"/> on every subsequent call.
            </summary>
            <returns>
            <see langword="true"/> if visiting can be terminated.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.SineStarFactory">
            <summary>
            Creates geometries which are shaped like multi-armed stars with each arm shaped like a sine wave.
            These kinds of geometries are useful as a more complex geometry for testing algorithms.
            </summary>
            <author>
            Martin Davis
            </author>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory.Create(NetTopologySuite.Geometries.Coordinate,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Creates a sine star with the given parameters.
            </summary>
            <param name="origin">The origin point.</param>
            <param name="size">The size of the star.</param>
            <param name="nPts">The number of points in the star.</param>
            <param name="nArms">The number of arms to generate.</param>
            <param name="armLengthRatio">The arm length ratio.</param>
            <returns>A sine star shape.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory.#ctor">
            <summary>
            Creates a factory which will create sine stars using the default <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a factory which will create sine stars using the given <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            </summary>
            <param name="geomFact">The factory to use</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.SineStarFactory.NumArms">
            <summary>Gets/Sets the number of arms in the star</summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.SineStarFactory.ArmLengthRatio">
            <summary>
            Gets or sets the ratio of the length of each arm to the radius of the star.
            A smaller number makes the arms shorter.
            </summary>
            <remarks>Value should be between 0.0 and 1.0</remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory.CreateSineStar">
            <summary>
            Generates the geometry for the sine star
            </summary>
            <returns>The geometry representing the sine star</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Depth">
            <summary>
            A Depth object records the topological depth of the sides
            of an Edge for up to two Geometries.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Depth.null">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.DepthAtLocation(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="_location"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.GetDepth(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.GetDepth(System.Int32,NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.SetDepth(System.Int32,NetTopologySuite.GeometriesGraph.Positions,System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="depthValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.SetDepth(System.Int32,NetTopologySuite.Geometries.Position,System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="depthValue"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Depth.Item(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Calls GetDepth and SetDepth.
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.GetLocation(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.GetLocation(System.Int32,NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.Add(System.Int32,NetTopologySuite.GeometriesGraph.Positions,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.IsNull">
            <summary>
            A Depth object is null (has never been initialized) if all depths are null.
            </summary>
            <returns><c>true</c> if depth is null (has never been initialized)</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.IsNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.IsNull(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.IsNull(System.Int32,NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.Add(NetTopologySuite.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="lbl"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.GetDelta(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.Normalize">
            <summary>
            Normalize the depths for each point, if they are non-null.
            A normalized depth
            has depth values in the set { 0, 1 }.
            Normalizing the depths
            involves reducing the depths by the same amount so that at least
            one of them is 0.  If the remaining value is > 0, it is set to 1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.DirectedEdge">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.DepthFactor(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Computes the factor for the change in depth when moving from one location to another.
            E.g. if crossing from the <see cref="F:NetTopologySuite.Geometries.Location.Interior"/> to the <see cref="F:NetTopologySuite.Geometries.Location.Exterior"/>
            the depth decreases, so the factor is -1.
            </summary>
            <param name="currLocation">The current location</param>
            <param name="nextLocation">The next location</param>
            <returns>Change of depth moving from <paramref name="currLocation"/> to <paramref name="nextLocation"/></returns>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.DirectedEdge._depth">
            <summary>
            The depth of each side (position) of this edge.
            The 0 element of the array is never used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.#ctor(NetTopologySuite.GeometriesGraph.Edge,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="isForward"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.InResult">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.IsInResult">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.Visited">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.IsVisited">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.EdgeRing">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.MinEdgeRing">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.GetDepth(NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="position"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.GetDepth(NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="position"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.SetDepth(NetTopologySuite.GeometriesGraph.Positions,System.Int32)">
             <summary>
            
             </summary>
             <param name="position"></param>
             <param name="depthVal"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.SetDepth(NetTopologySuite.Geometries.Position,System.Int32)">
            <summary>
            Set depth for a position
            </summary>
            <param name="position">The position to update</param>
            <param name="depthVal">The depth at the provided position</param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.DepthDelta">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.VisitedEdge">
            <summary>
            Gets or sets a value indicating if both Visited
            and Sym.Visited are <c>true</c>.
            <para/>
            Setting the property marks both DirectedEdges attached to a given Edge.
            <para/>
            This is used for edges corresponding to lines, which will only
            appear oriented in a single direction in the result.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.IsForward">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.Sym">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.Next">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.NextMin">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.IsLineEdge">
            <summary>
            Gets a value indicating if this edge is a line edge.
            <para/>It is if
            <list type="bullet">
            <item><description>at least one of the labels is a line label</description></item>
            <item><description>any labels which are not line labels have all Location = Exterior.</description></item>
            </list>
            </summary>
            <returns><c>true</c> if edge is a line edge</returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge.IsInteriorAreaEdge">
            <summary>
            This is an interior Area edge if
            its label is an Area label for both Geometries
            and for each Geometry both sides are in the interior.
            </summary>
            <returns><c>true</c> if this is an interior Area edge.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.ComputeDirectedLabel">
            <summary>
            Compute the label in the appropriate orientation for this DirEdge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.SetEdgeDepths(NetTopologySuite.GeometriesGraph.Positions,System.Int32)">
            <summary>
            Set both edge depths.
            One depth for a given side is provided.
            The other is computed depending on the Location
            transition and the depthDelta of the edge.
            </summary>
            <param name="position">The position to update</param>
            <param name="depth">The depth at the provided position</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.SetEdgeDepths(NetTopologySuite.Geometries.Position,System.Int32)">
            <summary>
            Set both edge depths.
            One depth for a given side is provided.
            The other is computed depending on the Location
            transition and the depthDelta of the edge.
            </summary>
            <param name="position">The position to update</param>
            <param name="depth">The depth at the provided position</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge.WriteEdge(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.DirectedEdgeStar">
            <summary>
            A DirectedEdgeStar is an ordered list of outgoing DirectedEdges around a node.
            It supports labelling the edges as well as linking the edges to form both
            MaximalEdgeRings and MinimalEdgeRings.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.DirectedEdgeStar._resultAreaEdgeList">
            <summary>
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a directed edge in the list.
            </summary>
            <param name="ee"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.Label">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree(NetTopologySuite.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="er"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.GetRightmostEdge">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.ComputeLabelling(NetTopologySuite.GeometriesGraph.GeometryGraph[])">
            <summary>
            Compute the labelling for all dirEdges in this star, as well
            as the overall labelling.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.MergeSymLabels">
            <summary>
            For each dirEdge in the star, merge the label .
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.UpdateLabelling(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Update incomplete dirEdge labels from the labeling for the node.
            </summary>
            <param name="nodeLabel">The label to apply</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.GetResultAreaEdges">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.LinkResultDirectedEdges">
            <summary>
            Traverse the star of DirectedEdges, linking the included edges together.
            To link two dirEdges, the next pointer for an incoming dirEdge
            is set to the next outgoing edge.
            DirEdges are only linked if:
            they belong to an area (i.e. they have sides)
            they are marked as being in the result
            Edges are linked in CCW order (the order they are stored).
            This means that rings have their face on the Right
            (in other words, the topological location of the face is given by the RHS label of the DirectedEdge).
            PRECONDITION: No pair of dirEdges are both marked as being in the result.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.LinkMinimalDirectedEdges(NetTopologySuite.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="er"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.LinkAllDirectedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.FindCoveredLineEdges">
            <summary>
            Traverse the star of edges, maintaining the current location in the result
            area at this node (if any).
            If any L edges are found in the interior of the result, mark them as covered.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.ComputeDepths(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.ComputeDepths(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute the DirectedEdge depths for a subsequence of the edge array.
            </summary>
            <returns>The last depth assigned (from the R side of the last edge visited).</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.UpdateIM(NetTopologySuite.GeometriesGraph.Label,NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Updates an IM from the label for an edge.
            Handles edges from both L and A geometries.
            </summary>
            <param name="im">An intersection matrix</param>
            <param name="label">A label</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.#ctor(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="label"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.#ctor(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Points">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Name">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.DepthDelta">
            <summary>
            The depthDelta is the change in depth as an edge is crossed from R to L.
            </summary>
            <returns>The change in depth as the edge is crossed from R to L.</returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.MaximumSegmentIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.EdgeIntersectionList">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.MonotoneChainEdge">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.IsCollapsed">
            <summary>
            An Edge is collapsed if it is an Area edge and it consists of
            two segments which are equal and opposite (eg a zero-width V).
            </summary>
            <returns><c>true</c> if edge is consisting of two segments
            which are equal and of oppose orientation (Zero-width V area edge)
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.CollapsedEdge">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.Isolated">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge.IsIsolated">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.AddIntersections(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
            <param name="li">A line intersector</param>
            <param name="segmentIndex">A segment index</param>
            <param name="geomIndex">A geometry index</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.AddIntersection(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an EdgeIntersection for intersection intIndex.
            An intersection that falls exactly on a vertex of the edge is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li">A line intersector</param>
            <param name="segmentIndex">A segment index</param>
            <param name="geomIndex">A geometry index</param>
            <param name="intIndex">The intersection index (0 or 1)</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.ComputeIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.Equals(System.Object)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            if
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.Equals(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            if
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.op_Equality(NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.op_Inequality(NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.IsPointwiseEqual(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Check if coordinate sequences of the Edges are identical. 
            </summary>
            <param name="e">The edge to test</param>
            <returns>
            <c>true</c> if the coordinate sequences of the Edges are identical.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.Write(System.IO.TextWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge.WriteReverse(System.IO.TextWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeEnd">
            <summary>
            Models the end of an edge incident on a node.
            </summary>
            <remarks>
            <para>
            EdgeEnds have a direction determined by the direction of the ray from the initial
            point to the next point.
            </para>
            <para>
            EdgeEnds are IComparable under the ordering  "a has a greater angle with the x-axis than b".
            This ordering is used to sort EdgeEnds around a node.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeEnd._label">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.#ctor(NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="edge"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.#ctor(NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.#ctor(NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="label"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.Init(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Label">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.DirectedCoordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Quadrant">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.QuadrantEx">
            <summary>
            Gets a value indicating the <c>Quadrant</c> this <c>EdgeEnd</c> lies in.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Dx">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Dy">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEnd.Node">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.CompareTo(NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.CompareDirection(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Implements the total order relation:
            a has a greater angle with the positive x-axis than b.
            <para/>
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is obviously susceptible to round off.
            <para/>
            A robust algorithm is:
            <list type="bullet">
            <item><description>first compare the quadrant.  If the quadrants
            are different, it it trivial to determine which vector is "greater".</description></item>
            <item><description>if the vectors lie in the same quadrant, the computeOrientation function
            can be used to decide the relative orientation of the vectors.</description></item>
            </list>
            </summary>
            <param name="e">An EdgeEnd</param>
            <returns>The <see cref="T:NetTopologySuite.Algorithm.OrientationIndex"/> of <paramref name="e"/> compared to <c>this</c> <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.ComputeLabel(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Subclasses should override this if they are using labels
            </summary>
            <param name="boundaryNodeRule"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeEndStar">
            <summary>
            A EdgeEndStar is an ordered list of EdgeEnds around a node.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeEndStar.edgeMap">
            <summary>
            A map which maintains the edges in sorted order around the node.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeEndStar.edgeList">
            <summary>
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeEndStar._ptInAreaLocation">
            <summary>
            The location of the point for this star in Geometry i Areas.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a EdgeEnd into this EdgeEndStar.
            </summary>
            <param name="e">An <c>EdgeEnd</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.InsertEdgeEnd(NetTopologySuite.GeometriesGraph.EdgeEnd,NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert an EdgeEnd into the map, and clear the edgeList cache,
            since the list of edges has now changed.
            </summary>
            <param name="e">An EdgeEnd</param>
            <param name="obj">An EdgeEnd</param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEndStar.Coordinate">
            <returns>
            The coordinate for the node this star is based at.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEndStar.Degree">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.GetEnumerator">
            <summary>
            Iterator access to the ordered list of edges is optimized by
            copying the map collection to a list.  (This assumes that
            once an iterator is requested, it is likely that insertion into
            the map is complete).
            </summary>
            <returns>Access to ordered list of edges.</returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEndStar.Edges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.GetNextCW(NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="ee"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.ComputeLabelling(NetTopologySuite.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.ComputeEdgeEndLabels(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.GetLocation(System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="p"></param>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.IsAreaLabelsConsistent(NetTopologySuite.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.CheckAreaLabelsConsistent(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.PropagateSideLabels(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.FindIndex(NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="eSearch"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeIntersection">
            <summary>
            An EdgeIntersection represents a point on an
            edge which intersects with another edge.
            The intersection may either be a single point, or a line segment
            (in which case this point is the start of the line segment)
            The label attached to this intersection point applies to
            the edge from this point forwards, until the next
            intersection or the end of the edge.
            The intersection point must be precise.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection.Coordinate">
            <summary>
            The point of intersection.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection.SegmentIndex">
            <summary>
            The index of the containing line segment in the parent edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection.Distance">
            <summary>
            The edge distance of this point along the containing line segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.#ctor(NetTopologySuite.Geometries.Coordinate,System.Int32,System.Double)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="coord">The point of intersection</param>
            <param name="segmentIndex">The index of the containing line segment in the parent edge</param>
            <param name="dist">The edge distance or this point along the containing line segment</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.Compare(System.Int32,System.Double)">
            <summary>
            Comparison with segment and distance.
            </summary>
            <param name="segmentIndex">The index of the containing line segment</param>
            <param name="dist">The distance of this point along the containing line segment</param>
            <returns>
            <c>-1</c> this EdgeIntersection is located before the argument location,
            <c>0</c> this EdgeIntersection is at the argument location,
            <c>1</c> this EdgeIntersection is located after the argument location.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.IsEndPoint(System.Int32)">
             <summary>
            
             </summary>
             <param name="maxSegmentIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList">
            <summary>
            A list of edge intersections along an Edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.#ctor(NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="edge"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.Count">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.Add(NetTopologySuite.Geometries.Coordinate,System.Int32,System.Double)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt">The point of intersection</param>
            <param name="segmentIndex">The index of the containing line segment in the parent edge</param>
            <param name="dist">The edge distance of this point along the containing line segment</param>
            <returns>The EdgeIntersection found or added.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.GetEnumerator">
            <summary>
            Returns an iterator of EdgeIntersections.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.IsIntersection(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.AddEndpoints">
            <summary>
            Adds entries for the first and last points of the edge to the list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.AddSplitEdges(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the input list (this is so a single list
            can be used to accumulate all split edges for a Geometry).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.CreateSplitEdge(NetTopologySuite.GeometriesGraph.EdgeIntersection,NetTopologySuite.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeList">
            <summary>
            A EdgeList is a list of Edges.  It supports locating edges
            that are point-wise equals to a target edge.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeList._ocaMap">
            <summary>
            An index of the edges, for fast lookup.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.Remove(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Remove the selected Edge element from the list if present.
            </summary>
            <param name="e">Edge element to remove from list</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.Add(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Insert an edge unless it is already in the list.
            </summary>
            <param name="e">An <c>Edge</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.AddAll(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edgeColl"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeList.Edges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.FindEqualEdge(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            If there is an edge equal to e already in the list, return it.
            Otherwise return null.
            </summary>
            <param name="e">An <c>Edge</c></param>
            <returns>
            The equal edge, if there is one already in the list,
            <c>null</c> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeList.Item(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.Get(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.FindEdgeIndex(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            If the edge e is already in the list, return its index.
            </summary>
            <param name="e">An <c>Edge</c></param>
            <returns>
            The index, if e is already in the list,
            <c>-1</c> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeNodingValidator">
            <summary>
            Validates that a collection of <see cref="T:NetTopologySuite.GeometriesGraph.Edge"/> is correctly noded.
            Throws an appropriate exception if an noding error is found.
            <remarks>
            Uses <see cref="T:NetTopologySuite.Noding.FastNodingValidator"/> to perform the validation.
            </remarks>
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeNodingValidator.CheckValid(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Checks whether the supplied <see cref="T:NetTopologySuite.GeometriesGraph.Edge"/>s are correctly noded.
            </summary>
            <param name="edges">an enumeration of Edges.</param>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If the SegmentStrings are not correctly noded</exception>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeNodingValidator.ToSegmentStrings(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Builds an enumeration of segment strings from the provided <paramref name="edges"/>.
            </summary>
            <param name="edges">An enumeration of <c>Edge</c>s</param>
            <returns>An enumeration of <c>ISegmentString</c>s</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeNodingValidator.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Creates a new validator for the given collection of <see cref="T:NetTopologySuite.GeometriesGraph.Edge"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeNodingValidator.CheckValid">
            <summary>
            Checks whether the supplied edges are correctly noded.
            </summary>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If the SegmentStrings are not correctly noded</exception>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeRing">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeRing.startDe">
            <summary>
            The directed edge which starts the list of edges for this EdgeRing.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.GeometryFactory">
            <summary>
            A <c>GeometryFactory</c> to use.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.#ctor(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an instance of this class using the provided <paramref name="start"/> and <paramref name="geometryFactory"/>.
            </summary>
            <param name="start">The start <c>DirectedEdge</c> for the <c>EdgeRing</c> </param>
            <param name="geometryFactory">A <c>GeometryFactory</c></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.IsIsolated">
            <summary>
            Gets a value indicating if this <c>EdgeRing</c> is isolated
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.IsHole">
            <summary>
            Gets a value indicating if this <c>EdgeRing</c> is a hole of a <c>Polygon</c>
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.GetCoordinate(System.Int32)">
            <summary>
            Access a <c>Coordinate</c> of this <c>EdgeRing</c> by its index.
            </summary>
            <param name="i">The index of the <c>Coordinate</c></param>
            <returns>The <c>Coordinate</c> at index <paramref name="i"/></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.LinearRing">
            <summary>
            Gets the geometry representation of this <c>EdgeRing</c>
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.Label">
            <summary>
            Gets a value indicating the topological relationship of this <c>EdgeRing</c>
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.IsShell">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.Shell">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.AddHole(NetTopologySuite.GeometriesGraph.EdgeRing)">
            <summary>
            Add an <c>EdgeRing</c> representing a hole
            </summary>
            <param name="ring">The ring to add</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.ToPolygon(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create the <c>Polygon</c> described by this <c>EdgeRing</c>
            </summary>
            <param name="geometryFactory">The <c>GeometryFactory</c> to use.</param>
            <returns>A <c>Polygon</c></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.ComputeRing">
            <summary>
            Compute a LinearRing from the point list previously collected.
            Test if the ring is a hole (i.e. if it is CCW) and set the hole flag
            accordingly.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.GetNext(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.SetEdgeRing(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.Edges">
            <summary>
            Returns the list of DirectedEdges that make up this EdgeRing.
            </summary>
            <returns>A list of <c>DirectedEdge</c>s</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.ComputePoints(NetTopologySuite.GeometriesGraph.DirectedEdge)">
            <summary>
            Collect all the points from the DirectedEdges of this ring into a contiguous list.
            </summary>
            <param name="start"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing.MaxNodeDegree">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.ComputeMaxNodeDegree">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.SetInResult">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.MergeLabel(NetTopologySuite.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="deLabel"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.MergeLabel(NetTopologySuite.GeometriesGraph.Label,System.Int32)">
            <summary>
            Merge the RHS label from a DirectedEdge into the label for this EdgeRing.
            The DirectedEdge label may be null.  This is acceptable - it results
            from a node which is NOT an intersection node between the Geometries
            (e.g. the end node of a LinearRing).  In this case the DirectedEdge label
            does not contribute any information to the overall labelling, and is simply skipped.
            </summary>
            <param name="deLabel"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.AddPoints(NetTopologySuite.GeometriesGraph.Edge,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="isForward"></param>
             <param name="isFirstEdge"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing.ContainsPoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            This method will cause the ring to be computed.
            It will also check any holes, if they have been assigned.
            </summary>
            <param name="p">The point to test</param>
            <returns><c>true</c> if the ring contains point <paramref name="p"/></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.GeometryGraph">
            <summary>
            A GeometryGraph is a graph that models a given Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.DetermineBoundary(NetTopologySuite.Algorithm.IBoundaryNodeRule,System.Int32)">
            <summary>
            Determine boundary
            </summary>
            <param name="boundaryNodeRule">The boundary node rule to apply for determination of the boundary</param>
            <param name="boundaryCount">The number of component boundaries that a point occurs in.</param>
            <returns><see cref="F:NetTopologySuite.Geometries.Location.Boundary"/> or <see cref="F:NetTopologySuite.Geometries.Location.Interior"/></returns>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.GeometryGraph._lineEdgeMap">
            <summary>
            The lineEdgeMap is a map of the linestring components of the
            parentGeometry to the edges which are derived from them.
            This is used to efficiently perform findEdge queries
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.GeometryGraph._useBoundaryDeterminationRule">
            <summary>
            If this flag is true, the Boundary Determination Rule will used when deciding
            whether nodes are in the boundary or not
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.CreateEdgeSetIntersector">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.#ctor(System.Int32,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="parentGeom"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.#ctor(System.Int32,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="parentGeom"></param>
             <param name="boundaryNodeRule"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GeometryGraph.HasTooFewPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GeometryGraph.InvalidPoint">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GeometryGraph.Geometry">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GeometryGraph.BoundaryNodeRule">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> used with this geometry graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GeometryGraph.BoundaryNodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.GetBoundaryPoints">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.FindEdge(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.ComputeSplitEdges(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edgelist"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.Add(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddCollection(NetTopologySuite.Geometries.GeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddPoint(NetTopologySuite.Geometries.Point)">
            <summary>
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddPolygonRing(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Adds a polygon ring to the graph. Empty rings are ignored.
            The left and right topological location arguments assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged.
            </summary>
            <param name="lr"></param>
            <param name="cwLeft"></param>
            <param name="cwRight"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddPolygon(NetTopologySuite.Geometries.Polygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddLineString(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddEdge(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Add an Edge computed externally.  The label on the Edge is assumed
            to be correct.
            </summary>
            <param name="e">An <c>Edge</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddPoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Add a point computed externally.  The point is assumed to be a
            Point Geometry part, which has a location of INTERIOR.
            </summary>
            <param name="pt">A <c>Coordinate</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.ComputeSelfNodes(NetTopologySuite.Algorithm.LineIntersector,System.Boolean)">
            <summary>
            Compute self-nodes, taking advantage of the Geometry type to
            minimize the number of intersection tests.  (E.g. rings are
            not tested for self-intersection, since they are assumed to be valid).
            </summary>
            <param name="li">The <c>LineIntersector</c> to use.</param>
            <param name="computeRingSelfNodes">If <c>false</c>, intersection checks are optimized to not test rings for self-intersection.</param>
            <returns>The computed SegmentIntersector, containing information about the intersections found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.ComputeSelfNodes(NetTopologySuite.Algorithm.LineIntersector,System.Boolean,System.Boolean)">
            <summary>
            Compute self-nodes, taking advantage of the Geometry type to
            minimize the number of intersection tests.  (E.g.rings are
            not tested for self-intersection, since they are assumed to be valid).
            </summary >
            <param name="li">The <c>LineIntersector</c> to use</param>
            <param name="computeRingSelfNodes">If <c>false</c>, intersection checks are optimized to not test rings for self-intersection</param>
            <param name="isDoneIfProperInt">Short-circuit the intersection computation if a proper intersection is found</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.ComputeEdgeIntersections(NetTopologySuite.GeometriesGraph.GeometryGraph,NetTopologySuite.Algorithm.LineIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <param name="li"></param>
             <param name="includeProper"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.InsertPoint(System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="coord"></param>
             <param name="onLocation"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.InsertBoundaryPoint(System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds candidate boundary points using the current <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>.
            This is used to add the boundary
            points of dim-1 geometries (Curves/MultiCurves).
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddSelfIntersectionNodes(System.Int32)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.AddSelfIntersectionNode(System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Location)">
            <summary>
            Add a node for a self-intersection.
            If the node is a potential boundary node (e.g. came from an edge which
            is a boundary) then insert it as a potential boundary node.
            Otherwise, just add it as a regular node.
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
            <param name="loc"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> of the given <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in this geometry.
            </summary>
            <param name="pt">The point to test</param>
            <returns>
            The location of the point in the geometry
            </returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.GraphComponent">
            <summary>
            A GraphComponent is the parent class for the objects'
            that form a graph.  Each GraphComponent can carry a
            Label.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.GraphComponent._label">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent.#ctor(NetTopologySuite.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="label"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.Label">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.InResult">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsInResult">
            <summary>
            IsInResult indicates if this component has already been included in the result.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.Covered">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsCovered">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsCoveredSet">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.Visited">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsVisited">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.Coordinate">
             <summary>
            
             </summary>
             <returns>
             A coordinate in this component (or null, if there are none).
             </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent.ComputeIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Compute the contribution to an IM for this component.
            </summary>
            <param name="im">An <c>IntersectionMatrix</c></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsIsolated">
            <summary>
            An isolated component is one that does not intersect or touch any other
            component.  This is the case if the label has valid locations for
            only a single Geometry.
            </summary>
            <returns><c>true</c> if this component is isolated.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent.UpdateIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im">An <c>IntersectionMatrix</c></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector">
            <summary>
            An <c>EdgeSetIntersector</c> computes all the intersections between the
            edges in the set.  It adds the computed intersections to each edge
            they are found on.  It may be used in two scenarios:
            determining the internal intersections between a single set of edges
            determining the mutual intersections between two different sets of edges
            It uses a <c>SegmentIntersector</c> to compute the intersections between
            segments and to record statistics about what kinds of intersections were found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            Computes all self-intersections between edges in a set of edges,
            allowing client to choose whether self-intersections are computed.
            </summary>
            <param name="edges">A list of edges to test for intersections.</param>
            <param name="si">The <c>SegmentIntersector</c> to use</param>
            <param name="testAllSegments"><c>true</c> if self-intersections are to be tested as well.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            Computes all mutual intersections between two sets of edges.
            </summary>
            <param name="edges0">A set of edges</param>
            <param name="edges1">A set of edges</param>
            <param name="si">The <c>SegmentIntersector</c> to use</param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChain">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChain.#ctor(NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge,System.Int32)">
             <summary>
            
             </summary>
             <param name="mce"></param>
             <param name="chainIndex"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChain.ComputeIntersections(NetTopologySuite.GeometriesGraph.Index.MonotoneChain,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="mc"></param>
             <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge">
            <summary>
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other, and
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.#ctor(NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.StartIndexes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.GetMinX(System.Int32)">
             <summary>
            
             </summary>
             <param name="chainIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.GetMaxX(System.Int32)">
             <summary>
            
             </summary>
             <param name="chainIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersects(NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="mce"></param>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="chainIndex0"></param>
             <param name="mce"></param>
             <param name="chainIndex1"></param>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,System.Int32,NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,System.Int32,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start0"></param>
             <param name="end0"></param>
             <param name="mce"></param>
             <param name="start1"></param>
             <param name="end1"></param>
             <param name="ei"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.Overlaps(System.Int32,System.Int32,NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,System.Int32)">
            <summary>
            Tests whether the envelopes of two chain sections overlap (intersect).
            </summary>
            <returns><c>true</c> if the section envelopes overlap</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer">
            <summary>
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            <para>
            Specifically, a sequence of contiguous line segments
            is a monotone chain if all the vectors defined by the oriented segments
            lies in the same quadrant.
            </para><para>
            Monotone Chains have the following useful properties:
            the segments within a monotone chain will never intersect each other, and
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </para>
            <para>
            Note that due to the efficient intersection test, there is no need to limit the size
            of chains to obtain fast performance.
            </para>
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.GetChainStartIndices(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the startpoints (and endpoints) of all in monotone chains in this edge
            </summary>
            <param name="pts">An array of points</param>
            <returns>An array of startpoints (and endpoints) of monotone chains</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.OLDGetChainStartIndices(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.FindChainEnd(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Searches for the end of a <c>MonotoneChain</c>
            </summary>
            <param name="pts">An array of <c>Coordinate</c>s</param>
            <param name="start">The start index of the chain to find the end for</param>
            <returns>
            The index of the last point in the monotone chain.
            </returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector">
            <summary>
            Computes the intersection of line segments,
            and adds the intersection to the edges containing the segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsAdjacentSegments(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i1"></param>
             <param name="i2"></param>
             <returns></returns>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.NumTests">
            <summary>
            Testing only.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.#ctor(NetTopologySuite.Algorithm.LineIntersector,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="includeProper"></param>
             <param name="recordIsolated"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.SetBoundaryNodes(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Node},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Node})">
             <summary>
            
             </summary>
             <param name="bdyNodes0"></param>
             <param name="bdyNodes1"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsDoneIfProperInt">
            <summary>
            Sets a flag if the segment intersector is done when a proper intersection has been found.
            </summary>
            <remarks>Has no effect anymore.</remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsDone">
            <summary>
            Gets a value indicating that the segment intersector is finished.
            </summary>
            <remarks>Always returns <c>false</c></remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.ProperIntersectionPoint">
            <returns>
            The proper intersection point, or <c>null</c> if none was found.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.HasIntersection">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire Geometry, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the Geometry.
            </summary>
            <returns>Indicates a proper intersection with an interior to at least two line segments</returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this SegmentIntersector.
            </summary>
            <returns>Indicates a proper interior intersection</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsTrivialIntersection(NetTopologySuite.GeometriesGraph.Edge,System.Int32,NetTopologySuite.GeometriesGraph.Edge,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Note that closed edges require a special check for the point shared by the beginning
            and end segments.
            </summary>
            <param name="e0">An Edge</param>
            <param name="segIndex0">The segment index of <paramref name="e0"/></param>
            <param name="e1">Another Edge</param>
            <param name="segIndex1">The segment index of <paramref name="e1"/></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.AddIntersections(NetTopologySuite.GeometriesGraph.Edge,System.Int32,NetTopologySuite.GeometriesGraph.Edge,System.Int32)">
            <summary>
            This method is called by clients of the EdgeIntersector class to test for and add
            intersections for two segments of the edges being intersected.
            Note that clients (such as MonotoneChainEdges) may choose not to intersect
            certain pairs of segments for efficiency reasons.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPoint(NetTopologySuite.Algorithm.LineIntersector,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Node}[])">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="bdyNodes"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPointInternal(NetTopologySuite.Algorithm.LineIntersector,System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Node})">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="bdyNodes"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using the straightforward method of
            comparing all segments.
            This algorithm is too slow for production use, but is useful for testing purposes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersects(NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.GeometriesGraph.Edge,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            Performs a brute-force comparison of every segment in each Edge.
            This has n^2 performance, and is about 100 times slower than using
            monotone chains.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using an x-axis sweepline algorithm in conjunction with Monotone Chains.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            The use of MonotoneChains as the items in the index
            seems to offer an improvement in performance over a sweep-line alone.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.AddEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.AddEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge},System.Object)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.AddEdge(NetTopologySuite.GeometriesGraph.Edge,System.Object)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.PrepareEvents">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,NetTopologySuite.GeometriesGraph.Index.SweepLineEvent,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="ev0"></param>
             <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using a simple x-axis sweepline algorithm.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge},System.Object)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(NetTopologySuite.GeometriesGraph.Edge,System.Object)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.PrepareEvents">
            <summary>
            Because DELETE events have a link to their corresponding INSERT event,
            it is possible to compute exactly the range of events which must be
            compared to a given INSERT event object.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="si"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,NetTopologySuite.GeometriesGraph.Index.SweepLineEvent,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="ev0"></param>
             <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.#ctor(System.Object,System.Double,System.Object)">
            <summary>
            Creates an INSERT event.
            </summary>
            <param name="label">The edge set label for this object.</param>
            <param name="x">The event location</param>
            <param name="obj">the object being inserted</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.#ctor(System.Double,NetTopologySuite.GeometriesGraph.Index.SweepLineEvent)">
            <summary>
            Creates a DELETE event.
            </summary>
            <param name="x">The event location</param>
            <param name="insertEvent">The corresponding INSERT event</param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.IsInsert">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.IsDelete">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.InsertEvent">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.DeleteEventIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.Object">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            Events are ordered first by their x-value, and then by their eventType.
            Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SweepLineSegment">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.#ctor(NetTopologySuite.GeometriesGraph.Edge,System.Int32)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="ptIndex"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.MinX">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.MaxX">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.ComputeIntersections(NetTopologySuite.GeometriesGraph.Index.SweepLineSegment,NetTopologySuite.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="ss"></param>
             <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Label">
            <summary>
            A <c>Label</c> indicates the topological relationship of a component
            of a topology graph to a given <c>Geometry</c>.
            This class supports labels for relationships to two <c>Geometry</c>s,
            which is sufficient for algorithms for binary operations.
            Topology graphs support the concept of labeling nodes and edges in the graph.
            The label of a node or edge specifies its topological relationship to one or
            more geometries.  (In fact, since NTS operations have only two arguments labels
            are required for only two geometries).  A label for a node or edge has one or
            two elements, depending on whether the node or edge occurs in one or both of the
            input <c>Geometry</c>s.  Elements contain attributes which categorize the
            topological location of the node or edge relative to the parent
            <c>Geometry</c>; that is, whether the node or edge is in the interior,
            boundary or exterior of the <c>Geometry</c>.  Attributes have a value
            from the set <c>{Interior, Boundary, Exterior}</c>.  In a node each
            element has a single attribute <c>On</c>. For an edge each element has a
            triplet of attributes <c>Left, On, Right</c>.
            It is up to the client code to associate the 0 and 1 <c>TopologyLocation</c>s
            with specific geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.ToLineLabel(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Converts a Label to a Line label (that is, one with no side Location).
            </summary>
            <param name="label">Label to convert.</param>
            <returns>Label as Line label.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.Geometries.Location)">
            <summary>
            Construct a Label with a single location for both Geometries.
            Initialize the locations to Null.
            </summary>
            <param name="onLoc">A location value</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(System.Int32,NetTopologySuite.Geometries.Location)">
            <summary>
            Construct a Label with a single location for both Geometries.
            Initialize the location for the Geometry index.
            </summary>
            <param name="geomIndex">A geometry index, <c>0</c>, or <c>1</c>.</param>
            <param name="onLoc">A location value for <b>On</b></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for both Geometries to the given values.
            </summary>
            <param name="onLoc">A location value for <b>On</b></param>
            <param name="leftLoc">A location value for <b>Left</b></param>
            <param name="rightLoc">A location value for <b>Right</b></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(System.Int32,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for the given Geometry index.
            </summary>
            <param name="geomIndex">A geometry index, <c>0</c>, or <c>1</c>.</param>
            <param name="onLoc">A location value for <b>On</b></param>
            <param name="leftLoc">A location value for <b>Left</b></param>
            <param name="rightLoc">A location value for <b>Right</b></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Construct a Label with the same values as the argument Label.
            </summary>
            <param name="lbl">A <c>Label</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.Flip">
            <summary>
            Performs <see cref="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Flip"/> on both
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>s of this <c>Label</c>
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.GetLocation(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.GetLocation(System.Int32,NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.GetLocation(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetLocation(System.Int32,NetTopologySuite.GeometriesGraph.Positions,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetLocation(System.Int32,NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetLocation(System.Int32,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllLocations(System.Int32,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllLocationsIfNull(System.Int32,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllLocationsIfNull(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="_location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.Merge(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Merge this label with another one.
            Merging updates any null attributes of this label with the attributes from <paramref name="lbl"/>.
            </summary>
            <param name="lbl">The <c>Label</c> to merge</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetGeometryLocation(System.Int32,NetTopologySuite.GeometriesGraph.TopologyLocation)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="tl"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Label.GeometryCount">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsAnyNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsArea">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsArea(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsLine(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsEqualOnSide(NetTopologySuite.GeometriesGraph.Label,System.Int32)">
             <summary>
            
             </summary>
             <param name="lbl"></param>
             <param name="side"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.AllPositionsEqual(System.Int32,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.ToLine(System.Int32)">
            <summary>
            Converts one GeometryLocation to a Line location.
            </summary>
            <param name="geomIndex">The index of the <c>TopologyLocation</c> to convert (<c>0</c> or <c>1</c>)</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Node">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Node._coord">
            <summary>
            Only non-null if this node is precise.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.GeometriesGraph.EdgeEndStar)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="edges"></param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Node.Coordinate">
            <summary>
            Gets a value indicating the position of this 
            </summary>
            <returns>The position of this <c>Node</c></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Node.Edges">
            <summary>
            Gets a value indicating the <c>EdgeEndStar</c> of this <c>Node</c>
            </summary>
            <returns>The <c>EdgeEndStar</c> of this <c>Node</c></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.IsIncidentEdgeInResult">
            <summary>
            Tests whether any incident edge is flagged as
            being in the result.
            This test can be used to determine if the node is in the result,
            since if any incident edge is in the result, the node must be in the result as well.
            </summary>
            <returns><c>true</c> if any incident edge in the in the result
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Node.IsIsolated">
            <inheritdoc cref="P:NetTopologySuite.GeometriesGraph.GraphComponent.IsIsolated"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.ComputeIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <inheritdoc cref="M:NetTopologySuite.GeometriesGraph.GraphComponent.ComputeIM(NetTopologySuite.Geometries.IntersectionMatrix)"/>
            <remarks>
            Basic nodes do not compute IMs.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.Add(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Add the edge to the list of edges at this node.
            </summary>
            <param name="e">An <c>EdgeEnd</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.MergeLabel(NetTopologySuite.GeometriesGraph.Node)">
            <summary>
            Merges <paramref name="n"/>'s <see cref="P:NetTopologySuite.GeometriesGraph.GraphComponent.Label"/> with this <c>Node</c>'s <c>Label</c>.
            </summary>
            <param name="n">A <c>Node</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.MergeLabel(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            To merge labels for two nodes,
            the merged location for each LabelElement is computed.
            The location for the corresponding node LabelElement is set to the result,
            as long as the location is non-null.
            </summary>
            <param name="label">The <c>Label</c> to merge</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.SetLabel(System.Int32,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="onLocation"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.SetLabelBoundary(System.Int32)">
            <summary>
            Updates the label of a node to BOUNDARY,
            obeying the mod-2 boundaryDetermination rule.
            </summary>
            <param name="argIndex">An index for a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> (<c>0</c> or <c>1</c>)</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.ComputeMergedLocation(NetTopologySuite.GeometriesGraph.Label,System.Int32)">
            <summary>
            The location for a given eltIndex for a node will be one
            of { Null, Interior, Boundary }.
            A node may be on both the boundary and the interior of a point;
            in this case, the rule is that the node is considered to be in the boundary.
            The merged location is the maximum of the two input values.
            </summary>
            <param name="label2"></param>
            <param name="eltIndex"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.Write(System.IO.TextWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.NodeFactory">
            <summary>
            A Factory to create <see cref="T:NetTopologySuite.GeometriesGraph.Node"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeFactory.CreateNode(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            The basic node constructor does not allow for incident edges.
            </summary>
            <param name="coord">A <c>Coordinate</c></param>
            <returns>The created <c>Node</c></returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.NodeMap">
            <summary>
            A map of nodes, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.#ctor(NetTopologySuite.GeometriesGraph.NodeFactory)">
            <summary>
            Creates an instance of this class using the provided <see cref="T:NetTopologySuite.GeometriesGraph.NodeFactory"/>.
            </summary>
            <param name="nodeFact">A factory to create <c>Node</c>s</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.AddNode(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            This method expects that a node has a coordinate value.
            </summary>
            <param name="coord">A <c>Coordinate</c></param>
            <returns>The <c>Node</c> for the provided <c>Coordinate</c> <paramref name="coord"/></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.AddNode(NetTopologySuite.GeometriesGraph.Node)">
            <summary>
            Adds a <c>Node</c> to this <c>NodeMap</c>.
            If a <c>Node</c> with the same <see cref="P:NetTopologySuite.GeometriesGraph.Node.Coordinate"/>
            is already present in this <c>NodeMap</c>,
            their <see cref="P:NetTopologySuite.GeometriesGraph.GraphComponent.Label"/>s are merged.
            </summary>
            <param name="n">The <c>Node</c> to add</param>
            <returns>Either <paramref name="n"/> or a <c>Node</c> with merged <c>Label</c>s</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.Add(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Adds a node for the start point of this EdgeEnd
            (if one does not already exist in this map).
            Adds the EdgeEnd to the (possibly new) node.
            </summary>
            <param name="e">An <c>EdgeEnd</c></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.Find(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Searches for a <c>Node</c> at <paramref name="coord"/> position.
            </summary>
            <param name="coord">A <c>Coordinate</c></param>
            <returns>
            The node if found; <c>null</c> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.NodeMap.Values">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.GetBoundaryNodes(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.PlanarGraph">
            <summary>
            The computation of the <c>IntersectionMatrix</c> relies on the use of a structure
            called a "topology graph". The topology graph contains nodes and edges
            corresponding to the nodes and line segments of a <c>Geometry</c>. Each
            node and edge in the graph is labeled with its topological location relative to
            the source point.
            Note that there is no requirement that points of self-intersection be a vertex.
            Thus to obtain a correct topology graph, <c>Geometry</c>s must be
            self-noded before constructing their graphs.
            Two fundamental operations are supported by topology graphs:
            Computing the intersections between all the edges and nodes of a single graph
            Computing the intersections between the edges and nodes of two different graphs
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Node})">
            <summary>
            For nodes in the Collection, link the DirectedEdges at the node that are in the result.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
            <param name="nodes">A collection of <c>Node</c>s</param>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.PlanarGraph._edges">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.PlanarGraph._nodes">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.PlanarGraph.edgeEndList">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.#ctor(NetTopologySuite.GeometriesGraph.NodeFactory)">
            <summary>
            Creates an instance of this class using the provided <see cref="T:NetTopologySuite.GeometriesGraph.NodeFactory"/>
            </summary>
            <param name="nodeFact">A factory to create <c>Node</c>s</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.#ctor">
            <summary>
            Creates an instance of this class using the default <see cref="T:NetTopologySuite.GeometriesGraph.NodeFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.GetEdgeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph.EdgeEnds">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.IsBoundaryNode(System.Int32,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.InsertEdge(NetTopologySuite.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.Add(NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.GetNodeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph.Nodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.AddNode(NetTopologySuite.GeometriesGraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.AddNode(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.Find(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Searches for a <c>Node</c> at <c>Coordinate</c> position <paramref name="coord"/>
            </summary>
            <param name="coord">A <c>Coordinate</c> position</param>
            <returns>
            The node if found; <c>null</c> otherwise
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.AddEdges(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Add a set of edges to the graph.  For each edge two DirectedEdges
            will be created.  DirectedEdges are NOT linked by this method.
            </summary>
            <param name="edgesToAdd">A set of <c>Edge</c>s to add.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges">
            <summary>
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.LinkAllDirectedEdges">
            <summary>
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.FindEdgeEnd(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Returns the EdgeEnd which has edge e as its base edge
            (MD 18 Feb 2002 - this should return a pair of edges).
            </summary>
            <param name="e">An <c>Edge</c></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.FindEdge(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the edge whose first two coordinates are p0 and p1.
            </summary>
            <param name="p0">The 1st <c>Coordinate</c></param>
            <param name="p1">The 2nd <c>Coordinate</c></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.FindEdgeInSameDirection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the edge which starts at p0 and whose first segment is
            parallel to p1.
            </summary>
            <param name="p0">Starting <c>Coordinate</c></param>
            <param name="p1"><c>Coordinate</c> used to establish direction</param>
            <returns>The matching edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.MatchInSameDirection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            The coordinate pairs match if they define line segments lying in the same direction.
            E.g. the segments are parallel and in the same quadrant
            (as opposed to parallel and opposite!).
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="ep0"></param>
            <param name="ep1"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph.WriteEdges(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Positions">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.On">
            <summary>
             An indicator that a Location is <c>on</c> a GraphComponent (0)
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Left">
            <summary>
            An indicator that a Location is to the <c>left</c> of a GraphComponent (1)
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Right">
            <summary>
            An indicator that a Location is to the <c>right</c> of a GraphComponent (2)
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Parallel">
            <summary>
            An indicator that a Location is <c>is parallel to x-axis</c> of a GraphComponent (-1)
            /// </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Position">
            <summary>
            A Position indicates the position of a Location relative to a graph component
            (Node, Edge, or Area).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Position.Opposite(NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Returns Positions.Left if the position is Positions.Right,
            Positions.Right if the position is Left, or the position
            otherwise.
            </summary>
            <param name="position"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.QuadrantOp">
            <summary>
            Utility functions for working with quadrants, which are numbered as follows:
            <para>
            1 | 0
            --+--
            2 | 3
            </para>
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.QuadrantOp.NE">
            <summary>
            North-East
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.QuadrantOp.NW">
            <summary>
            North-West
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.QuadrantOp.SW">
            <summary>
            South-West
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.QuadrantOp.SE">
            <summary>
            South-East
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.Quadrant(System.Double,System.Double)">
            <summary>
            Returns the quadrant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
            <exception cref="T:System.ArgumentException">If the displacements are both 0</exception>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.Quadrant(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the quadrant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <exception cref="T:System.ArgumentException"> if the points are equal</exception>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.IsOpposite(System.Int32,System.Int32)">
            <summary>
            Returns true if the quadrants are 1 and 3, or 2 and 4.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.CommonHalfPlane(System.Int32,System.Int32)">
            <summary>
            Returns the right-hand quadrant of the halfplane defined by the two quadrants,
            or -1 if the quadrants are opposite, or the quadrant if they are identical.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.IsInHalfPlane(System.Int32,System.Int32)">
            <summary>
            Returns whether the given quadrant lies within the given halfplane (specified
            by its right-hand quadrant).
            </summary>
            <param name="quad"></param>
            <param name="halfPlane"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp.IsNorthern(System.Int32)">
            <summary>
            Returns true if the given quadrant is 0 or 1.
            </summary>
            <param name="quad"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.TopologyLocation">
            <summary>
            A TopologyLocation is the labelling of a
            GraphComponent's topological relationship to a single Geometry.
            </summary>
            <remarks>
            If the parent component is an area edge, each side and the edge itself
            have a topological location.  These locations are named:
            <list type="table">
            <item><term>On</term><description>on the edge</description></item>
            <item><term>Left</term><description>left-hand side of the edge</description></item>
            <item><term>Right</term><description>right-hand side</description></item>
            </list>
            <para>
            If the parent component is a line edge or node, there is a single
            topological relationship attribute, On.</para>
            <para>
            The possible values of a topological location are
            { <see cref="F:NetTopologySuite.Geometries.Location.Null"/>, <see cref="F:NetTopologySuite.Geometries.Location.Exterior"/>, <see cref="F:NetTopologySuite.Geometries.Location.Boundary"/>, <see cref="F:NetTopologySuite.Geometries.Location.Interior"/> }</para>
            <para>
            The labelling is stored in an array _location[j] where
            where j has the values On, Left, Right.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.Geometries.Location[])">
             <summary>
            
             </summary>
             <param name="location"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Constructs a TopologyLocation specifying how points on, to the left of, and to the
            right of some GraphComponent relate to some Geometry. Possible values for the
            parameters are Location.Null, Location.Exterior, Location.Boundary,
            and Location.Interior.
            </summary>
            <param name="on"><c>Location</c> for <b>On</b> position</param>
            <param name="left"><c>Location</c> for <b>Left</b> position</param>
            <param name="right"><c>Location</c> for <b>Right</b> position</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="on"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.GeometriesGraph.TopologyLocation)">
             <summary>
            
             </summary>
             <param name="gl"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Init(System.Int32)">
             <summary>
            
             </summary>
             <param name="size"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Get(NetTopologySuite.GeometriesGraph.Positions)">
             <summary>
            
             </summary>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Get(NetTopologySuite.Geometries.Position)">
             <summary>
            
             </summary>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Item(NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Get calls Get(Positions posIndex),
            Set calls SetLocation(Positions locIndex, Location locValue)
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Item(NetTopologySuite.Geometries.Position)">
            <summary>
            Get calls Get(Positions posIndex),
            Set calls SetLocation(Positions locIndex, Location locValue)
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsNull">
            <returns>
            <c>true</c> if all locations are Null.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsAnyNull">
            <returns>
            <c>true</c> if any locations are Null.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.IsEqualOnSide(NetTopologySuite.GeometriesGraph.TopologyLocation,System.Int32)">
             <summary>
            
             </summary>
             <param name="le"></param>
             <param name="locIndex"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsArea">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsLine">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Flip">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetAllLocations(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetAllLocationsIfNull(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetLocation(NetTopologySuite.GeometriesGraph.Positions,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="locIndex"></param>
             <param name="locValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetLocation(NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="locIndex"></param>
             <param name="locValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetLocation(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.GetLocations">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetLocations(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="on"></param>
             <param name="left"></param>
             <param name="right"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.SetLocations(NetTopologySuite.GeometriesGraph.TopologyLocation)">
             <summary>
            
             </summary>
             <param name="gl"></param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.AllPositionsEqual(NetTopologySuite.Geometries.Location)">
             <summary>
            
             </summary>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Merge(NetTopologySuite.GeometriesGraph.TopologyLocation)">
            <summary>
            Merge updates only the Null attributes of this object
            with the attributes of another.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Index.ArrayListVisitor">
            <summary>
            Builds an array of all visited items.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.ArrayListVisitor`1">
            <summary>
            Builds an array of all visited items.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.ArrayListVisitor`1.VisitItem(`0)">
            <summary>
            Visits an item.
            </summary>
            <param name="item">The item to visit.</param>
        </member>
        <member name="P:NetTopologySuite.Index.ArrayListVisitor`1.Items">
            <summary>
            Gets the array of visited items.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Bintree`1">
            <summary>
            An <c>BinTree</c> (or "Binary Interval Tree")
            is a 1-dimensional version of a quadtree.
            It indexes 1-dimensional intervals (which may
            be the projection of 2-D objects on an axis).
            It supports range searching
            (where the range may be a single point).
            </summary>
            <remarks>
            <para>
            This structure is dynamic -
            new items can be added at any time,
            and it will support deletion of items
            (although this is not currently implemented).
            </para>
            <para>
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accommodate any extent
            of dataset.</para>
            <para>This index is different to the Interval Tree of Edelsbrunner
            or the Segment Tree of Bentley.</para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.EnsureExtent(NetTopologySuite.Index.Bintree.Interval,System.Double)">
            <summary>
            Ensure that the Interval for the inserted item has non-zero extents.
            Use the current minExtent to pad it, if necessary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Bintree`1.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Bintree`1.Count">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Bintree`1.NodeSize">
            <summary>
            Compute the total number of nodes in the tree.
            </summary>
            <returns>The number of nodes in the tree.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.Insert(NetTopologySuite.Index.Bintree.Interval,`0)">
             <summary>
            
             </summary>
             <param name="itemInterval"></param>
             <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.Remove(NetTopologySuite.Index.Bintree.Interval,`0)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemInterval">itemEnv the Envelope of the item to be removed</param>
            <param name="item">the item to remove</param>
            <returns><c>true</c> if the item was found (and thus removed)</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.Query(System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.Query(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Queries the tree to find all candidate items which
            may overlap the query interval.
            If the query interval is <tt>null</tt>, all items in the tree are found.
            <c>min</c> and <c>max</c> may be the same value.
            </summary>
            <param name="interval">The interval to query for or <c>null</c></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.Query(NetTopologySuite.Index.Bintree.Interval,System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds items in the tree which potentially overlap the query interval
            to the given collection.
            If the query interval is <c>null</c>, add all items in the tree.
            </summary>
            <param name="interval">A query interval, or <c>null</c></param>
            <param name="foundItems">The candidate items found</param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Bintree`1.CollectStats(NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Interval">
            <summary>
            Represents an (1-dimensional) closed interval on the Real number line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Interval.Min">
            <summary>
            Gets or sets a value indicating the minimum value of the closed interval.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Interval.Max">
            <summary>
            Gets or sets a value indicating the maximum value of the closed interval.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Interval.Width">
            <summary>
            Gets the width of the interval (<see cref="P:NetTopologySuite.Index.Bintree.Interval.Max"/> - <see cref="P:NetTopologySuite.Index.Bintree.Interval.Min"/>)
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Interval.Centre">
            <summary>
            Gets the centre of the interval (<see cref="P:NetTopologySuite.Index.Bintree.Interval.Min"/> + <see cref="P:NetTopologySuite.Index.Bintree.Interval.Width"/> * 0.5d)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.#ctor">
            <summary>
            Creates a new interval instance, setting <see cref="P:NetTopologySuite.Index.Bintree.Interval.Min"/>=<see cref="P:NetTopologySuite.Index.Bintree.Interval.Max"/>=0d;
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new interval instance, setting <see cref="P:NetTopologySuite.Index.Bintree.Interval.Min"/>=<paramref name="min"/> and <see cref="P:NetTopologySuite.Index.Bintree.Interval.Max"/>=<paramref name="max"/>;
            </summary>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.#ctor(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Creates a new interval instance, setting <see cref="P:NetTopologySuite.Index.Bintree.Interval.Min"/>=<paramref name="interval.Min.Min"/> and <see cref="P:NetTopologySuite.Index.Bintree.Interval.Max"/>=<paramref name="interval.Max.Max"/>.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Init(System.Double,System.Double)">
            <summary>
            Method to initialize the interval with the given <paramref name="min"/> and <paramref name="max"/> values. <br/>
            If <paramref name="max"/> &lt; <paramref name="min"/>, their values are exchanged.
            </summary>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.ExpandToInclude(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Method to expand this interval to contain <paramref name="interval"/>.
            </summary>
            <param name="interval">The interval to contain.</param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Overlaps(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.Index.Bintree.Interval"/> overlaps <paramref name="interval"/>.
            </summary>
            <param name="interval">The interval to test</param>
            <returns><c>true</c> if this interval overlaps <paramref name="interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Overlaps(System.Double,System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.Index.Bintree.Interval"/> overlaps the interval R[<paramref name="min"/>, <paramref name="max"/>].
            </summary>
            <param name="min">The mimimum value of the interval</param>
            <param name="max">The maximum value of the interval</param>
            <returns><c>true</c> if this interval overlaps the interval R[<paramref name="min"/>, <paramref name="max"/>]</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Contains(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.Index.Bintree.Interval"/> contains <paramref name="interval"/>.
            </summary>
            <remarks>This is more rigid than <see cref="M:NetTopologySuite.Index.Bintree.Interval.Overlaps(NetTopologySuite.Index.Bintree.Interval)"/></remarks>
            <param name="interval">The interval to test</param>
            <returns><c>true</c> if this interval contains <paramref name="interval"/></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Contains(System.Double,System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.Index.Bintree.Interval"/> contains the interval R[<paramref name="min"/>, <paramref name="max"/>].
            </summary>
            <remarks>This is more rigid than <see cref="M:NetTopologySuite.Index.Bintree.Interval.Overlaps(System.Double,System.Double)"/></remarks>
            <param name="min">The mimimum value of the interval</param>
            <param name="max">The maximum value of the interval</param>
            <returns><c>true</c> if this interval contains the interval R[<paramref name="min"/>, <paramref name="max"/>]</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Interval.Contains(System.Double)">
            <summary>
            Function to test if this <see cref="T:NetTopologySuite.Index.Bintree.Interval"/> contains the value <paramref name="p"/>.
            </summary>
            <param name="p">The value to test</param>
            <returns><c>true</c> if this interval contains the value <paramref name="p"/></returns>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Key">
            <summary>
            A Key is a unique identifier for a node in a tree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Key.ComputeLevel(NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Key.#ctor(NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Key.Point">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Key.Level">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Key.Interval">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Key.ComputeKey(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemInterval"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Key.ComputeInterval(System.Int32,NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <param name="itemInterval"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Node`1">
            <summary>
            A node of a <c>Bintree</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.CreateNode(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Creates a node
            </summary>
            <param name="itemInterval">The interval of the node item</param>
            <returns>A new node</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.CreateExpanded(NetTopologySuite.Index.Bintree.Node{`0},NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Creates a larger node, that contains both <paramref name="node.Interval.Interval"/> and <paramref name="addInterval"/>
            If <paramref name="node"/> is <c>null</c>, a node for <paramref name="addInterval"/> is created.
            </summary>
            <param name="node">The original node</param>
            <param name="addInterval">The additional interval</param>
            <returns>A new node</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.#ctor(NetTopologySuite.Index.Bintree.Interval,System.Int32)">
            <summary>
            Creates a new node instance
            </summary>
            <param name="interval">The node's interval</param>
            <param name="level">The node's level</param>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.Node`1.Interval">
            <summary>
            Gets the node's <see cref="P:NetTopologySuite.Index.Bintree.Node`1.Interval"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.IsSearchMatch(NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="itemInterval"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.GetNode(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Returns the subnode containing the envelope.
            Creates the node if
            it does not already exist.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.Find(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            Returns the smallest existing
            node containing the envelope.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.Insert(NetTopologySuite.Index.Bintree.Node{`0})">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.GetSubnode(System.Int32)">
            <summary>
            Get the subnode for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.CreateSubnode(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.NodeBase`1">
            <summary>
            The base class for nodes in a <c>Bintree</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.GetSubnodeIndex(NetTopologySuite.Index.Bintree.Interval,System.Double)">
            <summary>
            Returns the index of the subnode that wholely contains the given interval.
            If none does, returns -1.
            </summary>
            <param name="interval"></param>
            <param name="centre"></param>
        </member>
        <member name="F:NetTopologySuite.Index.Bintree.NodeBase`1._items">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Bintree.NodeBase`1.Subnode">
            <summary>
            Subnodes are numbered as follows:
            0 | 1
            .
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.Items">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.Add(`0)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.AddAllItems(System.Collections.Generic.IList{`0})">
             <summary>
            
             </summary>
             <param name="items"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.IsSearchMatch(NetTopologySuite.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.AddAllItemsFromOverlapping(NetTopologySuite.Index.Bintree.Interval,System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds items in the tree which potentially overlap the query interval
            to the given collection.
            If the query interval is <tt>null</tt>, add all items in the tree.
            </summary>
            <param name="interval">A query interval, or <c>null</c></param>
            <param name="resultItems">The candidate items found</param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.NodeBase`1.Remove(NetTopologySuite.Index.Bintree.Interval,`0)">
            <summary>
            Removes a single item from this subtree.
            </summary>
            <param name="itemInterval">The envelope containing the item</param>
            <param name="item">The item to remove</param>
            <returns><c>true</c> if the item was found and removed</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.IsPrunable">
            <summary>
            Gets whether this node is prunable
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.HasChildren">
            <summary>
            Gets whether this node has any children
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.HasItems">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.Depth">
            <summary>
            Gets whether this node has any subnodes
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.Count">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.NodeBase`1.NodeCount">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Root`1">
            <summary>
            The root node of a single <c>Bintree</c>.
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.Insert(NetTopologySuite.Index.Bintree.Interval,`0)">
            <summary>
            Insert an item into the tree this is the root of.
            </summary>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.InsertContained(NetTopologySuite.Index.Bintree.Node{`0},NetTopologySuite.Index.Bintree.Interval,`0)">
            <summary>
            Insert an item which is known to be contained in the tree rooted at
            the given Node.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
            <param name="tree"></param>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.IsSearchMatch(NetTopologySuite.Index.Bintree.Interval)">
            <summary>
            The root node matches all searches.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChain">
            <summary>
            MonotoneChains are a way of partitioning the segments of a linestring to
            allow for fast searching of intersections.
            </summary>
            <remarks>
            <para>
            They have the following properties:
            <list type="bullet">
            <item><description>the segments within a monotone chain never intersect each other</description></item>
            <item><description>the envelope of any contiguous subset of the segments in a monotone chain
            is equal to the envelope of the endpoints of the subset.</description></item>
            </list>
            </para>
            <para>
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.</para>
            <para>Property 2 allows an efficient
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.</para>
            <para>
            One of the goals of this implementation of MonotoneChains is to be
            as space and time efficient as possible. One design choice that aids this
            is that a MonotoneChain is based on a subarray of a list of points.
            This means that new arrays of points (potentially very large) do not
            have to be allocated.</para>
            <para>
            MonotoneChains support the following kinds of queries:
            <list type="table">
            <item>Envelope select</item><description>determine all the segments in the chain which
            intersect a given envelope.</description>
            <item>Overlap</item><description>determine all the pairs of segments in two chains whose
            envelopes overlap.</description>
            </list>
            </para>
            <para>
            This implementation of MonotoneChains uses the concept of internal iterators
            (<see cref="T:NetTopologySuite.Index.Chain.MonotoneChainSelectAction"/> and <see cref="T:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction"/>)
            to return the resultsets for the above queries.
            This has time and space advantages, since it
            is not necessary to build lists of instantiated objects to represent the segments
            returned by the query.
            Queries made in this manner are thread-safe.
            </para>
            <para>
            MonotoneChains support being assigned an integer id value
            to provide a total ordering for a set of chains.
            This can be used during some kinds of processing to
            avoid redundant comparisons
            (i.e.by comparing only chains where the first id is less than the second).
            </para>
            <para>
            MonotoneChains support using an tolerance distance for overlap tests.
            This allows reporting overlap in situations where
            intersection snapping is being used.
            If this is used the chain envelope must be computed
            providing an expansion distance using <see cref="M:NetTopologySuite.Index.Chain.MonotoneChain.GetEnvelope(System.Double)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Int32,System.Object)">
            <summary>
            Creates a new MonotoneChain based on the given array of points.
            </summary>
            <param name="pts">The points containing the chain</param>
            <param name="start">The index of the first coordinate in the chain</param>
            <param name="end">The index of the last coordinate in the chain </param>
            <param name="context">A user-defined data object</param>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.Id">
            <summary>
            Gets or sets the Id of this chain
            </summary>
            <remarks>
            Useful for assigning an ordering to a set of
            chains, which can be used to avoid redundant processing.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.OverlapDistance">
            <summary>
            Gets or sets the overlap distance used in overlap tests
            with other chains.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.Context">
            <summary>
            Gets the chain's user-defined context data value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.Envelope">
            <summary>
            Gets the envelope of this chain
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.GetEnvelope(System.Double)">
            <summary>
            Gets the envelope for this chain,
            expanded by a given distance.
            </summary>
            <param name="expansionDistance">Distance to expand the envelope by</param>
            <returns>The expanded envelope of the chain</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.StartIndex">
            <summary>
            Gets the index of the start of the monotone chain
            in the underlying array of points.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.EndIndex">
            <summary>
            Gets the index of the end of the monotone chain
            in the underlying array of points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.GetLineSegment(System.Int32,NetTopologySuite.Geometries.LineSegment@)">
            <summary>
            Gets the line segment starting at <paramref name="index"/>
            </summary>
            <param name="index">The index of the segment</param>
            <param name="ls">The line segment to extract to</param>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain.Coordinates">
            <summary>
            Return the subsequence of coordinates forming this chain.
            Allocates a new array to hold the Coordinates.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.Select(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.Chain.MonotoneChainSelectAction)">
            <summary>
            Determine all the line segments in the chain whose envelopes overlap
            the searchEnvelope, and process them.
            </summary>
            <remarks>
            The monotone chain search algorithm attempts to optimize
            performance by not calling the select action on chain segments
            which it can determine are not in the search envelope.
            However, it *may* call the select action on segments
            which do not intersect the search envelope.
            This saves on the overhead of checking envelope intersection
            each time, since clients may be able to do this more efficiently.
            </remarks>
            <param name="searchEnv">The search envelope</param>
            <param name="mcs">The select action to execute on selected segments</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.ComputeSelect(NetTopologySuite.Geometries.Envelope,System.Int32,System.Int32,NetTopologySuite.Index.Chain.MonotoneChainSelectAction)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="start0"></param>
             <param name="end0"></param>
             <param name="mcs"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.ComputeOverlaps(NetTopologySuite.Index.Chain.MonotoneChain,NetTopologySuite.Index.Chain.MonotoneChainOverlapAction)">
            <summary>
            Determines the line segments in two chains which may overlap,
            and passes them to an overlap action.
            </summary>
            <remarks>
            The monotone chain search algorithm attempts to optimize
            performance by not calling the overlap action on chain segments
            which it can determine do not overlap.
            However, it* may* call the overlap action on segments
            which do not actually interact.
            This saves on the overhead of checking intersection
            each time, since clients may be able to do this more efficiently.
            </remarks>
            <param name="mc">The chain to compare to</param>
            <param name="mco">The overlap action to execute on selected segments</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.ComputeOverlaps(NetTopologySuite.Index.Chain.MonotoneChain,System.Double,NetTopologySuite.Index.Chain.MonotoneChainOverlapAction)">
            <summary>
            Determines the line segments in two chains which may overlap,
            using an overlap distance tolerance,
            and passes them to an overlap action.
            </summary>
            <param name="mc">The chain to compare to</param>
            <param name="overlapTolerance">The overlap tolerance distance (may be 0)</param>
            <param name="mco">The overlap action to execute on selected segments</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.ComputeOverlaps(System.Int32,System.Int32,NetTopologySuite.Index.Chain.MonotoneChain,System.Int32,System.Int32,System.Double,NetTopologySuite.Index.Chain.MonotoneChainOverlapAction)">
            <summary>
            Uses an efficient mutual binary search strategy
            to determine which pairs of chain segments
            may overlap, and calls the given overlap action on them.
            </summary>
            <param name="start0">The start index of this chain section</param>
            <param name="end0">The end index of this chain section</param>
            <param name="mc">The target monotone chain</param>
            <param name="start1">The start index of the target chain section</param>
            <param name="end1">The end index of the target chain section</param>
            <param name="overlapTolerance">The overlap tolerance distance (may be 0)</param>
            <param name="mco">The overlap action to execute on selected segments</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.Overlaps(System.Int32,System.Int32,NetTopologySuite.Index.Chain.MonotoneChain,System.Int32,System.Int32,System.Double)">
            <summary>
            Tests whether the envelope of a section of the chain
            overlaps(intersects) the envelope of a section of another target chain.
            This test is efficient due to the monotonicity property
            of the sections(i.e.the envelopes can be are determined
            from the section endpoints
            rather than a full scan).
            </summary>
            <param name="start0">The start index of this chain section</param>
            <param name="end0">The end index of this chain section</param>
            <param name="mc">The target monotone chain</param>
            <param name="start1">The start index of the target chain section</param>
            <param name="end1">The end index of the target chain section</param>
            <param name="overlapTolerance">The overlap tolerance distance (may be 0)</param>
            <returns><c>true</c> if the section envelopes overlap</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain.Overlaps(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <param name="p1">The 1st coordinate of the 1st segment</param>
            <param name="p2">The 2nd coordinate of the 1st segment</param>
            <param name="q1">The 1st coordinate of the 2nd segment</param>
            <param name="q2">The 2nd coordinate of the 2nd segment</param>
            <param name="overlapTolerance">The overlap tolerance distance (may be 0)</param>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChainBuilder">
            <summary>
            Constructs <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain"/>s
            for sequences of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.GetChains(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes a list of the <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain"/>s
            for a list of coordinates.
            </summary>
            <param name="pts">The list of points to compute chains for</param>
            <returns>A list of the monotone chains for the points</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.GetChains(NetTopologySuite.Geometries.Coordinate[],System.Object)">
            <summary>
            Return a list of the <c>MonotoneChain</c>s
            for the given list of coordinates.
            </summary>
            <param name="pts">The list of points to compute chains for</param>
            <param name="context">A data object to attach to each chain</param>
            <returns>A list of the monotone chains for the points</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.GetChainStartIndices(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Return an array containing lists of start/end indexes of the monotone chains
            for the given list of coordinates.
            The last entry in the array points to the end point of the point array,
            for use as a sentinel.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.FindChainEnd(NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Finds the index of the last point in a monotone chain
            starting at a given point.
            Any repeated points (0-length segments) will be included
            in the monotone chain returned.
            </summary>
            <param name="pts">The coordinates</param>
            <param name="start">The start index</param>
            <returns>
            The index of the last point in the monotone chain starting at <c>start</c>.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction">
            <summary>
            The action for the internal iterator for performing
            overlap queries on a MonotoneChain.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.overlapSeg1">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.overlapSeg2">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.Overlap(NetTopologySuite.Index.Chain.MonotoneChain,System.Int32,NetTopologySuite.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            This function can be overridden if the original chains are needed.
            </summary>
            <param name="mc1"></param>
            <param name="start1">The index of the start of the overlapping segment from mc1.</param>
            <param name="mc2"></param>
            <param name="start2">The index of the start of the overlapping segment from mc2.</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.Overlap(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment)">
            <summary>
            This is a convenience function which can be overridden to obtain the actual
            line segments which overlap.
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChainSelectAction">
            <summary>
            The action for the internal iterator for performing
            envelope select queries on a MonotoneChain.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Chain.MonotoneChainSelectAction.SelectedSegment">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainSelectAction.Select(NetTopologySuite.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            This method is overridden to process a segment
            in the context of the parent chain.
            </summary>
            <param name="mc">The parent chain</param>
            <param name="startIndex">The index of the start vertex of the segment being processed</param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainSelectAction.Select(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            This is a convenience method which can be overridden to obtain the actual
            line segment which is selected.
            </summary>
            <param name="seg"></param>
        </member>
        <member name="T:NetTopologySuite.Index.HPRtree.HPRtree`1">
            <summary>
            A Hilbert-Packed R-tree.  This is a static R-tree
            which is packed by using the Hilbert ordering
            of the tree items.
            <para/>
            The tree is constructed by sorting the items
            by the Hilbert code of the midpoint of their envelope.
            Then, a set of internal layers is created recursively
            as follows:
            <list type="bullet">
            <item><term>The items/nodes of the previous are partitioned into blocks of size <c>nodeCapacity</c></term></item>
            <item><term>For each block a layer node is created with range equal to the envelope of the items/nodess in the block</term></item>
            </list>
            The internal layers are stored using an array to
            store the node bounds.
            The link between a node and its children is
            stored implicitly in the indexes of the array.
            For efficiency, the offsets to the layers
            within the node array are pre-computed and stored.
            <para/>
            NOTE: Based on performance testing,
            the HPRtree is somewhat faster than the STRtree.
            It should also be more memory-efficent,
            due to fewer object allocations.
            <para/>
            However, it is not clear whether this
            will produce a significant improvement
            for use in JTS operations.
            </summary>
            <seealso cref="T:NetTopologySuite.Index.Strtree.STRtree`1"/>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.#ctor">
            <summary>
            Creates a new index with the default node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.#ctor(System.Int32)">
            <summary>
            Creates a new index with the given node capacity.
            </summary>
            <param name="nodeCapacity">The node capacity to use</param>
        </member>
        <member name="P:NetTopologySuite.Index.HPRtree.HPRtree`1.Count">
            <summary>Gets the number of items in the index.</summary>
            <returns>The number of items</returns>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Insert(NetTopologySuite.Geometries.Envelope,`0)">
            <inheritdoc cref="M:NetTopologySuite.Index.ISpatialIndex`1.Insert(NetTopologySuite.Geometries.Envelope,`0)" />
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Query(NetTopologySuite.Geometries.Envelope)">
            <inheritdoc cref="M:NetTopologySuite.Index.ISpatialIndex`1.Query(NetTopologySuite.Geometries.Envelope)" />
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
            <inheritdoc cref="M:NetTopologySuite.Index.ISpatialIndex`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})" />
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Intersects(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Envelope)">
            <summary>
            Tests whether two envelopes intersect.<para/>
            Avoids the <c>null</c> check in <see cref="M:NetTopologySuite.Geometries.Envelope.Intersects(NetTopologySuite.Geometries.Envelope)"/>.</summary>
            <param name="env1">An envelope</param>
            <param name="env2">An envelope</param>
            <returns><c>true</c> if the envelopes intersect</returns>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Remove(NetTopologySuite.Geometries.Envelope,`0)">
            <inheritdoc cref="M:NetTopologySuite.Index.ISpatialIndex`1.Remove(NetTopologySuite.Geometries.Envelope,`0)" />
            <remarks>Not supported, will always return <c>false</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.Build">
            <summary>
            Builds the index, if not already built.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.NumNodesToCover(System.Int32,System.Int32)">
            <summary>
            Computes the number of blocks (nodes) required to
            cover a given number of children.
            </summary>
            <param name="nChild"></param>
            <param name="nodeCapacity"></param>
            <returns>the number of nodes needed to cover the children</returns>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.HPRtree`1.GetBounds">
            <summary>
            Gets the extents of the internal index nodes
            </summary>
            <returns>A list of the internal node extents</returns>
        </member>
        <member name="P:NetTopologySuite.Index.HPRtree.Item`1.Value">
            <remarks>
            This property is named Item in JTS
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.HPRtree.Item`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Index.IIndexVisitor">
            <summary>
            A visitor for nodes and items in an index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.IIndexVisitor.VisitItem(System.Object)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="T:NetTopologySuite.Index.IItemVisitor`1">
            <summary>
            A visitor for items in a <see cref="T:NetTopologySuite.Index.ISpatialIndex`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.IItemVisitor`1.VisitItem(`0)">
            <summary>
            Visits an item in the index.
            </summary>
            <param name="item">The index item to be visited.</param>
        </member>
        <member name="T:NetTopologySuite.Index.ILimitingItemVisitor`1">
            <summary>
            A visitor for items in a <see cref="T:NetTopologySuite.Index.ISpatialIndex`1"/>
            <para><b>Not used, commited by accident!</b></para>
            </summary>
            <typeparam name="T">The type of the items in the index</typeparam>
            [Obsolete]
        </member>
        <member name="P:NetTopologySuite.Index.ILimitingItemVisitor`1.IsDone">
            <summary>
            Gets a value indicating if no more items need to be visited
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1">
            <summary>
            A static index on a set of 1-dimensional intervals,
            using an R-Tree packed based on the order of the interval midpoints.
            </summary>
            <remarks>
            It supports range searching,
            where the range is an interval of the real line (which may be a single point).
            A common use is to index 1-dimensional intervals which
            are the projection of 2-D objects onto an axis of the coordinate system.
            <para>
            This index structure is <i>static</i>
            - items cannot be added or removed once the first query has been made.
            The advantage of this characteristic is that the index performance
            can be optimized based on a fixed set of items.
            </para>
            <author>Martin Davis</author>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1._root">
            <summary>
            If root is null that indicates
            that the tree has not yet been built,
            OR nothing has been added to the tree.
            In both cases, the tree is still open for insertions.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1.Insert(System.Double,System.Double,`0)">
            <summary>
            Adds an item to the index which is associated with the given interval
            </summary>
            <param name="min">The lower bound of the item interval</param>
            <param name="max">The upper bound of the item interval</param>
            <param name="item">The item to insert</param>
            <exception cref="T:System.InvalidOperationException">if the index has already been queried</exception>
        </member>
        <member name="M:NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1.Query(System.Double,System.Double,NetTopologySuite.Index.IItemVisitor{`0})">
            <summary>
            Search for intervals in the index which intersect the given closed interval
            and apply the visitor to them.
            </summary>
            <param name="min">The lower bound of the query interval</param>
            <param name="max">The upper bound of the query interval</param>
            <param name="visitor">The visitor to pass any matched items to</param>
        </member>
        <member name="T:NetTopologySuite.Index.ISpatialIndex`1">
            <summary>
            The basic insertion and query operations supported by classes
            implementing spatial index algorithms.
            A spatial index typically provides a primary filter for range rectangle queries. A
            secondary filter is required to test for exact intersection. Of course, this
            secondary filter may consist of other tests besides intersection, such as
            testing other kinds of spatial relationships.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.ISpatialIndex`1.Insert(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Adds a spatial item with an extent specified by the given <c>Envelope</c> to the index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.ISpatialIndex`1.Query(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Queries the index for all items whose extents intersect the given search <c>Envelope</c>
            Note that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <returns>A list of the items found by the query.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.ISpatialIndex`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
            <summary>
            Queries the index for all items whose extents intersect the given search <see cref="T:NetTopologySuite.Geometries.Envelope" />,
            and applies an <see cref="T:NetTopologySuite.Index.IItemVisitor`1" /> to them.
            Note that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <param name="visitor">A visitor object to apply to the items found.</param>
        </member>
        <member name="M:NetTopologySuite.Index.ISpatialIndex`1.Remove(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns> <c>true</c> if the item was found.</returns>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.IKdNodeVisitor`1">
            <summary>
            A visitor for <see cref="T:NetTopologySuite.Index.KdTree.KdNode`1"/>s in a <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/> index.
            </summary>
            <version>1.7</version>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.IKdNodeVisitor`1.Visit(NetTopologySuite.Index.KdTree.KdNode{`0})">
            <summary>
            Visits a node.
            </summary>
            <param name="node">The node to visit</param>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.KdNode`1">
            <summary>
            A node of a <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/>, which represents one or more points in the same location.
            </summary>
            <typeparam name="T">The type of the object</typeparam>
            <author>dskea</author>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.#ctor(System.Double,System.Double,`0)">
            <summary>
            Creates a new KdNode.
            </summary>
            <param name="x">coordinate of point</param>
            <param name="y">coordinate of point</param>
            <param name="data">A data objects to associate with this node</param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.#ctor(NetTopologySuite.Geometries.Coordinate,`0)">
            <summary>
            Creates a new KdNode.
            </summary>
            <param name="p">The point location of new node</param>
            <param name="data">A data objects to associate with this node</param>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.X">
            <summary>
            Gets x-ordinate of this node
            </summary>
            <returns>The <c>x</c>-ordinate</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Y">
            <summary>
            Gets y-ordinate of this node
            </summary>
            <returns>The <c>y</c>-ordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.SplitValue(System.Boolean)">
            <summary>
            Gets the split value at a node, depending on
            whether the node splits on X or Y.
            The X (or Y) ordinates of all points in the left subtree
            are less than the split value, and those
            in the right subtree are greater than or equal to the split value.
            </summary>
            <param name="isSplitOnX">A flag whether the node splits a X or Y</param>
            <returns>The splitting value</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Coordinate">
            <summary>
            Gets the location of this node
            </summary>
            <returns>The <c>Coordinate</c></returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Data">
            <summary>
            Gets the user data object associated with this node.
            </summary>
            <returns>The user data</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Left">
            <summary>
            Gets or sets the left node of the tree
            </summary>
            <returns>The left node</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Right">
            <summary>
            Gets or sets the right node of the tree
            </summary>
            <returns>The right node</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Count">
            <summary>
            Gets the number of inserted points that are coincident at this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.IsRepeated">
            <summary>
            Gets whether more than one point with this value have been inserted (up to the tolerance)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.IsRangeOverLeft(System.Boolean,NetTopologySuite.Geometries.Envelope)">
            <summary>
            Tests whether the node's left subtree may contain values
            in a given range envelope.
            </summary>
            <param name="isSplitOnX">A flag whether the node splits on  X or Y</param>
            <param name="env">The range envelope</param>
            <returns><c>true</c> if the left subtree is in range</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.IsRangeOverRight(System.Boolean,NetTopologySuite.Geometries.Envelope)">
            <summary>
            Tests whether the node's right subtree may contain values
            in a given range envelope.
            </summary>
            <param name="isSplitOnX">A flag whether the node splits on  X or Y</param>
            <param name="env">The range envelope</param>
            <returns><c>true</c>if the right subtree is in range</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.IsPointOnLeft(System.Boolean,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a point is strictly to the left
            of the splitting plane for this node.
            If so it may be in the left subtree of this node,
            Otherwise, the point may be in the right subtree.
            The point is to the left if its X (or Y) ordinate
            is less than the split value.
            </summary>
            <param name="isSplitOnX">A flag whether the node splits on  X or Y</param>
            <param name="pt">The query point</param>
            <returns><c>true</c> if the point is strictly to the left.</returns>
            <seealso cref="M:NetTopologySuite.Index.KdTree.KdNode`1.SplitValue(System.Boolean)"/>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.KdTree`1">
            <summary>
            An implementation of a
            <a href='https://en.wikipedia.org/wiki/K-d_tree'> KD - Tree </a>
            over two dimensions(X and Y).
            KD-trees provide fast range searching and fast lookup for point data.
            The tree is built dynamically by inserting points.
            The tree supports queries by range and for point equality.
            For querying an internal stack is used instead of recursion to avoid overflow.
            </summary>
            <remarks>
            This implementation supports detecting and snapping points which are closer
            than a given distance tolerance.
            If the same point (up to tolerance) is inserted
            more than once , it is snapped to the existing node.
            In other words, if a point is inserted which lies
            within the tolerance of a node already in the index,
            it is snapped to that node.
            When an inserted point is snapped to a node then a new node is not created
            but the count of the existing node is incremented.
            If more than one node in the tree is within tolerance of an inserted point,
            the closest and then lowest node is snapped to.
            <para/>
            The structure of a KD-Tree depends on the order of insertion of the points.
            A tree may become umbalanced if the inserted points are coherent
            (e.g.monotonic in one or both dimensions).
            A perfectly balanced tree has depth of only log2(N),
            but an umbalanced tree may be much deeper.
            This has a serious impact on query efficiency.
            One solution to this is to randomize the order of points before insertion
            (e.g. by using <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"> Fisher - Yates shuffling</a>).
            </remarks>
            <typeparam name="T">The type of the user data object</typeparam>
            <author>David Skea</author>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.ToCoordinates(System.Collections.Generic.IEnumerable{NetTopologySuite.Index.KdTree.KdNode{`0}})">
            <summary>
            Converts a collection of<see cref= "T:NetTopologySuite.Index.KdTree.KdNode`1" /> s to an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="kdnodes">A collection of nodes</param>
            <returns>An array of the coordinates represented by the nodes</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.ToCoordinates(System.Collections.Generic.IEnumerable{NetTopologySuite.Index.KdTree.KdNode{`0}},System.Boolean)">
            <summary>
            Converts a collection of <see cref="T:NetTopologySuite.Index.KdTree.KdNode`1"/>{@link KdNode}s
            to an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s,
            specifying whether repeated nodes should be represented
            by multiple coordinates.
            </summary>
            <param name="kdnodes">a collection of nodes</param>
            <param name="includeRepeated">true if repeated nodes should
            be included multiple times</param>
            <returns>An array of the coordinates represented by the nodes</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.#ctor">
            <summary>
            Creates a new instance of a KdTree with a snapping tolerance of 0.0.
            (I.e. distinct points will <i>not</i> be snapped)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.#ctor(System.Double)">
            <summary>
            Creates a new instance of a KdTree with a snapping distance
            tolerance. Points which lie closer than the tolerance to a point already
            in the tree will be treated as identical to the existing point.
            </summary>
            <param name="tolerance">The tolerance distance for considering two points equal</param>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdTree`1.IsEmpty">
            <summary>
            Tests whether the index contains any items.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdTree`1.Root">
            <summary>
            Gets a value indicating the root node of the tree
            </summary>
            <returns>The root node of the tree</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Insert(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Inserts a new point in the kd-tree, with no data.
            </summary>
            <param name="p">The point to insert</param>
            <returns>The kdnode containing the point</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Insert(NetTopologySuite.Geometries.Coordinate,`0)">
            <summary>
            Inserts a new point into the kd-tree.
            </summary>
            <param name="p">The point to insert</param>
            <param name="data">A data item for the point</param>
            <returns>
            A new KdNode if a new point is inserted, else an existing
            node is returned with its counter incremented. This can be checked
            by testing returnedNode.getCount() > 1.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.FindBestMatchNode(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds the node in the tree which is the best match for a point
            being inserted.
            The match is made deterministic by returning the lowest of any nodes which
            lie the same distance from the point.
            There may be no match if the point is not within the distance tolerance of any
            existing node.
            </summary>
            <param name="p">The point being inserted</param>
            <returns>
            <list type="bullet">
            <item><description>the best matching node</description></item>
            <item><description>null if no match was found</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.InsertExact(NetTopologySuite.Geometries.Coordinate,`0)">
            <summary>
            Inserts a point known to be beyond the distance tolerance of any existing node.
            The point is inserted at the bottom of the exact splitting path,
            so that tree shape is deterministic.
            </summary>
            <param name="p">The point to insert</param>
            <param name="data">The data associated with <paramref name="p"/></param>
            <returns>
            <list type="bullet">
            <item><description>The data for the point</description></item>
            <item><description>The created node</description></item>
            </list>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.KdTree.IKdNodeVisitor{`0})">
            <summary>
            Performs a range search of the points in the index and visits all nodes found.
            </summary>
            <param name="queryEnv">The range rectangle to query</param>
            <param name="visitor">A visitor to visit all nodes found by the search</param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Query(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Performs a range search of the points in the index.
            </summary>
            <param name="queryEnv">The range rectangle to query</param>
            <returns>A collection of the KdNodes found</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Query(NetTopologySuite.Geometries.Envelope,System.Collections.Generic.IList{NetTopologySuite.Index.KdTree.KdNode{`0}})">
            <summary>
            Performs a range search of the points in the index.
            </summary>
            <param name="queryEnv">The range rectangle to query</param>
            <param name="result">A collection to accumulate the result nodes into</param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Query(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Searches for a given point in the index and returns its node if found.
            </summary>
            <param name="queryPt">the point to query</param>
            <returns>the point node, if it is found in the index, or <see langword="null"/> if not</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdTree`1.Depth">
            <summary>
            Gets a value indicating the depth of the tree
            </summary>
            <returns>The depth of the tree</returns>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdTree`1.Count">
            <summary>
            Gets a value indicating the number of items in the tree.
            </summary>
            <returns>The number of items in the tree.</returns>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.KdTreeExtensions">
            <summary>
            Extensions methods for the <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTreeExtensions.NearestNeighbor``1(NetTopologySuite.Index.KdTree.KdTree{``0},NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Performs a nearest neighbor search of the points in the index.
            </summary>
            <param name="self">The KdTree to look for the nearest neighbor</param>
            <param name="coord">The point to search the nearset neighbor for</param>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.DoubleBits">
            <summary>
            DoubleBits manipulates Double numbers
            by using bit manipulation and bit-field extraction.
            For some operations (such as determining the exponent)
            this is more accurate than using mathematical operations
            (which suffer from round-off error).
            The algorithms and constants in this class
            apply only to IEEE-754 double-precision floating point format.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.DoubleBits.ExponentBias">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.PowerOf2(System.Int32)">
             <summary>
            
             </summary>
             <param name="exp"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.GetExponent(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.TruncateToPowerOfTwo(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.ToBinaryString(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.MaximumCommonMantissa(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="d1"></param>
             <param name="d2"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.#ctor(System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.DoubleBits.Double">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.DoubleBits.BiasedExponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.DoubleBits.Exponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.ZeroLowerBits(System.Int32)">
             <summary>
            
             </summary>
             <param name="nBits"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.GetBit(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.NumCommonMantissaBits(NetTopologySuite.Index.Quadtree.DoubleBits)">
            <summary>
            This computes the number of common most-significant bits in the mantissa.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="db"></param>
            <returns> The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.DoubleBits.ToString">
            <summary>
            A representation of the Double bits formatted for easy readability.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.IntervalSize">
            <summary>
            Provides a test for whether an interval is
            so small it should be considered as zero for the purposes of
            inserting it into a binary tree.
            The reason this check is necessary is that round-off error can
            cause the algorithm used to subdivide an interval to fail, by
            computing a midpoint value which does not lie strictly between the
            endpoints.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.IntervalSize.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.IntervalSize.MinBinaryExponent">
            <summary>
            This value is chosen to be a few powers of 2 less than the
            number of bits available in the double representation (i.e. 53).
            This should allow enough extra precision for simple computations to be correct,
            at least for comparison purposes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.IntervalSize.IsZeroWidth(System.Double,System.Double)">
            <summary>
            Computes whether the interval [min, max] is effectively zero width.
            I.e. the width of the interval is so much less than the
            location of the interval that the midpoint of the interval cannot be
            represented precisely.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Key">
            <summary>
            A Key is a unique identifier for a node in a quadtree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Key.ComputeQuadLevel(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Key.#ctor(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Key.Point">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Key.Level">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Key.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Key.Centre">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Key.ComputeKey(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemEnv"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Key.ComputeKey(System.Int32,NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <param name="itemEnv"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Node`1">
            <summary>
            Represents a node of a <c>Quadtree</c>.  Nodes contain
            items which have a spatial extent corresponding to the node's position
            in the quadtree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.CreateNode(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.CreateExpanded(NetTopologySuite.Index.Quadtree.Node{`0},NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="addEnv"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.#ctor(NetTopologySuite.Geometries.Envelope,System.Int32)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <param name="level"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Node`1.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.IsSearchMatch(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.GetNode(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Returns the subquad containing the envelope <paramref name="searchEnv"/>.
            Creates the subquad if
            it does not already exist.
            </summary>
            <param name="searchEnv">The envelope to search for</param>
            <returns>The subquad containing the search envelope.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.Find(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Returns the smallest <i>existing</i>
            node containing the envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.InsertNode(NetTopologySuite.Index.Quadtree.Node{`0})">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.GetSubnode(System.Int32)">
            <summary>
            Get the subquad for the index.
            If it doesn't exist, create it.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`1.CreateSubnode(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Node`1.Level">
            <summary>
            Gets a value indicating the level of this node
            </summary>
            <returns>The level of this node</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.NodeBase`1">
            <summary>
            The base class for nodes in a <c>Quadtree</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.GetSubnodeIndex(NetTopologySuite.Geometries.Envelope,System.Double,System.Double)">
            <summary>
            Gets the index of the subquad that wholly contains the given envelope.
            If none does, returns -1.
            </summary>
            <returns>The index of the subquad that wholly contains the given envelope <br/>
            or -1 if no subquad wholly contains the envelope</returns>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.NodeBase`1._items">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.NodeBase`1.Subnode">
            <summary>
            subquads are numbered as follows:
            2 | 3
            --+--
            0 | 1
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.Items">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.HasItems">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.Add(`0)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.Remove(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Removes a single item from this subtree.
            </summary>
            <param name="itemEnv">The envelope containing the item.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found and removed.</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.IsPrunable">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.HasChildren">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.IsEmpty">
            <summary>
            Gets a value indicating that this node is empty, i.e. it does not contain an items or sub-nodes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.AddAllItems(System.Collections.Generic.IList{`0}@)">
            <summary>
            Insert items in <c>this</c> into the parameter!
            </summary>
            <param name="resultItems">IList for adding items.</param>
            <returns>Parameter IList with <c>this</c> items.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.IsSearchMatch(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.AddAllItemsFromOverlapping(NetTopologySuite.Geometries.Envelope,System.Collections.Generic.IList{`0}@)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="resultItems"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.Visit(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="visitor"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.NodeBase`1.VisitItems(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
             <summary>
            
             </summary>  
             <param name="searchEnv"></param>
             <param name="visitor"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.Count">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.NodeBase`1.NodeCount">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Quadtree`1">
            <summary>
            A Quadtree is a spatial index structure for efficient range querying
            of items bounded by 2D rectangles.<br/>
            <see cref="T:NetTopologySuite.Geometries.Geometry"/>s can be indexed by using their <see cref="T:NetTopologySuite.Geometries.Envelope"/>s.<br/>
            Any type of object can also be indexed, as long as it has an extent that can be
            represented by an <see cref="T:NetTopologySuite.Geometries.Envelope"/>.
            <para/>
            This Quadtree index provides a <b>primary filter</b>
            for range rectangle queries.  The various query methods return a list of
            all items which <i>may</i> intersect the query rectangle.  Note that
            it may thus return items which do <b>not</b> in fact intersect the query rectangle.
            A secondary filter is required to test for actual intersection
            between the query rectangle and the envelope of each candidate item.
            The secondary filter may be performed explicitly,
            or it may be provided implicitly by subsequent operations executed on the items
            (for instance, if the index query is followed by computing a spatial predicate
            between the query geometry and tree items,
            the envelope intersection check is performed automatically.
            <para/>
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accommodate any extent
            of dataset.
            <para/>
            This data structure is also known as an <c>MX-CIF quadtree</c>
            following the terminology usage of Samet and others.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.EnsureExtent(NetTopologySuite.Geometries.Envelope,System.Double)">
            <summary>
            Ensure that the envelope for the inserted item has non-zero extents.
            Use the current minExtent to pad the envelope, if necessary.
            </summary>
            <param name="itemEnv"></param>
            <param name="minExtent"></param>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.Quadtree`1._minExtent">
            <summary>
            minExtent is the minimum envelope extent of all items
            inserted into the tree so far. It is used as a heuristic value
            to construct non-zero envelopes for features with zero X and/or Y extent.
            Start with a non-zero extent, in case the first feature inserted has
            a zero extent in both directions.  This value may be non-optimal, but
            only one feature will be inserted with this value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.#ctor">
            <summary>
            Constructs a Quadtree with zero items.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`1.Depth">
            <summary>
            Returns the number of levels in the tree.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`1.IsEmpty">
            <summary>
            Tests whether the index contains any items.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`1.Count">
            <summary>
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.Insert(NetTopologySuite.Geometries.Envelope,`0)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
             <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.Remove(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to be removed.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found (and thus removed).</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.Query(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Queries the tree and returns items which may lie in the given search envelope.
            </summary>
            <remarks>
            Precisely, the items that are returned are all items in the tree
            whose envelope <b>may</b> intersect the search Envelope.
            Note that some items with non-intersecting envelopes may be returned as well;
            the client is responsible for filtering these out.
            In most situations there will be many items in the tree which do not
            intersect the search envelope and which are not returned - thus
            providing improved performance over a simple linear scan.
            </remarks>
            <param name="searchEnv">The envelope of the desired query area.</param>
            <returns>A List of items which may intersect the search envelope</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
            <summary>
            Queries the tree and visits items which may lie in the given search envelope.
            </summary>
            <remarks>
            Precisely, the items that are visited are all items in the tree
            whose envelope <b>may</b> intersect the search Envelope.
            Note that some items with non-intersecting envelopes may be visited as well;
            the client is responsible for filtering these out.
            In most situations there will be many items in the tree which do not
            intersect the search envelope and which are not visited - thus
            providing improved performance over a simple linear scan.
            </remarks>
            <param name="searchEnv">The envelope of the desired query area.</param>
            <param name="visitor">A visitor object which is passed the visited items</param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.QueryAll">
            <summary>
            Return a list of all items in the Quadtree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`1.CollectStats(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`1.Root">
            <summary>
            Gets a value indicating the root node of this QuadTree
            </summary>
            <returns>The root node of this QuadTree</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.ExcludingItemVisitor`1">
            <summary>
            Item visitor that specifically excludes a predefined area.
            </summary>
            <typeparam name="T">The type of the items to visit</typeparam>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.ExcludingItemVisitor`1.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Initialize with <paramref name="exclude"/>
            </summary>
            <param name="exclude"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.ExcludingItemVisitor`1.VisitItem(`0)">
            <inheritdoc cref="M:NetTopologySuite.Index.IItemVisitor`1.VisitItem(`0)"/>>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.ExcludingItemVisitor`1.Items">
            <summary>
            Get a value indicating the gathered items
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Root`1">
            <summary>
            QuadRoot is the root of a single Quadtree.
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Root`1.Insert(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Insert an item into the quadtree this is the root of.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Root`1.InsertContained(NetTopologySuite.Index.Quadtree.Node{`0},NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Insert an item which is known to be contained in the tree rooted at
            the given QuadNode root.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Root`1.IsSearchMatch(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.AbstractNode`2">
            <summary>
            A node of an <see cref="T:NetTopologySuite.Index.Strtree.AbstractSTRtree`2"/>. A node is one of:
            <list type="bullet">
            <item>empty</item>
            <item><description>an <i>interior node</i> containing child <see cref="T:NetTopologySuite.Index.Strtree.AbstractNode`2"/>s</description></item>
            <item><description>a <i>leaf node</i> containing data items (<see cref="T:NetTopologySuite.Index.Strtree.ItemBoundable`2"/>s).</description></item>
            </list>
            A node stores the bounds of its children, and its level within the index tree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractNode`2.#ctor(System.Int32)">
            <summary>
            Constructs an AbstractNode at the given level in the tree
            </summary>
            <param name="level">
            0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </param>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractNode`2.ChildBoundables">
            <summary>
            Returns either child <see cref="T:NetTopologySuite.Index.Strtree.AbstractNode`2"/>s, or if this is a leaf node, real data (wrapped
            in <see cref="T:NetTopologySuite.Index.Strtree.ItemBoundable`2"/>s).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractNode`2.ComputeBounds">
            <summary>
            Returns a representation of space that encloses this Boundable,
            preferably not much bigger than this Boundable's boundary yet fast to
            test for intersection with the bounds of other Boundables. The class of
            object returned depends on the subclass of AbstractSTRtree.
            </summary>
            <returns>
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other
            object (for other subclasses of AbstractSTRtree).
            </returns>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractNode`2.Bounds">
            <summary>
            Gets the bounds of this node
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractNode`2.Level">
            <summary>
            Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractNode`2.Count">
            <summary>
            Gets the count of the <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s at this node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractNode`2.IsEmpty">
            <summary>
            Tests whether there are any <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s at this node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractNode`2.AddChildBoundable(NetTopologySuite.Geometries.IBoundable{`0,`1})">
            <summary>
            Adds either an AbstractNode, or if this is a leaf node, a data object
            (wrapped in an ItemBoundable).
            </summary>
            <param name="childBoundable">The child to add.</param>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.AbstractSTRtree`2">
            <summary>
            Base class for STRtree and SIRtree. STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. <i>Spatial Databases With
            Application To GIS</i>. Morgan Kaufmann, San Francisco, 2002.
            <para>
            This implementation is based on <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s rather than just <see cref="T:NetTopologySuite.Index.Strtree.AbstractNode`2"/>s,
            because the STR algorithm operates on both nodes and
            data, both of which are treated as <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s.
            </para>
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.IIntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.IIntersectsOp.Intersects(`0,`0)">
            <summary>
            For STRtrees, the bounds will be Envelopes;
            for SIRtrees, Intervals;
            for other subclasses of AbstractSTRtree, some other class.
            </summary>
            <param name="aBounds">The bounds of one spatial object.</param>
            <param name="bBounds">The bounds of another spatial object.</param>
            <returns>Whether the two bounds intersect.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.#ctor(System.Int32)">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have.
            </summary>
            <param name="nodeCapacity"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.#ctor(System.Int32,NetTopologySuite.Index.Strtree.AbstractNode{`0,`1})">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have, and the root node
            </summary>
            <param name="nodeCapacity">The maximum number of child nodes in a node</param>
            <param name="root">The root node that links to all other nodes in the tree</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.#ctor(System.Int32,System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{`0,`1}})">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have, and all leaf nodes in the tree
            </summary>
            <param name="nodeCapacity">The maximum number of child nodes in a node</param>
            <param name="itemBoundables">The list of leaf nodes in the tree</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.Build">
            <summary>
            Creates parent nodes, grandparent nodes, and so forth up to the root
            node, for the data that has been inserted into the tree. Can only be
            called once, and thus can be called only after all of the data has been
            inserted into the tree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.CreateParentBoundables(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{`0,`1}},System.Int32)">
            <summary>
            Sorts the childBoundables then divides them into groups of size M, where
            M is the node capacity.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.CreateHigherLevels(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{`0,`1}},System.Int32)">
            <summary>
            Creates the levels higher than the given level.
            </summary>
            <param name="boundablesOfALevel">The level to build on.</param>
            <param name="level">the level of the Boundables, or -1 if the boundables are item
            boundables (that is, below level 0).</param>
            <returns>The root, which may be a ParentNode or a LeafNode.</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.Root">
            <summary>
            Gets the root node of the tree.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.NodeCapacity">
            <summary>
            Gets the maximum number of child nodes that a node may have.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.IsEmpty">
            <summary>
            Tests whether the index contains any items.
            This method does not build the index,
            so items can still be inserted after it has been called.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.Count">
            <summary>
            Gets the number of elements in the tree
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.Query(`0)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.ItemsTree">
            <summary>
            Gets a tree structure (as a nested list)
            corresponding to the structure of the items and nodes in this tree.
            The returned Lists contain either Object items,
            or Lists which correspond to subtrees of the tree
            Subtrees which do not contain any items are not included.
            Builds the tree if necessary.
            </summary>
            <returns>a List of items and/or Lists</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.IntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.Remove(`0,`1)">
            <summary>
            Removes an item from the tree.
            (Builds the tree, if necessary.)
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractSTRtree`2.ItemBoundables">
            <summary>
            Gets a value indicating the boundable items that have to be included in the index
            </summary>
            <returns>A list of boundable items</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.BoundablePair`1">
            <summary>
            A pair of <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s, whose leaf items
            support a distance metric between them.
            Used to compute the distance between the members,
            and to expand a member relative to the other
            in order to produce new branches of the
            Branch-and-Bound evaluation tree.
            Provides an ordering based on the distance between the members,
            which allows building a priority queue by minimum distance.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.#ctor(NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0},NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0},NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})">
            <summary>
            Creates an instance of this class with the given <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s and the <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> function.
            </summary>
            <param name="boundable1">The first boundable</param>
            <param name="boundable2">The second boundable</param>
            <param name="itemDistance">The item distance function</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.GetBoundable(System.Int32)">
            <summary>
            Gets one of the member <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s in the pair
            (indexed by [0, 1]).
            </summary>
            <param name="i">The index of the member to return (0 or 1)</param>
            <returns>The chosen member</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.MaximumDistance">
            <summary>
            Computes the maximum distance between any
            two items in the pair of nodes.
            </summary>
            <returns>the maximum distance between items in the pair</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.GetDistance">
            <summary>
            Computes the distance between the <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s in this pair.
            The boundables are either composites or leaves.
            If either is composite, the distance is computed as the minimum distance
            between the bounds.
            If both are leaves, the distance is computed by <see cref="M:NetTopologySuite.Index.Strtree.IItemDistance`2.Distance(NetTopologySuite.Geometries.IBoundable{`0,`1},NetTopologySuite.Geometries.IBoundable{`0,`1})"/>.
            </summary>
            <returns>The distance between the <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s in this pair.</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.BoundablePair`1.Distance">
            <summary>
            Gets the minimum possible distance between the Boundables in
            this pair.
            If the members are both items, this will be the
            exact distance between them.
            Otherwise, this distance will be a lower bound on
            the distances between the items in the members.
            </summary>
            <returns>The exact or lower bound distance for this pair</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.CompareTo(NetTopologySuite.Index.Strtree.BoundablePair{`0})">
            <summary>
            Compares two pairs based on their minimum distances
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.BoundablePair`1.IsLeaves">
            <summary>
            Tests if both elements of the pair are leaf nodes
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePair`1.ExpandToQueue(NetTopologySuite.Utilities.PriorityQueue{NetTopologySuite.Index.Strtree.BoundablePair{`0}},System.Double)">
            <summary>
            For a pair which is not a leaf
            (i.e. has at least one composite boundable)
            computes a list of new pairs
            from the expansion of the larger boundable
            with distance less than minDistance
            and adds them to a priority queue.
            <para/>
            Note that expanded pairs may contain
            the same item/node on both sides.
            This must be allowed to support distance
            functions which have non-zero distances
            between the item and itself (non-zero reflexive distance).
            </summary>
            <param name="priQ">The priority queue to add the new pairs to. </param>
            <param name="minDistance">The limit on the distance between added pairs. </param>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1">
            <summary>
            The Class BoundablePairDistanceComparator. It implements .Net <see cref="T:System.Collections.Generic.IComparer`1"/> and is used
            as a parameter to sort the BoundablePair list.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1._normalOrder">
            <summary>The normal order</summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1.#ctor(System.Boolean)">
            <summary>
            Instantiates a new boundable pair distance comparator.
            </summary>
            <param name="normalOrder">
            A value of <c>true</c> puts the lowest record at the head of this queue.
            This is the natural order. <see cref="M:NetTopologySuite.Utilities.PriorityQueue`1.Peek"/> will get the least element.
            </param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1.Compare(NetTopologySuite.Index.Strtree.BoundablePair{`0},NetTopologySuite.Index.Strtree.BoundablePair{`0})">
            <inheritdoc cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.EnvelopeDistance">
            <summary>
             Utility functions for working with <see cref="T:NetTopologySuite.Geometries.Envelope"/>s.
             </summary>
             <author>mdavis</author>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.EnvelopeDistance.MaximumDistance(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Envelope)">
            <summary>
             Computes the maximum distance between the points defining two envelopes.
             This is the distance between the two corners which are farthest apart.
             <para/>
             Note that this is NOT the MinMax distance, which is a tighter bound on
             the distance between the points in the envelopes.
             </summary>
             <param name="env1">An envelope</param>
             <param name="env2">An envelope</param>
             <returns>The maximum distance between the points defining the envelopes</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.EnvelopeDistance.MinMaxDistance(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Envelope)">
            <summary>
            Computes the Min-Max Distance between two <see cref="T:NetTopologySuite.Geometries.Envelope"/>s.
            It is equal to the minimum of the maximum distances between all pairs of
            edge segments from the two envelopes.
            This is the tight upper bound on the distance between
            geometric items bounded by the envelopes.
            <para/>
            Theoretically this bound can be used in the R-tree nearest-neighbour branch-and-bound search
            instead of <see cref="M:NetTopologySuite.Index.Strtree.EnvelopeDistance.MaximumDistance(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Envelope)"/>.
            However, little performance improvement is observed in practice.
            </summary>
            <param name="a">An envelope</param>
            <param name="b">An envelope</param>
            <returns>The min-max-distance between the envelopes</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.EnvelopeDistance.MaxDistance(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
             <summary>
             Computes the maximum distance between two line segments.
             </summary>
             <param name="ax1">x-ordinate of first endpoint of segment 1</param>
             <param name="ay1">y-ordinate of first endpoint of segment 1</param>
             <param name="ax2">x-ordinate of second endpoint of segment 1</param>
             <param name="ay2">y-ordinate of second endpoint of segment 1</param>
             <param name="bx1">x-ordinate of first endpoint of segment 2</param>
             <param name="by1">y-ordinate of first endpoint of segment 2</param>
             <param name="bx2">x-ordinate of second endpoint of segment 2</param>
             <param name="by2">y-ordinate of second endpoint of segment 2</param>
            <returns>Maximum distance between the segments</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.GeometryItemDistance">
            <summary>
            An <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> function for
            items which are <see cref="T:NetTopologySuite.Geometries.Geometry"/> using the <see cref="M:NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)"/> method.
            <para/>
            To make this distance function suitable for
            using to query a single index tree,
            the distance metric is <i>anti-reflexive</i>.
            That is, if the two arguments are the same Geometry object,
            the distance returned is <see cref="F:System.Double.MaxValue"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.GeometryItemDistance.Distance(NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Geometry})">
            <summary>
            Computes the distance between two <see cref="T:NetTopologySuite.Geometries.Geometry"/> items,
            using the <see cref="M:NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)"/> method.
            </summary>
            <param name="item1">An item which is a geometry.</param>
            <param name="item2">An item which is a geometry.</param>
            <exception cref="T:System.InvalidCastException">if either item is not a Geometry</exception>
            <returns>The distance between the two items.</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.IItemDistance`2">
            <summary>
            A function method which computes the distance
            between two <see cref="T:NetTopologySuite.Geometries.IBoundable`2"/>s in an <see cref="T:NetTopologySuite.Index.Strtree.STRtree`1"/>.
            Used for Nearest Neighbour searches.
            <para/>
            To make a distance function suitable for
            querying a single index tree
            via <see cref="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})"/>,
            the function should have a non-zero <i>reflexive distance</i>.
            That is, if the two arguments are the same object,
            the distance returned should be non-zero.
            If it is required that only pairs of <b>distinct</b> items be returned,
            the distance function must be <i>anti-reflexive</i>,
            and must return <see cref="F:System.Double.MaxValue"/> for identical arguments.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.IItemDistance`2.Distance(NetTopologySuite.Geometries.IBoundable{`0,`1},NetTopologySuite.Geometries.IBoundable{`0,`1})">
            <summary>
            Computes the distance between two items.
            </summary>
            <param name="item1">The first item.</param>
            <param name="item2">The second item.</param>
            <exception cref="T:System.ArgumentException">If the metric is not applicable to the arguments</exception>
            <returns>The distance between <paramref name="item1"/> and <paramref name="item2"/>.</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.Interval">
            <summary>
            A contiguous portion of 1D-space. Used internally by SIRtree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.#ctor(NetTopologySuite.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.#ctor(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.Interval.Centre">
            <summary>
            Gets the centre of the interval.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.ExpandToInclude(NetTopologySuite.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns><c>this</c></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.ExpandedBy(NetTopologySuite.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns><c>this</c></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.Intersects(NetTopologySuite.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.Equals(System.Object)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.Interval.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.ItemBoundable`2">
            <summary>
            Boundable wrapper for a non-Boundable spatial object. Used internally by
            AbstractSTRtree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.ItemBoundable`2.#ctor(`0,`1)">
             <summary>
            
             </summary>
             <param name="bounds"></param>
             <param name="item"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.ItemBoundable`2.Bounds">
            <summary>
            The bounds
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.ItemBoundable`2.Item">
            <summary>
            The item
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.SIRtree`1">
            <summary>
            One-dimensional version of an STR-packed R-tree. SIR stands for
            "Sort-Interval-Recursive". STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.AnonymousAbstractNodeImpl.#ctor(System.Int32)">
             <summary>
            
             </summary>
             <param name="nodeCapacity"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.AnonymousAbstractNodeImpl.ComputeBounds">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.#ctor">
            <summary>
            Constructs an SIRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.#ctor(System.Int32)">
            <summary>
            Constructs an SIRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.Insert(System.Double,System.Double,`0)">
            <summary>
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.Query(System.Double)">
            <summary>
            Returns items whose bounds intersect the given value.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.Query(System.Double,System.Double)">
            <summary>
            Returns items whose bounds intersect the given bounds.
            </summary>
            <param name="x1">Possibly equal to x2.</param>
            <param name="x2">Possibly equal to x1.</param>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.SIRtree`1.IntersectsOp">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SIRtree`1.GetComparer">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.STRtree`1">
            <summary>
            A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.
            For two-dimensional spatial data.
            <para/>
            The STR packed R-tree is simple to implement and maximizes space
            utilization; that is, as many leaves as possible are filled to capacity.
            Overlap between nodes is far less than in a basic R-tree.
            However, the index is semi-static; once the tree has been built
            (which happens automatically upon the first query), items may
            not be added.<br/>
            Items may be removed from the tree using <see cref="M:NetTopologySuite.Index.Strtree.STRtree`1.Remove(NetTopologySuite.Geometries.Envelope,`0)"/>.
            <para/>
            Described in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            <para/>
            <b>Note that inserting items into a tree is not thread-safe.</b>
            Inserting performed on more than one thread must be synchronized externally.
            <para/>
            Querying a tree is thread-safe. The building phase is done synchronously,
            and querying is stateless.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.#ctor">
            <summary>
            Constructs an STRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.#ctor(System.Int32)">
            <summary>
            Constructs an STRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
            <remarks>The minimum recommended capacity setting is 4.</remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.#ctor(System.Int32,NetTopologySuite.Index.Strtree.AbstractNode{NetTopologySuite.Geometries.Envelope,`0})">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have, and the root node
            </summary>
            <retmarks>The minimum recommended capacity setting is 4</retmarks>
            <param name="nodeCapacity">The maximum number of child nodes in a node</param>
            <param name="root">The root node that links to all other nodes in the tree</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.#ctor(System.Int32,System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0}})">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have, and all leaf nodes in the tree
            </summary>
            <retmarks>The minimum recommended capacity setting is 4</retmarks>
            <param name="nodeCapacity">The maximum number of child nodes in a node</param>
            <param name="itemBoundables">The list of leaf nodes in the tree</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.Avg(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CentreX(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CentreY(NetTopologySuite.Geometries.Envelope)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CreateParentBoundables(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0}},System.Int32)">
            <summary>
            Creates the parent level for the given child level. First, orders the items
            by the x-values of the midpoints, and groups them into vertical slices.
            For each slice, orders the items by the y-values of the midpoints, and
            group them into runs of size M (the node capacity). For each run, creates
            a new (parent) node.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CreateParentBoundablesFromVerticalSlices(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0}}[],System.Int32)">
             <summary>
            
             </summary>
             <param name="verticalSlices"></param>
             <param name="newLevel"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CreateParentBoundablesFromVerticalSlice(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0}},System.Int32)">
             <summary>
            
             </summary>
             <param name="childBoundables"></param>
             <param name="newLevel"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.VerticalSlices(System.Collections.Generic.IList{NetTopologySuite.Geometries.IBoundable{NetTopologySuite.Geometries.Envelope,`0}},System.Int32)">
             <summary>
            
             </summary>
             <param name="childBoundables">Must be sorted by the x-value of the envelope midpoints.</param>
             <param name="sliceCount"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.STRtree`1.IntersectsOp">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.Insert(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="itemEnv"></param>
            <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.Query(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.Query(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Index.IItemVisitor{`0})">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.Remove(NetTopologySuite.Geometries.Envelope,`0)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.GetComparer">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})">
            <summary>
            Finds the two nearest items in the tree,
            using <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> as the distance metric.
            A Branch-and-Bound tree traversal algorithm is used
            to provide an efficient search.
            <para/>
            If the tree is empty, the return value is <c>null</c>.
            If the tree contains only one item, the return value is a pair containing that item.
            If it is required to find only pairs of distinct items,
            the <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> function must be <b>anti-reflexive</b>.
            </summary>
            <param name="itemDist">A distance metric applicable to the items in this tree</param>
            <returns>The pair of the nearest items or <c>null</c> if the tree is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Geometries.Envelope,`0,NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})">
            <summary>
            Finds the item in this tree which is nearest to the given <paramref name="item"/>,
            using <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> as the distance metric.
            A Branch-and-Bound tree traversal algorithm is used
            to provide an efficient search.
            <para/>
            The query <paramref name="item"/> does <b>not</b> have to be
            contained in the tree, but it does
            have to be compatible with the <paramref name="itemDist"/>
            distance metric.
            </summary>
            <param name="env">The envelope of the query item</param>
            <param name="item">The item to find the nearest neighbour of</param>
            <param name="itemDist">A distance metric applicable to the items in this tree and the query item</param>
            <returns>The nearest item in this tree or <c>null</c> if the tree is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Index.Strtree.STRtree{`0},NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})">
            <summary>
            Finds the two nearest items from this tree
            and another tree,
            using <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> as the distance metric.
            A Branch-and-Bound tree traversal algorithm is used
            to provide an efficient search.
            The result value is a pair of items,
            the first from this tree and the second
            from the argument tree.
            </summary>
            <param name="tree">Another tree</param>
            <param name="itemDist">A distance metric applicable to the items in the trees</param>
            <returns>The pair of the nearest items, one from each tree or <c>null</c> if no pair of distinct items can be found.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.IsWithinDistance(NetTopologySuite.Index.Strtree.STRtree{`0},NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0},System.Double)">
            <summary>
            Tests whether some two items from this tree and another tree
            lie within a given distance.
            <see cref="T:NetTopologySuite.Index.Strtree.IItemDistance`2"/> is used as the distance metric.
            A Branch-and-Bound tree traversal algorithm is used
            to provide an efficient search.
            </summary>
            <param name="tree">Another tree</param>
            <param name="itemDist">A distance metric applicable to the items in the trees</param>
            <param name="maxDistance">The distance limit for the search</param>
            <returns><c>true</c> if there are items within the distance</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.IsWithinDistance(NetTopologySuite.Index.Strtree.BoundablePair{`0},System.Double)">
            <summary>
            Performs a withinDistance search on the tree node pairs.
            This is a different search algorithm to nearest neighbour.
            It can utilize the <see cref="M:NetTopologySuite.Index.Strtree.BoundablePair`1.MaximumDistance"/> between
            tree nodes to confirm if two internal nodes must
            have items closer than the maxDistance,
            and short-circuit the search.
            </summary>
            <param name="initBndPair">The initial pair containing the tree root nodes</param>
            <param name="maxDistance">The maximum distance to search for</param>
            <returns><c>true</c> if two items lie within the given distance</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Geometries.Envelope,`0,NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0},System.Int32)">
            <summary>
            Finds up to <paramref name="k"/> items in this tree which are the top k nearest neighbors to the given <c>item</c>,
            using <c>itemDist</c> as the distance metric.
            A Branch-and-Bound tree traversal algorithm is used
            to provide an efficient search.
            This method implements the KNN algorithm described in the following paper:
            <para/>
            Roussopoulos, Nick, Stephen Kelley, and Frdric Vincent. "Nearest neighbor queries."
            ACM sigmod record. Vol. 24. No. 2. ACM, 1995.
            <para/>
            The query <c>item</c> does <b>not</b> have to be
            contained in the tree, but it does
            have to be compatible with the <c>itemDist</c>
            distance metric.<para/>
            If the tree size is smaller than k fewer items will be returned.
            If the tree is empty an array of size 0 is returned.
            </summary>
            <param name="env">The envelope of the query item</param>
            <param name="item">The item to find the nearest neighbours of</param>
            <param name="itemDist">A distance metric applicable to the items in this tree and the query item</param>
            <param name="k">The maximum number of nearest items to search for</param>
            <returns>An array of the nearest items found (with length between 0 and <paramref name="k"/>)</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction.Overlap(NetTopologySuite.Index.Sweepline.SweepLineInterval,NetTopologySuite.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="s0"></param>
             <param name="s1"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.SweepLineEvents">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Sweepline.SweepLineEvents.Insert">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Sweepline.SweepLineEvents.Delete">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.SweepLineEvent">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineEvent.#ctor(System.Double,NetTopologySuite.Index.Sweepline.SweepLineEvent,NetTopologySuite.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <param name="insertEvent"></param>
             <param name="sweepInt"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineEvent.IsInsert">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineEvent.IsDelete">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineEvent.InsertEvent">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineEvent.DeleteEventIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineEvent.Interval">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.SweepLineIndex">
            <summary>
            A sweepline implements a sorted index on a set of intervals.
            It is used to compute all overlaps between the interval in the index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineIndex.Add(NetTopologySuite.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="sweepInt"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineIndex.BuildIndex">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineIndex.ComputeOverlaps(NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction)">
             <summary>
            
             </summary>
             <param name="action"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineIndex.ProcessOverlaps(System.Int32,System.Int32,NetTopologySuite.Index.Sweepline.SweepLineInterval,NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="s0"></param>
             <param name="action"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.SweepLineInterval">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double,System.Object)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
             <param name="item"></param>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineInterval.Min">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineInterval.Max">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Sweepline.SweepLineInterval.Item">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Index.VertexSequencePackedRtree">
            <summary>
            A semi-static spatial index for points which occur
            in a spatially-coherent sequence.
            In particular, this is suitable for indexing the vertices
            of a {@link LineString} or {@link Polygon} ring.
            <para/>
            The index is constructed in a batch fashion on a given sequence of coordinates.
            Coordinates can be removed via the {@link #remove(int)} method.
            <para/>
            Note that this index queries only the individual points
            of the input coordinate sequence,
            <b>not</b> any line segments which might be lie between them.
            <para/>
            The input coordinate array is read-only,
            and is not changed when vertices are removed.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Index.VertexSequencePackedRtree.NodeCapacity">
            <summary>
            Number of items/nodes in a parent node.
            Determined empirically.  Performance is not too sensitive to this.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.VertexSequencePackedRtree.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a new tree over the given sequence of coordinates.
            The sequence should be spatially coherent to provide query performance.
            </summary>
            <param name="pts">A sequence of points</param>
        </member>
        <member name="M:NetTopologySuite.Index.VertexSequencePackedRtree.ComputeLevelOffsets">
            <summary>
            Computes the level offsets.
            This is the position in the <tt>bounds</tt> array of each level.
            The levelOffsets array includes a sentinel value of <c>offset[0] = 0</c>.
            The top level is always of size 1,
            and so also indicates the total number of bounds.
            </summary>
            <returns>The level offsets</returns>
        </member>
        <member name="M:NetTopologySuite.Index.VertexSequencePackedRtree.Query(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Queries the index to find all items which intersect an extent.
            The query result is a list of the indices of input coordinates
            which intersect the extent.
            </summary>
            <param name="queryEnv">The query extent</param>
            <returns>An array of the indices of the input coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Index.VertexSequencePackedRtree.RemoveAt(System.Int32)">
            <summary>
            Removes the input item at the given index from the spatial index.
            </summary>
            <remarks>
            This does not change the underlying coordinate array.
            </remarks>
            <param name="index">Index the index of the item in the input</param>
        </member>
        <member name="T:NetTopologySuite.IO.BEBinaryWriter">
            <summary>
            Extends the <see cref="T:System.IO.BinaryWriter" /> class to allow writing values in the BigEndian format.
            </summary>
            <remarks>
            While <see cref="T:NetTopologySuite.IO.BEBinaryWriter" /> extends <see cref="T:System.IO.BinaryWriter" />
            adding methods for writing integer values (<see cref="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Int32)" />)
            and double values (<see cref="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Double)" />) in the BigEndian format,
            this implementation overrides methods, such <see cref="M:System.IO.BinaryWriter.Write(System.Int32)" />
            and <see cref="M:System.IO.BinaryWriter.Write(System.Double)" /> and more,
            for writing <see cref="F:NetTopologySuite.IO.ByteOrder.BigEndian" /> values in the BigEndian format.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.BEBinaryWriter"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.BEBinaryWriter"/> class.
            </summary>
            <param name="output">The supplied stream.</param>
            <exception cref="T:System.ArgumentNullException">output is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.BEBinaryWriter"/> class.
            </summary>
            <param name="output">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
            <exception cref="T:System.ArgumentNullException">output or encoding is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a two-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by two bytes.
            </summary>
            <param name="value">The two-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.UInt16)">
            <summary>
            Writes a two-byte unsigned integer to the current stream  using BigEndian encoding
            and advances the stream position by two bytes.
            </summary>
            <param name="value">The two-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a four-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.UInt32)">
            <summary>
            Writes a four-byte unsigned integer to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Int64)">
            <summary>
            Writes an eight-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.UInt64)">
            <summary>
            Writes an eight-byte unsigned integer to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Single)">
            <summary>
            Writes a four-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BEBinaryWriter.Write(System.Double)">
            <summary>
            Writes an eight-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="T:NetTopologySuite.IO.BiEndianBinaryReader">
            <summary>
            Extends the <see cref="T:System.IO.BinaryReader" /> class to allow reading values in the specified format.
            </summary>
            <remarks>
            While <see cref="T:NetTopologySuite.IO.BiEndianBinaryReader" /> extends <see cref="T:System.IO.BinaryReader" />
            adding methods for reading integer values (<see cref="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadInt32" />)
            and double values (<see cref="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadDouble" />) in the specified format,
            this implementation overrides methods, such <see cref="M:System.IO.BinaryReader.ReadInt32" />
            and <see cref="M:System.IO.BinaryReader.ReadDouble" /> and more,
            for reading values in the specified by <see cref="P:NetTopologySuite.IO.BiEndianBinaryReader.Endianess"/> format.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.BiEndianBinaryReader"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.#ctor(System.IO.Stream,NetTopologySuite.IO.ByteOrder)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.BiEndianBinaryReader"/> class.
            </summary>
            <param name="input">The supplied stream.</param>
            <param name="endianess">The byte order.</param>
            <exception cref="T:System.ArgumentException">The stream does not support reading, the stream is null, or the stream is already closed. </exception>
        </member>
        <member name="P:NetTopologySuite.IO.BiEndianBinaryReader.Endianess">
            <summary>
            Encoding type
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadInt16">
            <summary>
            Reads a 2-byte signed integer from the current stream using the specified encoding
            and advances the current position of the stream by two bytes.
            </summary>
            <returns>
            A 2-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadUInt16">
            <summary>
            Reads a 2-byte unsigned integer from the current stream using the specified encoding
            and advances the position of the stream by two bytes.
            </summary>
            <returns>
            A 2-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadInt32">
            <summary>
            Reads a 4-byte signed integer from the current stream using the specified encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadUInt32">
            <summary>
            Reads a 4-byte unsigned integer from the current stream using the specified encoding
            and advances the position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadInt64">
            <summary>
            Reads an 8-byte signed integer from the current stream using the specified encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadUInt64">
            <summary>
            Reads an 8-byte unsigned integer from the current stream using the specified encoding
            and advances the position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadSingle">
            <summary>
            Reads a 4-byte floating point value from the current stream using the specified encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadDouble">
            <summary>
            Reads an 8-byte floating point value from the current stream using the specified encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadString">
            <summary>
            Reads a string from the current stream.
            The string is prefixed with the length, encoded as an integer seven bits at a time.
            </summary>
            <returns>The string being read.</returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:NetTopologySuite.IO.BiEndianBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the current stream
            and advances the current position of the stream by sixteen bytes.
            </summary>
            <returns>
            A decimal value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="T:NetTopologySuite.IO.ByteOrder">
            <summary>
            Byte order
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.ByteOrder.BigEndian">
            <summary>
            BigEndian
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.ByteOrder.LittleEndian">
            <summary>
            LittleEndian
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.GeometryType">
            <summary>
            Lightweight class that handles OGC Geometry type declaration
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GeometryType.#ctor(System.UInt32)">
            <summary>
            Initializes this instance
            </summary>
            <param name="geometryType">The value describing the <see cref="T:NetTopologySuite.IO.GeometryType"/></param>
        </member>
        <member name="M:NetTopologySuite.IO.GeometryType.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Inititalizes this instance based on a geometry and an Ordinates flag.
            </summary>
            <param name="geometry">The geometry.</param>
            <param name="ordinates">The ordinates flag.</param>
        </member>
        <member name="M:NetTopologySuite.IO.GeometryType.#ctor(NetTopologySuite.Geometries.OgcGeometryType)">
            <summary>
            Inititalizes this instance based on an <see cref="T:NetTopologySuite.Geometries.OgcGeometryType"/>
            </summary>
            <param name="ogcGeometryType">The OGC geometry type</param>
        </member>
        <member name="M:NetTopologySuite.IO.GeometryType.#ctor(NetTopologySuite.Geometries.OgcGeometryType,System.Boolean)">
            <summary>
            Inititalizes this instance based on an <see cref="T:NetTopologySuite.Geometries.OgcGeometryType"/> and an SRID indicator
            </summary>
            <param name="ogcGeometryType">The OGC geometry type</param>
            <param name="hasSrid">Indicator if a SRID is supplied.</param>
        </member>
        <member name="M:NetTopologySuite.IO.GeometryType.#ctor(NetTopologySuite.Geometries.OgcGeometryType,NetTopologySuite.Geometries.Ordinates,System.Boolean)">
            <summary>
            Inititalizes this instance based on an <see cref="T:NetTopologySuite.Geometries.OgcGeometryType"/> and an SRID indicator
            </summary>
            <param name="ogcGeometryType">The OGC geometry type</param>
            <param name="ordinates">The ordinates flag.</param>
            <param name="hasSrid">Indicator if a SRID is supplied.</param>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.BaseGeometryType">
            <summary>
            Gets or sets the base geometry type
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.WkbGeometryType">
            <summary>
            Gets the OGC Well-Known-Binary type code
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.EwkbWkbGeometryType">
            <summary>
            Gets the PostGIS Enhanced Well-Known-Binary type code
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasZ">
            <summary>
            Gets or sets whether z-ordinate values are stored along with the geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasM">
            <summary>
            Gets or sets whether m-ordinate values are stored along with the geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasSrid">
            <summary>
            Gets whether SRID value is stored along with the geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasWkbZ">
            <summary>
            Gets or sets whether z-ordinate values are stored along with the geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasWkbM">
            <summary>
            Gets or sets whether m-ordinate values are stored along with the geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasEwkbZ">
            <summary>
            Gets or sets whether z-ordinates are stored along with the geometry.
            <para>PostGis EWKB format.</para>
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasEwkbM">
            <summary>
            Gets or sets whether z-ordinates are stored along with the geometry.
            <para>PostGis EWKB format.</para>
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GeometryType.HasEwkbSrid">
            <summary>
            Gets or sets whether z-ordinates are stored along with the geometry.
            <para>PostGis EWKB format.</para>
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.GML2.GMLReader">
            <summary>
            Reads a GML document and creates a representation of the features based on NetTopologySuite model.
            Uses GML 2.1.1 <c>Geometry.xsd</c> schema for base for features.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GML2.GMLReader.Factory">
            <summary>
            <see cref="T:NetTopologySuite.Geometries.Geometry"/> builder.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.#ctor">
            <summary>
            Initialize reader with a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Initialize reader with the given <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.Read(System.Xml.XmlDocument)">
            <summary>
            Read a GML document and returns relative <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.Read(System.Xml.Linq.XDocument)">
            <summary>
            Read a GML document and returns relative <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.ReadCoordinate(System.Xml.XmlReader)">
            <summary>
            Reads the coordinate.
            </summary>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.ReadCoordinates(System.String)">
            <summary>
            Extract a <see cref="T:NetTopologySuite.Geometries.Coordinate" /> from a x,y string value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.ReadPosAsCoordinate(System.String[])">
            <summary>
            Extract a <see cref="T:NetTopologySuite.Geometries.Coordinate" /> from a pos entity string value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLReader.ReadPosListAsCoordinates(System.Int32,System.String[])">
            <summary>
            Extract a <see cref="T:NetTopologySuite.Geometries.Coordinate" /> from a x,y string value.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.GML2.GMLVersion">
            <summary>
            Identifies a version of the GML specification.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.GML2.GMLVersion.Two">
            <summary>
            Version 2.1.1 (OGC 02-009).
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.GML2.GMLVersion.Three">
            <summary>
            Version 3.2.2 (OGC 07-036r1 / ISO 19136:2007).
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.GML2.GMLWriter">
            <summary>
            Writes the GML representation of the features of NetTopologySuite model.
            Uses GML 2.1.1 <c>Geometry.xsd</c> schema for base for features.
            <remarks>
            Thanks to <see href="http//www.codeplex.com/Wiki/View.aspx?ProjectName=MsSqlSpatial">rstuven</see> for improvements :)
            </remarks>
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.GML2.GMLWriter.NumberFormatter">
            <summary>
            Formatter for double values of coordinates
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.GML2.GMLWriter"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns an <c>XmlReader</c> with feature informations.
            Use <c>XmlDocument.Load(XmlReader)</c> for obtain a <c>XmlDocument</c> to work.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.Stream)">
            <summary>
            Writes a GML feature into a generic <c>Stream</c>, such a <c>FileStream</c> or other streams.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Coordinate,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="coordinate"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Coordinate[],System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="coordinates"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.WriteCoordinates(NetTopologySuite.Geometries.Coordinate[],System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="coordinates"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.WriteCoordinates(NetTopologySuite.Geometries.CoordinateSequence,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="coordinates"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Geometry,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Point,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.LineString,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.LinearRing,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="linearRing"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.Polygon,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.MultiPoint,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="multiPoint"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.MultiLineString,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="multiLineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.MultiPolygon,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="multiPolygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.Write(NetTopologySuite.Geometries.GeometryCollection,System.Xml.XmlWriter)">
             <summary>
            
             </summary>
             <param name="geometryCollection"></param>
             <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.GeometryCollection)">
             <summary>
            
             </summary>
             <param name="geometryCollection"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.MultiPolygon)">
             <summary>
            
             </summary>
             <param name="multiPolygon"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.MultiLineString)">
             <summary>
            
             </summary>
             <param name="multiLineString"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.MultiPoint)">
             <summary>
            
             </summary>
             <param name="multiPoint"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.Polygon)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.SetByteStreamLength(NetTopologySuite.Geometries.Point)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.GML2.GMLWriter.GetEpsgCode(System.Int32)">
            <summary>
            Provides the EPSG code exposing the SRID of the geometry
            </summary>
            <param name="srid">The SRID of the geometry</param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.IO.GML3.GML3Writer">
            <summary>
            Writes the GML representation of the features of NetTopologySuite model.
            Uses GML 3.2.2 <c>gml.xsd</c> schema for base for features.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.GML3.GML3Writer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.GML3.GML3Writer"/> class.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.KML.KMLReader">
            <summary>
            Constructs <see cref="T:NetTopologySuite.Geometries.Geometry"/> objects from the OGC KML representation.
            Works only with KML geometry elements and may also parse attributes within these elements
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.#ctor">
            <summary>
            Creates a reader that creates objects using the default <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a reader that creates objects using the given <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geometryFactory">The factory used to create <c>Geometry</c>s.</param>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.#ctor(System.String[])">
            <summary>
            Creates a reader that creates objects using the default <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="attributeNames">Names of attributes that should be parsed (i.e. extrude, altitudeMode, tesselate, etc).</param>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.#ctor(NetTopologySuite.Geometries.GeometryFactory,System.String[])">
            <summary>
            Creates a reader that creates objects using the given <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geometryFactory">The factory used to create <c>Geometry</c>s.</param>
            <param name="attributeNames">Names of attributes that should be parsed (i.e. extrude, altitudeMode, tesselate, etc).</param>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.Read(System.String)">
            <summary>
            Reads a KML representation of a <see cref="T:NetTopologySuite.Geometries.Geometry"/> from a <see cref="T:System.String"/>.
            <para/>
            If any attribute names were specified during {@link KMLReader} construction,
            they will be stored as <see cref="T:System.Collections.Generic.IDictionary`2"/> in <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/>.
            </summary>
            <param name="kmlGeometrystring">The string that specifies kml representation of geometry.</param>
            <returns>A <c>Geometry</c></returns>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if a parsing problem occurs.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLReader.Read(System.IO.TextReader)">
            <summary>
            Reads a KML representation of a <see cref="T:NetTopologySuite.Geometries.Geometry"/> from a <see cref="T:System.IO.TextReader"/>.
            <para/>
            If any attribute names were specified during {@link KMLReader} construction,
            they will be stored as <see cref="T:System.Collections.Generic.IDictionary`2"/> in <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/>.
            </summary>
            <param name="kmlStreamReader">The text stream reader.</param>
            <returns>A <c>Geometry</c></returns>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if a parsing problem occurs.</exception>
        </member>
        <member name="T:NetTopologySuite.IO.KML.KMLWriter">
            <summary>
            Writes a formatted string containing the KML representation
            of a JTS <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The output is KML fragments which can be substituted
            wherever the KML <see cref="T:NetTopologySuite.Geometries.Geometry"/> abstract
            element can be used.
            </summary>
            <remarks>
            Output elements are indented to provide a
            nicely-formatted representation.
            An output line prefix and maximum
            number of coordinates per line can be specified.
            </remarks>
            <remarks>
            The Z ordinate value output can be forced to be a specific value.
            The <see cref="P:NetTopologySuite.IO.KML.KMLWriter.Extrude"/> and <see cref="P:NetTopologySuite.IO.KML.KMLWriter.AltitudeMode"/> modes can be set.
            If set, the corresponding sub-elements will be output.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.IO.KML.KMLWriter.AltitudeModeClampToGround">
            <summary>
            The KML standard value <c>clampToGround</c> for use in <see cref="P:NetTopologySuite.IO.KML.KMLWriter.AltitudeMode"/>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.KML.KMLWriter.AltitudeModeRelativeToGround">
            <summary>
            The KML standard value <c>relativeToGround</c> for use in <see cref="P:NetTopologySuite.IO.KML.KMLWriter.AltitudeMode"/>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.KML.KMLWriter.AltitudeModeAbsolute">
            <summary>
            The KML standard value <c>absolute</c> for use in <see cref="P:NetTopologySuite.IO.KML.KMLWriter.AltitudeMode"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.WriteGeometry(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Writes a Geometry as KML to a string, using
            a specified Z value.
            </summary>
            <param name="geometry">the geometry to write</param>
            <param name="z">the Z value to use</param>
            <returns>a string containing the KML geometry representation</returns>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.WriteGeometry(NetTopologySuite.Geometries.Geometry,System.Double,System.Int32,System.Boolean,System.String)">
            <summary>
            Writes a Geometry as KML to a string, using
            a specified Z value, precision, extrude flag,
            and altitude mode code.
            </summary>
            <param name="geometry">the geometry to write</param>
            <param name="z">the Z value to use</param>
            <param name="precision">the maximum number of decimal places to write</param>
            <param name="extrude">the extrude flag to write</param>
            <param name="altitudeMode">the altitude model code to write</param>
            <returns>a string containing the KML geometry representation</returns>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.LinePrefix">
            <summary>
            A tag string which is prefixed to every emitted text line.
            This can be used to indent the geometry text in a containing document.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.MaxCoordinatesPerLine">
            <summary>
            The maximum number of coordinates to output per line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.Z">
            <summary>
            The Z value to be output for all coordinates.
            This overrides any Z value present in the Geometry coordinates.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.Extrude">
            <summary>
            The flag to be output in the <c>extrude</c> element.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.Tesselate">
            <summary>
            The flag to be output in the <c>tesselate</c> element.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.AltitudeMode">
            <summary>
            The value output in the <c>altitudeMode</c> element.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.KML.KMLWriter.Precision">
            <summary>
            The maximum number of decimal places to output in ordinate values.
            Useful for limiting output size.
            </summary>
            <remarks>
            negative values set the precision to <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>,
            like standard behavior.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.Write(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Writes a <see cref="T:NetTopologySuite.Geometries.Geometry"/> in KML format as a string.
            </summary>
            <param name="geom">the geometry to write</param>
            <returns>a string containing the KML geometry representation</returns>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.TextWriter)">
            <summary>
            Writes the KML representation of a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="geom">the geometry to write</param>
            <param name="writer">the writer to write to</param>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.Write(NetTopologySuite.Geometries.Geometry,System.Text.StringBuilder)">
            <summary>
            Appends the KML representation of a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="geom">the geometry to write</param>
            <param name="sb">the buffer to write into</param>
        </member>
        <member name="M:NetTopologySuite.IO.KML.KMLWriter.Write(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Text.StringBuilder)">
            <summary>
            Takes a list of coordinates and converts it to KML.
            </summary>
            <remarks>
            2D and 3D aware. Terminates the coordinate output with a newline.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.IO.OrdinateFormat">
            <summary>
            Formats numeric values for ordinates
            in a consistent, accurate way.
            <para/>
            The format has the following characteristics:
            <list type="Bullet">
            <item>It is consistent in all locales (in particular, the decimal separator is always a period)</item>
            <item><description>Scientific notation is never output, even for very large numbers. This means that it is possible that output can contain a large number of digits. </description></item>
            <item><description>The maximum number of decimal places reflects the available precision</description></item>
            <item><description>NaN values are represented as "NaN"</description></item>
            <item><description>Inf values are represented as "Inf" or "-Inf"</description></item>
            </list>
            </summary>
            <author>mdavis</author>
        </member>
        <member name="F:NetTopologySuite.IO.OrdinateFormat.REP_POS_INF">
            <summary>
             The output representation of <see cref="F:System.Double.PositiveInfinity"/>
             </summary>
        </member>
        <member name="F:NetTopologySuite.IO.OrdinateFormat.REP_NEG_INF">
            <summary>
             The output representation of <see cref="F:System.Double.NegativeInfinity"/>
             </summary>
        </member>
        <member name="F:NetTopologySuite.IO.OrdinateFormat.REP_NAN">
            <summary>
             The output representation of <see cref="F:System.Double.NaN"/>
             </summary>
        </member>
        <member name="F:NetTopologySuite.IO.OrdinateFormat.MAX_FRACTION_DIGITS">
            <summary>
            The maximum number of fraction digits to support output of reasonable ordinate values.
            <para/>
            The default is chosen to allow representing the smallest possible IEEE-754 double-precision value,
            although this is not expected to occur (and is not supported by other areas of the JTS/NTS code).
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.OrdinateFormat.Default">
            <summary>
            The default formatter using the maximum number of digits in the fraction portion of a number.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.OrdinateFormat.#ctor">
            <summary>
            Creates an OrdinateFormat using the default maximum number of fraction digits.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.OrdinateFormat.#ctor(System.Int32)">
            <summary>
            Creates an OrdinateFormat using the given maximum number of fraction digits.
            </summary>
            <param name="maximumFractionDigits">The maximum number of fraction digits to output</param>
        </member>
        <member name="M:NetTopologySuite.IO.OrdinateFormat.Format(System.Double)">
            <summary>
            Returns a string representation of the given ordinate numeric value.
            </summary>
            <param name="ord">The ordinate value</param>
            <returns>The formatted number string</returns>
        </member>
        <member name="T:NetTopologySuite.IO.ParseException">
            <summary>
            Thrown by a <c>WKTReader</c> when a parsing problem occurs.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.ParseException.#ctor(System.String)">
            <summary>
            Creates a <c>ParseException</c> with the given detail message.
            </summary>
            <param name="message">A description of this <c>ParseException</c>.</param>
        </member>
        <member name="M:NetTopologySuite.IO.ParseException.#ctor(System.Exception)">
            <summary>
            Creates a <c>ParseException</c> with <c>e</c>s detail message.
            </summary>
            <param name="e">An exception that occurred while a <c>WKTReader</c> was
            parsing a Well-known Text string.</param>
        </member>
        <member name="M:NetTopologySuite.IO.ParseException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a <c>ParseException</c> with <paramref name="innerException"/>s detail message
            </summary>
            <param name="message"></param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:NetTopologySuite.IO.WKBGeometryTypes">
            <summary>
            WKB Geometry Types
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPoint">
            <summary>
            Point.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBLineString">
            <summary>
            LineString.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPolygon">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPoint">
            <summary>
            MultiPoint.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiLineString">
            <summary>
            MultiLineString.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPolygon">
            <summary>
            MultiPolygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBGeometryCollection">
            <summary>
            GeometryCollection.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPointZ">
            <summary>
            Point with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBLineStringZ">
            <summary>
            LineString with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPolygonZ">
            <summary>
            Polygon with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPointZ">
            <summary>
            MultiPoint with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiLineStringZ">
            <summary>
            MultiLineString with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPolygonZ">
            <summary>
            MultiPolygon with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBGeometryCollectionZ">
            <summary>
            GeometryCollection with Z coordinate.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPointM">
            <summary>
            Point with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBLineStringM">
            <summary>
            LineString with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPolygonM">
            <summary>
            Polygon with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPointM">
            <summary>
            MultiPoint with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiLineStringM">
            <summary>
            MultiLineString with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPolygonM">
            <summary>
            MultiPolygon with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBGeometryCollectionM">
            <summary>
            GeometryCollection with M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPointZM">
            <summary>
            Point with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBLineStringZM">
            <summary>
            LineString with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBPolygonZM">
            <summary>
            Polygon with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPointZM">
            <summary>
            MultiPoint with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiLineStringZM">
            <summary>
            MultiLineString with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBMultiPolygonZM">
            <summary>
            MultiPolygon with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBGeometryTypes.WKBGeometryCollectionZM">
            <summary>
            GeometryCollection with Z coordinate and M ordinate value.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WKBHexFileReader">
            <summary>
            Reads a sequence of {@link Geometry}s in WKBHex format
            from a text file.
            Each WKBHex geometry must be on a single line
            The geometries in the file may be separated by any amount
            of whitespace and newlines.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.#ctor(NetTopologySuite.IO.WKBReader)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.IO.WKBHexFileReader"/> given the
            <see cref="T:NetTopologySuite.IO.WKBReader"/> to use to parse the geometries.
            </summary>
            <param name="wkbReader">The geometry reader to use</param>
        </member>
        <member name="P:NetTopologySuite.IO.WKBHexFileReader.Limit">
            <summary>
            Gets or sets a value indicating the maximum number of geometries to read
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBHexFileReader.Offset">
            <summary>
            Gets or sets the number of geometries to skip before storing.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.Read(System.String)">
            <summary>
            Reads a sequence of geometries.<br/>
            If an <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Offset"/> is specified, geometries read up to the offset count are skipped.
            If a <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> is specified, no more than <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> geometries are read.
            </summary>
            <param name="file">The path to the file</param>
            <exception cref="T:System.ArgumentNullException">Thrown if no filename was specified</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the filename specified does not exist</exception>
            <exception cref="T:System.IO.IOException">Thrown if an I/O exception was encountered</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if an error occurred reading a geometry</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.Read(System.IO.Stream)">
            <summary>
            Reads a sequence of geometries.<br/>
            If an <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Offset"/> is specified, geometries read up to the offset count are skipped.
            If a <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> is specified, no more than <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> geometries are read.
            </summary>
            <param name="stream">The path to the file</param>
            <exception cref="T:System.ArgumentNullException">Thrown if no stream was passed</exception>
            <exception cref="T:System.ArgumentException">Thrown if passed stream is not readable or seekable</exception>
            <exception cref="T:System.IO.IOException">Thrown if an I/O exception was encountered</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if an error occured reading a geometry</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.Read(System.IO.StreamReader)">
            <summary>
            Reads a sequence of geometries.<br/>
            If an <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Offset"/> is specified, geometries read up to the offset count are skipped.
            If a <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> is specified, no more than <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> geometries are read.
            </summary>
            <param name="streamReader">The stream reader to use.</param>
            <exception cref="T:System.IO.IOException">Thrown if an I/O exception was encountered</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if an error occured reading a geometry</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.IsAtLimit(System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Tests if reader has reached limit
            </summary>
            <param name="geoms">A collection of already read geometries</param>
            <returns><c>true</c> if <see cref="P:NetTopologySuite.IO.WKBHexFileReader.Limit"/> number of geometries has been read.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBHexFileReader.IsAtEndOfFile(System.IO.StreamReader)">
            <summary>
            Tests if reader is at EOF.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WKBReader">
            <summary>
            Converts a Well-Known Binary byte data to a <c>Geometry</c>.
            </summary>
            <remarks>
            This class reads the format describe in {@link WKBWriter}.
            It partially handles the<b>Extended WKB</b> format used by PostGIS,
            by parsing and storing optional SRID values.
            If a SRID is not specified in an element geometry, it is inherited
            from the parent's SRID.
            The default SRID value depends on <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/>.
            <para/>
            Although not defined in the WKB spec, empty points
            are handled if they are represented as a Point with <c>NaN</c> X and Y ordinates.
            <para/>
            The reader repairs structurally-invalid input
            (specifically, LineStrings and LinearRings which contain
            too few points have vertices added,
            and non-closed rings are closed).
            <para/>
            The reader handles most errors caused by malformed or malicious WKB data.
            It checks for obviously excessive values of the fields
            <c>numElems</c>, <c>numRings</c>, and <c>numCoords</c>.
            It also checks that the reader does not read beyond the end of the data supplied.
            A <see cref="T:NetTopologySuite.IO.ParseException"/> is thrown if this situation is detected.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.HexToBytes(System.String)">
            <summary>
            Converts a hexadecimal string to a byte array.
            The hexadecimal digit symbols are case-insensitive.
            </summary>
            <param name="hex">A string containing hex digits</param>
            <returns>An array of bytes with the value of the hex string</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.#ctor">
            <summary>
            Initialize reader with a standard <see cref="T:NetTopologySuite.NtsGeometryServices"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.#ctor(NetTopologySuite.NtsGeometryServices)">
            <summary>
            Creates an instance of this class using the provided <c>NtsGeometryServices</c>
            </summary>
            <param name="services"></param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.Read(System.Byte[])">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.Geometry"/> in binary WKB format from an array of <see cref="T:System.Byte"/>s.
            </summary>
            <param name="data">The byte array to read from</param>
            <returns>The geometry read</returns>
            <exception cref="T:NetTopologySuite.IO.ParseException"> if the WKB data is ill-formed.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.Read(System.IO.Stream)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.Geometry"/> in binary WKB format from an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The stream to read from</param>
            <returns>The geometry read</returns>
            <exception cref="T:NetTopologySuite.IO.ParseException"> if the WKB data is ill-formed.</exception>
        </member>
        <member name="T:NetTopologySuite.IO.WKBReader.CoordinateSystem">
            <summary>
            WKB Coordinate Systems
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBReader.CoordinateSystem.XY">
            <summary>
            2D coordinate system
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBReader.CoordinateSystem.XYZ">
            <summary>
            3D coordinate system
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBReader.CoordinateSystem.XYM">
            <summary>
            2D coordinate system with additional measure value
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBReader.CoordinateSystem.XYZM">
            <summary>
            3D coordinate system with additional measure value
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.Read(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadByteOrder(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadCoordinateSequence(System.IO.BinaryReader,System.Int32,NetTopologySuite.IO.WKBReader.CoordinateSystem)">
            <summary>
            Function to read a coordinate sequence.
            </summary>
            <param name="reader">The reader</param>
            <param name="size">The number of ordinates</param>
            <param name="cs">The coordinate system</param>
            <returns>The read coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadCoordinateSequenceRing(System.IO.BinaryReader,System.Int32,NetTopologySuite.IO.WKBReader.CoordinateSystem)">
            <summary>
            Function to read a coordinate sequence that is supposed to form a ring.
            </summary>
            <param name="reader">The reader</param>
            <param name="size">The number of ordinates</param>
            <param name="cs">The coordinate system</param>
            <returns>The read coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadCoordinateSequenceLineString(System.IO.BinaryReader,System.Int32,NetTopologySuite.IO.WKBReader.CoordinateSystem)">
            <summary>
            Function to read a coordinate sequence that is supposed to serve a line string.
            </summary>
            <param name="reader">The reader</param>
            <param name="size">The number of ordinates</param>
            <param name="cs">The coordinate system</param>
            <returns>The read coordinate sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ToOrdinates(NetTopologySuite.IO.WKBReader.CoordinateSystem)">
            <summary>
            Function to convert from <see cref="T:NetTopologySuite.IO.WKBReader.CoordinateSystem"/> to <see cref="T:NetTopologySuite.Geometries.Ordinates"/>
            </summary>
            <param name="cs">The coordinate system</param>
            <returns>The corresponding <see cref="T:NetTopologySuite.Geometries.Ordinates"/></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadPoint(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.Point"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Point"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadLineString(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.LineString"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LineString"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadLinearRing(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.LinearRing"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LinearRing"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadPolygon(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.Polygon"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.Polygon"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadMultiPoint(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadMultiLineString(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadMultiPolygon(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> geometry</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.ReadGeometryCollection(System.IO.BinaryReader,NetTopologySuite.IO.WKBReader.CoordinateSystem,System.Int32)">
            <summary>
            Reads a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> geometry.
            </summary>
            <param name="reader">The reader</param>
            <param name="cs">The coordinate system</param>
            <param name="srid">The spatial reference id for the geometry.</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> geometry</returns>
        </member>
        <member name="P:NetTopologySuite.IO.WKBReader.HandleSRID">
            <summary>
            Gets or sets a value indicating if a possibly encoded SRID value should be handled.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBReader.AllowedOrdinates">
            <summary>
            Gets a value indicating which ordinates can be handled.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBReader.HandleOrdinates">
            <summary>
            Gets a value indicating which ordinates should be handled.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBReader.IsStrict">
            <summary>
            Gets or sets a value indicating if the reader should attempt to repair malformed input.
            </summary>
            <remarks>
            <i>Malformed</i> in this case means the ring has too few points (4),
            or is not closed.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.IO.WKBReader.RepairRings">
            <summary>
            Gets or sets whether invalid linear rings should be fixed
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBReader.HandleOrdinate(NetTopologySuite.Geometries.Ordinate)">
            <summary>
            Function to determine whether an ordinate should be handled or not.
            </summary>
            <param name="ordinate"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.IO.WKBWriter">
            <summary>
            Writes a Well-Known Binary byte data representation of a <c>Geometry</c>.
            </summary>
            <remarks>
            There are a few cases which are not specified in the standard.
            The implementation uses a representation which is compatible with
            other common spatial systems (notably, PostGIS).
            <list type="bullet">
            <item><term><see cref="T:NetTopologySuite.Geometries.LinearRing"/>s</term><description>are written as <see cref="T:NetTopologySuite.Geometries.LineString"/>s.</description></item>
            <item><term>Empty geometries are output as follows</term><description>
            <list type="bullet">
            <item><term><c>Point</c></term><description>A <c>WKBPoint</c> with <c>double.NaN</c> ordinate values</description></item>
            <item><term><c>LineString</c></term><description>A <c>WKBLineString</c> with zero points</description></item>
            <item><term><c>Polygon</c></term><description>currently output as a <c>WKBPolygon</c> with one <c>LinearRing</c> with zero points.
            <i>Note:</i> This is different to other systems. It will change to a <c>WKBPolygon</c> with zero <c>LinearRing</c>s.</description></item>
            <item><term>Multi geometries</term><description>A <c>WKBMulti</c> with zero elements</description></item>
            <item><term><c>GeometryCollection</c></term><description>A <c>WKBGeometryCollection</c> with zero elements</description></item>
            </list>
            </description></item></list>
            <para/>
            This implementation supports the <b>Extended WKB</b> standard.
            Extended WKB allows writing 3-dimensional coordinates
            and the geometry SRID value.
            The presence of 3D coordinates is indicated
            by setting the high bit of the <tt>wkbType</tt> word.
            The presence of a SRID is indicated
            by setting the third bit of the <tt>wkbType</tt> word.
            EWKB format is upward-compatible with the original SFS WKB format.
            <para/>
            SRID output is optimized, if specified.
            The top-level geometry has the SRID included. Child geometries
            have it included if their value differs from its parent.
            <para/>
            This class supports reuse of a single instance to read multiple
            geometries. This class is not thread - safe; each thread should create its own
            instance.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.ToHex(System.Byte[])">
            <summary>Converts a byte array to a hexadecimal string.</summary>
            <param name="bytes">A byte array</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.WriteHeader(System.IO.BinaryWriter,NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Writes the WKB Header for the geometry
            </summary>
            <param name="writer">The writer</param>
            <param name="geom">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="P:NetTopologySuite.IO.WKBWriter.EncodingType">
            <summary>
            Gets or sets the binary encoding type
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBWriter.InitCount">
            <summary>
            Standard byte size for each complex point.
            Each complex point (LineString, Polygon, ...) contains:
                1 byte for ByteOrder and
                4 bytes for WKBType.
                4 bytes for SRID value
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetHeaderSize(System.Boolean)">
            <summary>
            Calculates the number of bytes required to store (E)WKB Header information.
            </summary>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The size of the </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.#ctor">
            <summary>
            Initializes writer with LittleIndian byte order.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.#ctor(NetTopologySuite.IO.ByteOrder)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.#ctor(NetTopologySuite.IO.ByteOrder,System.Boolean)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
            <param name="handleSRID">SRID values, present or not, should be emitted.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.#ctor(NetTopologySuite.IO.ByteOrder,System.Boolean,System.Boolean)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
            <param name="handleSRID">SRID values, present or not, should be emitted.</param>
            <param name="emitZ">Z values, present or not, should be emitted</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.#ctor(NetTopologySuite.IO.ByteOrder,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
            <param name="handleSRID">SRID values, present or not, should be emitted.</param>
            <param name="emitZ">Z values, present or not, should be emitted</param>
            <param name="emitM">M values, present or not, should be emitted</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.Stream)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.WriteByteOrder(System.IO.BinaryWriter)">
            <summary>
            Writes the ByteOrder defined in <see cref="P:NetTopologySuite.IO.WKBWriter.EncodingType"/>.
            </summary>
            <param name="writer">The writer to use</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Coordinate,System.IO.BinaryWriter)">
            <summary>
            Write a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="coordinate">The coordinate</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.CoordinateSequence,System.Boolean,System.IO.BinaryWriter)">
            <summary>
            Write a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <param name="sequence">The coordinate sequence to write</param>
            <param name="emitSize">A flag indicating if the size of <paramref name="sequence"/> should be written, too.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Point,System.IO.BinaryWriter)">
            <summary>
            Write a point in its WKB format
            </summary>
            <param name="point">The point</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Point,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a point in its WKB format
            </summary>
            <param name="point">The point</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.LineString,System.IO.BinaryWriter)">
            <summary>
            Write a LineString in its WKB format
            </summary>
            <param name="lineString">The LineString</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.LineString,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a LineString in its WKB format
            </summary>
            <param name="lineString">The LineString</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.LinearRing,System.IO.BinaryWriter)">
            <summary>
            Write LinearRing information
            </summary>
            <param name="ring">The linear ring</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Polygon,System.IO.BinaryWriter)">
            <summary>
            Write a Polygon in its WKB format
            </summary>
            <param name="polygon">The Polygon</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.Polygon,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a Polygon in its WKB format
            </summary>
            <param name="polygon">The Polygon</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiPoint,System.IO.BinaryWriter)">
            <summary>
            Write a MultiPoint in its WKB format
            </summary>
            <param name="multiPoint">The MultiPoint</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiPoint,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a MultiPoint in its WKB format
            </summary>
            <param name="multiPoint">The MultiPoint</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiLineString,System.IO.BinaryWriter)">
            <summary>
            Write a MultiLineString in its WKB format
            </summary>
            <param name="multiLineString">The MultiLineString</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiLineString,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a MultiLineString in its WKB format
            </summary>
            <param name="multiLineString">The MultiLineString</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiPolygon,System.IO.BinaryWriter)">
            <summary>
            Write a MultiPolygon in its WKB format
            </summary>
            <param name="multiPolygon">The MultiPolygon</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.MultiPolygon,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a MultiPolygon in its WKB format
            </summary>
            <param name="multiPolygon">The MultiPolygon</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.GeometryCollection,System.IO.BinaryWriter)">
            <summary>
            Write a GeometryCollection in its WKB format
            </summary>
            <param name="geomCollection">The GeometryCollection</param>
            <param name="writer">The writer</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.Write(NetTopologySuite.Geometries.GeometryCollection,System.IO.BinaryWriter,System.Boolean)">
            <summary>
            Write a GeometryCollection in its WKB format
            </summary>
            <param name="geomCollection">The GeometryCollection</param>
            <param name="writer">The writer</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetBytes(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets a buffer for the <see cref="T:System.IO.MemoryStream"/> to write <paramref name="geometry"/> to.
            </summary>
            <param name="geometry">The geometry to write</param>
            <returns>A buffer</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetBuffer(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Gets a buffer for the <see cref="T:System.IO.MemoryStream"/> to write <paramref name="geometry"/> to.
            </summary>
            <param name="geometry">The geometry to write</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>A buffer</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the length of a buffer to write <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Computes the length of a buffer to write <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.GeometryCollection)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.GeometryCollection,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.MultiPolygon)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.MultiPolygon,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.MultiLineString)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.MultiLineString,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.MultiPoint)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.MultiPoint,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.Polygon"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.Polygon,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.Polygon"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.LineString)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.LineString"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.LineString,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.LineString"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.SetByteStream(NetTopologySuite.Geometries.Point)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.Point"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKBWriter.GetRequiredBufferSize(NetTopologySuite.Geometries.Point,System.Boolean)">
            <summary>
            Computes the length of a buffer to write the <see cref="T:NetTopologySuite.Geometries.Point"/> <paramref name="geometry"/> in its WKB format.
            </summary>
            <param name="geometry">The geometry</param>
            <param name="includeSRID">
            A flag indicting if SRID value is of possible interest.
            The value is <c>&amp;&amp;</c>-combineed with <c>HandleSRID</c>.
            </param>
            <returns>The number of bytes required to store <paramref name="geometry"/> in its WKB format.</returns>
        </member>
        <member name="F:NetTopologySuite.IO.WKBWriter._strict">
            <summary>
            Gets a value whether or not EWKB featues may be used.
            <para/>EWKB features are
            <list type="bullet">
            <item><description><c>0x80000000</c> flag if geometry's z-ordinate values are written</description></item>
            <item><description><c>0x40000000</c> flag if geometry's m-ordinate values are written</description></item>
            <item><description><c>0x20000000</c> flag if geometry's SRID value is written</description></item></list>
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBWriter.Strict">
            <summary>
            Gets a value indicating if only original WKT elements should be handled
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBWriter.HandleSRID">
            <summary>
            Gets or sets a value indicating if an encoded SRID value should be handled or ignored.
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKBWriter.AllowedOrdinates">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> that this class can write.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKBWriter.HandleOrdinates">
            <summary>
            Gets or sets the maximum <see cref="T:NetTopologySuite.Geometries.Ordinates"/> to write out.
            The default is equivalent to <see cref="F:NetTopologySuite.IO.WKBWriter.AllowedOrdinates"/>.
            </summary>
            <remarks>
            <para>
            The purpose of this property is to <b>restrict</b> what gets written out to ensure that,
            e.g., Z values are never written out even if present on a geometry instance.  Ordinates
            that are not present on a geometry instance will be omitted regardless of this value.
            </para>
            <para>
            Flags not present in <see cref="F:NetTopologySuite.IO.WKBWriter.AllowedOrdinates"/> are silently ignored.
            </para>
            <para>
            <see cref="F:NetTopologySuite.Geometries.Ordinates.X"/> and <see cref="F:NetTopologySuite.Geometries.Ordinates.Y"/> are always present.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.IO.WKTConstants">
            <summary>
            Constants used in the WKT (Well-Known Text) format.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.GEOMETRYCOLLECTION">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.LINEARRING">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.LinearRing"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.LINESTRING">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.LineString"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.MULTIPOLYGON">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.MULTILINESTRING">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.MULTIPOINT">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.POINT">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.Point"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.POLYGON">
            <summary>
            Token text for <see cref="T:NetTopologySuite.Geometries.Polygon"/> geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.EMPTY">
            <summary>
            Token text for empty geometries
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.M">
            <summary>
            Token text indicating that geometries have measure-ordinate values
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.Z">
            <summary>
            Token text indicating that geometries have z-ordinate values
            </summary>
        </member>
        <member name="F:NetTopologySuite.IO.WKTConstants.ZM">
            <summary>
            Token text indicating that geometries have both z- and measure-ordinate values
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WKTFileReader">
            <summary>
            Reads a sequence of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s in WKT format from a text file.
            </summary>
            <remarks>The geometries in the file may be separated by any amount of whitespace and newlines.</remarks>
            <author>
            Martin Davis
            </author>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.#ctor(System.IO.FileInfo,NetTopologySuite.IO.WKTReader)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.IO.WKTFileReader" /> given the <paramref name="file" /> to read from and a <see cref="T:NetTopologySuite.IO.WKTReader" /> to use to parse the geometries.
            </summary>
            <param name="file"> the <see cref="T:System.IO.FileInfo" /> to read from</param>
            <param name="wktReader">the geometry reader to use</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.#ctor(System.String,NetTopologySuite.IO.WKTReader)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.IO.WKTFileReader" />, given the name of the file to read from.
            </summary>
            <param name="filename">The name of the file to read from</param>
            <param name="wktReader">The geometry reader to use</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.#ctor(System.IO.Stream,NetTopologySuite.IO.WKTReader)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.IO.WKTFileReader" />, given a <see cref="T:System.IO.Stream"/> to read from.
            </summary>
            <param name="stream">The stream to read from</param>
            <param name="wktReader">The geometry reader to use</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.#ctor(System.IO.TextReader,NetTopologySuite.IO.WKTReader)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.IO.WKTFileReader" />, given a <see cref="T:System.IO.TextReader"/> to read with.
            </summary>
            <param name="reader">The stream reader of the file to read from</param>
            <param name="wktReader">The geometry reader to use</param>
        </member>
        <member name="P:NetTopologySuite.IO.WKTFileReader.Limit">
            <summary>
            Gets/Sets the maximum number of geometries to read.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTFileReader.StrictParsing">
            <summary>
            Gets/Sets allow ignoring WKT parse errors
            after at least one geometry has been read,
            to return a partial result.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTFileReader.Offset">
            <summary>
            Gets/Sets the number of geometries to skip before reading.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.Read">
            <summary>
            Reads a sequence of geometries.
            </summary>
            <remarks>
            <para>
            If an offset is specified, geometries read up to the offset count are skipped.</para>
            <para>If a limit is specified, no more than <see cref="P:NetTopologySuite.IO.WKTFileReader.Limit" /> geometries are read.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">Thrown if an I/O exception was encountered</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">Thrown if an error occurred reading a geometry</exception>
            <returns>The list of geometries read</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTFileReader.IsAtEndOfFile(System.IO.StreamReader)">
            <summary>
            Tests if reader is at EOF.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WKTReader">
             <summary>
             Converts a Well-Known Text string to a <c>Geometry</c>.
            
             The <c>WKTReader</c> allows
             extracting <c>Geometry</c> objects from either input streams or
             internal strings. This allows it to function as a parser to read <c>Geometry</c>
             objects from text blocks embedded in other data formats (e.g. XML).
            
             The Well-known
             Text format is defined in the <A HREF="http://www.opengis.org/techno/specs.htm">
             OpenGIS Simple Features Specification for SQL</A> .
             <para/>
             As of version 2.0, NTS can read WKT syntax
             which specifies coordinate dimension Z, M or ZM as modifiers(e.g.POINT Z)
             or in the name of the geometry type(e.g.LINESTRINGZM).
             If the coordinate dimension is specified it will be set in the created geometry.
             If the coordinate dimension is not specified, the default behaviour is to
             create XYZ geometry(this is backwards compatible with older JTS versions).
             This can be altered to create XY geometry by
             setting <see cref="P:NetTopologySuite.IO.WKTReader.IsOldNtsCoordinateSyntaxAllowed"/> to <c>false</c>.
             <para/>
             A reader can be set to ensure the input is structurally valid
             by setting <see cref="P:NetTopologySuite.IO.WKTReader.FixStructure"/> to <c>true</c>.
             This ensures that geometry can be constructed without errors due to missing coordinates.
             The created geometry may still be topologically invalid.
             <para/>
             NOTE:  There is an inconsistency in the SFS.
             The WKT grammar states that <c>MultiPoints</c> are represented by
             <c>MULTIPOINT ( ( x y), (x y) )</c>,
             but the examples show <c>MultiPoint</c>s as <c>MULTIPOINT ( x y, x y )</c>.
             Other implementations follow the latter syntax, so NTS will adopt it as well.
             A <c>WKTReader</c> is parameterized by a <c>GeometryFactory</c>,
             to allow it to create <c>Geometry</c> objects of the appropriate
             implementation. In particular, the <c>GeometryFactory</c> will
             determine the <c>PrecisionModel</c> and <c>SRID</c> that is used.
             The <c>WKTReader</c> will convert the input numbers to the precise
             internal representation.
             <remarks>
             <see cref="T:NetTopologySuite.IO.WKTReader" /> reads also non-standard <see cref="F:NetTopologySuite.IO.WKTConstants.LINEARRING"/> tags.
             </remarks>
             </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.#ctor">
            <summary>
            Creates a <c>WKTReader</c> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.#ctor(NetTopologySuite.NtsGeometryServices)">
            <summary>
            Creates a <c>WKTReader</c> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a <c>WKTReader</c> that creates objects using the given
            <c>GeometryFactory</c>.
            </summary>
            <param name="factory">The factory used to create <c>Geometry</c>s.</param>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.IsOldNtsCoordinateSyntaxAllowed">
            <summary>
            Gets or sets a value indicating whether or not coordinates may have 3 ordinate values
            even though no Z or M ordinate indicator is present.  The default value is
            <see langword="true"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.IsOldNtsMultiPointSyntaxAllowed">
            <summary>
            Gets or sets a value indicating whether or not point coordinates in a MultiPoint
            geometry must not be enclosed in paren.  The default value is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.FixStructure">
            <summary>
            Gets or sets a flag indicating that the structure of input geometry should be fixed
            so that the geometry can be constructed without error.<br/>
            This involves adding coordinates if the input coordinate sequence is shorter than required.
            </summary>
            <seealso cref="F:NetTopologySuite.Geometries.LineString.MinimumValidSize"/>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.Factory">
            <summary>
            Gets or sets the factory to create geometries
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.DefaultSRID">
            <summary>
            Gets or sets the default SRID
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTReader.IsStrict">
            <summary>
            Gets or sets a value indicating if the reader should attempt to repair malformed input.
            </summary>
            <remarks>
            <i>Malformed</i> in this case means the ring has too few points (4),
            or is not closed.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.Read(System.String)">
            <summary>
            Converts a Well-known Text representation to a <c>Geometry</c>.
            </summary>
            <param name="wellKnownText">
            one or more Geometry Tagged Text strings (see the OpenGIS
            Simple Features Specification) separated by whitespace.
            </param>
            <returns>
            A <c>Geometry</c> specified by <c>wellKnownText</c>
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.Read(System.IO.Stream)">
            <summary>
            Converts a Well-known Text representation to a <c>Geometry</c>.
            </summary>
            <param name="stream">
            one or more Geometry Tagged Text strings (see the OpenGIS
            Simple Features Specification) separated by whitespace.
            </param>
            <returns>
            A <c>Geometry</c> specified by <c>wellKnownText</c>
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.Read(System.IO.TextReader)">
            <summary>
            Converts a Well-known Text representation to a <c>Geometry</c>.
            </summary>
            <param name="reader">
            A Reader which will return a "Geometry Tagged Text"
            string (see the OpenGIS Simple Features Specification).
            </param>
            <returns>A <c>Geometry</c> read from <c>reader</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetCoordinate(NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.Ordinates,System.Boolean)">
            <summary>
            Reads a <c>Coordinate</c> from a stream using the given <see cref="T:RTools_NTS.Util.StreamTokenizer"/>.
            <para>
            All ordinate values are read, but -depending on the <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/>
            of the underlying <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>- not necessarily all can be handled.
            Those are silently dropped.
            </para>
            </summary>
            <param name="factory">A geometry factory</param>
            <param name="tokens">the tokenizer to use.</param>
            <param name="ordinateFlags">a bit-mask defining the ordinates to read.</param>
            <param name="tryParen">a value indicating if a starting "<c>(</c>" should be probed.</param>
            <returns>a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> of appropriate dimension containing the read ordinate values.</returns>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">if an unexpected token was encountered.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetCoordinateSequence(NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.Ordinates,System.Int32,System.Boolean)">
            <summary>
            Reads a <c>Coordinate</c> from a stream using the given <see cref="T:RTools_NTS.Util.StreamTokenizer"/>.
            <para>
            All ordinate values are read, but -depending on the <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/>
            of the underlying <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>- not necessarily all can be handled.
            Those are silently dropped.
            </para>
            </summary>
            <param name="factory">A geometry factory</param>
            <param name="tokens">the tokenizer to use.</param>
            <param name="ordinateFlags">a bit-mask defining the ordinates to read.</param>
            <param name="minSize">The minumum number of coordinates that have to be in the sequence</param>
            <param name="isRing">A flag indicating if the sequence should form a ring</param>
            <returns>a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> of length 1 containing the read ordinate values.</returns>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">if an unexpected token was encountered.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetCoordinateSequenceOldMultiPoint(NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Reads a <c>CoordinateSequence</c> from a stream using the given <see cref="T:RTools_NTS.Util.StreamTokenizer"/>
            for an old-style JTS MultiPoint (Point coordinates not enclosed in parentheses).
            <para>
            All ordinate values are read, but -depending on the <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/>
            of the underlying <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>- not necessarily all can be handled.
            Those are silently dropped.
            </para>
            </summary>
            <param name="factory">A geometry factory</param>
            <param name="tokens">the tokenizer to use.</param>
            <param name="ordinateFlags">a bit-mask defining the ordinates to read.</param>
            <returns>a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> of length 1 containing the read ordinate values.</returns>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">if an unexpected token was encountered.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ToDimension(NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Computes the required dimension based on the given ordinate bit-mask.
            It is assumed that <see cref="F:NetTopologySuite.Geometries.Ordinates.XY"/> is set.
            </summary>
            <param name="ordinateFlags">the ordinate bit-mask.</param>
            <returns>the number of dimensions required to store ordinates for the given bit-mask.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.IsNumberNext(NetTopologySuite.Utilities.TokenStream)">
             <summary>
            
             </summary>
             <param name="tokens"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.IsOpenerNext(NetTopologySuite.Utilities.TokenStream)">
             <summary>
            
             </summary>
             <param name="tokens"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextNumber(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next number in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be a number.
            </param>
            <returns>The next number in the stream.</returns>
            <exception cref="T:NetTopologySuite.IO.ParseException">if the next token is not a valid number</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextEmptyOrOpener(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next WKTConstants.EMPTY or "(" in the stream as uppercase text.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be <see cref="F:NetTopologySuite.IO.WKTConstants.EMPTY"/> or "(".
            </param>
            <returns>
            The next WKTConstants.EMPTY or "(" in the stream as uppercase text.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextOrdinateFlags(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next ordinate flag information in the stream as uppercase text.
            This can be Z, M or ZM.
            </summary>
            <param name="tokens">tokenizer over a stream of text in Well-known Text</param>
            <returns>the next ordinate flags.</returns>
            <exception cref="T:System.IO.IOException">if an I/O error occurs</exception>
            <exception cref="T:NetTopologySuite.IO.ParseException">if the next token is not EMPTY or L_PAREN</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.LookAheadWord(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next word in the stream.
            </summary>
            <param name="tokens">tokenizer over a stream of text in Well-known Text format. The next token must be a word.</param>
            <returns>the next word in the stream as uppercase text</returns>
            <exception cref="T:NetTopologySuite.IO.ParseException">if the next token is not a word</exception>
            <exception cref="T:System.IO.IOException">if an I/O error occurs</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextCloserOrComma(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next ")" or "," in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be ")" or ",".
            </param>
            <returns>
            The next ")" or "," in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextCloser(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Returns the next ")" in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be ")".
            </param>
            <returns>
            The next ")" in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.GetNextWord(NetTopologySuite.Utilities.TokenStream,System.Boolean)">
            <summary>
            Returns the next word in the stream as uppercase text.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be a word.
            </param>
            <param name="advance">
            <see langword="true"/> to advance the stream, <see langword="false"/> to just peek.
            </param>
            <returns>The next word in the stream as uppercase text.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadGeometryTaggedText(NetTopologySuite.Utilities.TokenStream)">
            <summary>
            Creates a <c>Geometry</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;Geometry Tagged Text.
            </param>
            <returns>A <c>Geometry</c> specified by the next token
            in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadPointText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>Point</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a &lt;Point Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>A <c>Point</c> specified by the next token in
            the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadLineStringText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>LineString</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a &lt;LineString Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>LineString</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadLinearRingText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>LinearRing</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a &lt;LineString Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>A <c>LinearRing</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadMultiPointText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>MultiPoint</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a &lt;MultiPoint Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>MultiPoint</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadPolygonText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>Polygon</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a Polygon Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>Polygon</c> specified by the next token
            in the stream.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadMultiLineStringText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>MultiLineString</c> using the next token in the stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a MultiLineString Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>MultiLineString</c> specified by the
            next token in the stream.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadMultiPolygonText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>MultiPolygon</c> using the next token in the stream.
            </summary>
            <param name="tokens">Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a MultiPolygon Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>MultiPolygon</c> specified by the next
            token in the stream, or if if the coordinates used to create the
            <c>Polygon</c> shells and holes do not form closed linestrings.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTReader.ReadGeometryCollectionText(NetTopologySuite.Utilities.TokenStream,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.Ordinates)">
            <summary>
            Creates a <c>GeometryCollection</c> using the next token in the
            stream.
            </summary>
            <param name="tokens">
              Tokenizer over a stream of text in Well-known Text
              format. The next tokens must form a &lt;GeometryCollection Text.
            </param>
            <param name="factory">The factory to create the geometry</param>
            <param name="ordinateFlags">A flag indicating the ordinates to expect.</param>
            <returns>
            A <c>GeometryCollection</c> specified by the
            next token in the stream.</returns>
        </member>
        <member name="T:NetTopologySuite.IO.WKTWriter">
            <summary>
            Outputs the textual representation of a <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            The <see cref="T:NetTopologySuite.IO.WKTWriter" /> outputs coordinates rounded to the precision
            model. No more than the maximum number of necessary decimal places will be
            output.
            The Well-known Text format is defined in the <A
            HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
            Specification for SQL</A>.
            A non-standard "LINEARRING" tag is used for LinearRings. The WKT spec does
            not define a special tag for LinearRings. The standard tag to use is
            "LINESTRING".
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.ToPoint(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Generates the WKT for a <c>Point</c> specified by a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="p0">The point coordinate.</param>
            <returns>The WKT</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.ToLineString(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Generates the WKT for a N-point <c>LineString</c> specified by a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <param name="seq">The sequence to write.</param>
            <returns>The WKT</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.ToLineString(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Generates the WKT for a <tt>LINESTRING</tt> specified by an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="coord">An array of coordinates</param>
            <returns>The WKT</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.ToLineString(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Generates the WKT for a <c>LineString</c> specified by two <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="p0">The first coordinate.</param>
            <param name="p1">The second coordinate.</param>
            <returns>The WKT</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.CreateFormatter(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates the <c>NumberFormatInfo</c> used to write <c>double</c>s
            with a sufficient number of decimal places.
            </summary>
            <param name="precisionModel">
            The <c>PrecisionModel</c> used to determine
            the number of decimal places to write.
            </param>
            <returns>
            A <c>NumberFormatInfo</c> that write <c>double</c>s
            without scientific notation.
            </returns>
        </member>
        <member name="T:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter">
            <summary>
            A filter implementation to test if a coordinate sequence actually has meaningful values
            for an ordinate bit-pattern
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter.#ctor(NetTopologySuite.Geometries.Ordinates,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter"/> flag.
            </summary>
            <param name="checkOrdinateFlags">
            The index for the ordinates to test.
            </param>
            <param name="alwaysEmitZWithM">
            <see langword="true"/> if <see cref="F:NetTopologySuite.Geometries.Ordinates.M"/> implies
            <see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/>, <see langword="false"/> otherwise.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence)">
            <inheritdoc />
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter.GeometryChanged">
            <inheritdoc />
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter.Done">
            <inheritdoc />
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter.OutputOrdinates">
            <summary>
            Gets the evaluated ordinate bit-pattern of ordinates with valid values masked by
            <see cref="F:NetTopologySuite.IO.WKTWriter.CheckOrdinatesFilter._checkOrdinateFlags"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.#ctor">
            <summary>
            Creates an instance of this class which is writing at most 2 dimensions.
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.#ctor(System.Int32)">
            <summary>
            Creates an instance of this class which is writing at most <paramref name="outputDimension"/> dimensions.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.Formatted">
            <summary>
            Gets/sets whether the output will be formatted
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.MaxCoordinatesPerLine">
            <summary>
            Gets/sets the maximum number of coordinates per line written in formatted output.
            </summary>
            <remarks>If the provided coordinate number is &lt; 0, coordinates will be written all on one line.</remarks>
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.Tab">
            <summary>Gets/sets the tab size to use for indenting.</summary>
            <exception cref="T:System.ArgumentException">If the size is non-positive</exception>
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.OutputOrdinates">
            <summary>
            Gets or sets the <see cref="T:NetTopologySuite.Geometries.Ordinates"/> to be written.  Possible members are:
            <list type="bullet">
            <item><description><see cref="F:NetTopologySuite.Geometries.Ordinates.X"/></description></item>
            <item><description><see cref="F:NetTopologySuite.Geometries.Ordinates.Y"/></description></item>
            <item><description><see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/></description></item>
            <item><description><see cref="F:NetTopologySuite.Geometries.Ordinates.M"/></description></item>
            </list>
            Values of <see cref="F:NetTopologySuite.Geometries.Ordinates.X"/> and <see cref="F:NetTopologySuite.Geometries.Ordinates.Y"/> are always assumed and
            not particularly checked for.
            </summary>
        </member>
        <member name="P:NetTopologySuite.IO.WKTWriter.PrecisionModel">
            <summary>
            Gets or sets a <see cref="P:NetTopologySuite.IO.WKTWriter.PrecisionModel"/> that should be used on the ordinates written.
            <para>
            If none/<see langword="null"/> is assigned, the precision model of the
            <see cref="P:NetTopologySuite.Geometries.Geometry.Factory"/> is used.
            </para>
            <para>
            Note: The precision model is applied to all ordinate values, not just x and y.
            </para>
            </summary>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.ForMicrosoftSqlServer">
            <summary>
            Creates a new instance of the <see cref="T:NetTopologySuite.IO.WKTWriter"/> class suitable for MSSQL's non-
            standard WKT format.
            </summary>
            <returns>
            A new instance of the <see cref="T:NetTopologySuite.IO.WKTWriter"/> class suitable for MSSQL's non-standard
            WKT format.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.Write(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <returns>A Geometry Tagged Text string (see the OpenGIS Simple Features Specification).</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.Stream)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <param name="stream">A <c>Stream</c> to write into</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.Write(NetTopologySuite.Geometries.Geometry,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <param name="writer"></param>
            <returns>A "Geometry Tagged Text" string (see the OpenGIS Simple Features Specification)</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.WriteFormatted(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <returns>
            A "Geometry Tagged Text" string (see the OpenGIS Simple
            Features Specification), with newlines and spaces.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.WriteFormatted(NetTopologySuite.Geometries.Geometry,System.IO.TextWriter)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="writer"></param>
            <returns>
            A Geometry Tagged Text string (see the OpenGIS Simple
            Features Specification), with newlines and spaces.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.WriteFormatted(NetTopologySuite.Geometries.Geometry,System.Boolean,System.IO.TextWriter,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="useFormatting">A flag indicating that the output should be formatted.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="precisionModel">The precision model to use.</param>
            <returns>
            A "Geometry Tagged Text" string (see the OpenGIS Simple
            Features Specification).
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendGeometryTaggedText(NetTopologySuite.Geometries.Geometry,System.Boolean,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to &lt;Geometry Tagged Text&gt; format, then appends
            it to the writer.
            </summary>
            <param name="geometry">the <see cref="T:NetTopologySuite.Geometries.Geometry"/> to process.</param>
            <param name="useFormatting">A flag indicating that the output should be formatted.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendGeometryTaggedText(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to &lt;Geometry Tagged Text&gt; format, then appends
            it to the writer.
            </summary>
            <param name="geometry">the <see cref="T:NetTopologySuite.Geometries.Geometry"/> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted.</param>
            <param name="level">The indentation level</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendPointTaggedText(NetTopologySuite.Geometries.Point,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>Coordinate</c> to Point Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="point">The <c>Point</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendLineStringTaggedText(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>LineString</c> to &lt;LineString Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="lineString">The <c>LineString</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendLinearRingTaggedText(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>LinearRing</c> to &lt;LinearRing Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="linearRing">The <c>LinearRing</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendPolygonTaggedText(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiPointTaggedText(NetTopologySuite.Geometries.MultiPoint,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multipoint">The <c>MultiPoint</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiLineStringTaggedText(NetTopologySuite.Geometries.MultiLineString,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiLineString</c> to MultiLineString Tagged
            Text format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiPolygonTaggedText(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiPolygon</c> to MultiPolygon Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendGeometryCollectionTaggedText(NetTopologySuite.Geometries.GeometryCollection,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollection
            Tagged Text format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that the output should be formatted</param>
            <param name="level">the indentation level</param>
            <param name="writer">The output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendCoordinate(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Ordinates,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Appends the i'th coordinate from the sequence to the writer
            <para>
            If the <paramref name="seq"/> has coordinates that are <see cref="M:System.Double.IsNaN(System.Double)">NaN</see>,
            these are not written, even though <see cref="F:NetTopologySuite.IO.WKTWriter._outputDimension"/> suggests this.
            </para>
            </summary>
            <param name="seq">the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to process</param>
            <param name="outputOrdinates">A bit pattern of output ordinates</param>
            <param name="i">the index of the coordinate to write</param>
            <param name="writer">writer the output writer to append to</param>
            <param name="ordinateFormat">The format to use for writing ordinate values</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.WriteNumber(System.Double,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <see cref="T:System.Double" /> to a <see cref="T:System.String" />.
            </summary>
            <param name="d">The <see cref="T:System.Double" /> to convert.</param>
            <param name="ordinateFormat">A</param>
            <returns>
            The <see cref="T:System.Double" /> as a <see cref="T:System.String" />.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendOrdinateText(NetTopologySuite.Geometries.Ordinates,System.IO.TextWriter)">
            <summary>
            Appends additional ordinate information. This function may
            <list type="bullet">
            <item>
            <description>
            append 'Z' if in <paramref name="outputOrdinates"/> the <see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/> value is included.
            </description>
            </item>
            <item>
            <description>
            append 'M' if in <paramref name="outputOrdinates"/> the <see cref="F:NetTopologySuite.Geometries.Ordinates.M"/> value is included.
            </description>
            </item>
            <item>
            <description>
            append 'ZM' if in <paramref name="outputOrdinates"/> the <see cref="F:NetTopologySuite.Geometries.Ordinates.Z"/> and
            <see cref="F:NetTopologySuite.Geometries.Ordinates.M"/> values are included.
            </description>
            </item>
            </list>
            </summary>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="writer">the output writer to append to.</param>
            <exception cref="T:System.IO.IOException">if an error occurs while using the writer.</exception>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendSequenceText(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.Boolean,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Appends all members of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to the stream. Each
            <see cref="T:NetTopologySuite.Geometries.Coordinate"/> is separated from another using a colon, the ordinates of a
            <see cref="T:NetTopologySuite.Geometries.Coordinate"/> are separated by a space.
            </summary>
            <param name="seq">the <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="indentFirst">flag indicating that the first <see cref="T:NetTopologySuite.Geometries.Coordinate"/> of the sequence should be indented for better visibility.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendPolygonText(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.Boolean,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Text format, then
            appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="indentFirst">flag indicating that the first <see cref="T:NetTopologySuite.Geometries.Coordinate"/> of the sequence should be indented for better visibility.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiPointText(NetTopologySuite.Geometries.MultiPoint,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Text format, then
            appends it to the writer.
            </summary>
            <param name="multiPoint">The <c>MultiPoint</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiLineStringText(NetTopologySuite.Geometries.MultiLineString,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiLineString</c> to &lt;MultiLineString Text
            format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendMultiPolygonText(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>MultiPolygon</c> to &lt;MultiPolygon Text format,
            then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="outputOrdinates">A bit-pattern of ordinates to write.</param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WKTWriter.AppendGeometryCollectionText(NetTopologySuite.Geometries.GeometryCollection,NetTopologySuite.Geometries.Ordinates,System.Boolean,System.Int32,System.IO.TextWriter,NetTopologySuite.IO.OrdinateFormat)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollectionText
            format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="outputOrdinates"></param>
            <param name="useFormatting">flag indicating that.</param>
            <param name="level">the indentation level.</param>
            <param name="writer">the output writer to append to.</param>
            <param name="ordinateFormat">The format to use for writing ordinate values.</param>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.ExtractLineByLocation">
            <summary>
            Extracts the subline of a linear <see cref="T:NetTopologySuite.Geometries.Geometry" /> between
            two <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />s on the line.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation.Extract(NetTopologySuite.Geometries.Geometry,NetTopologySuite.LinearReferencing.LinearLocation,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Computes the subline of a <see cref="T:NetTopologySuite.Geometries.LineString" /> between
            two <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/>s on the line.
            If the start location is after the end location,
            the computed linear geometry has reverse orientation to the input line.
            </summary>
            <param name="line">The line to use as the baseline.</param>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>The extracted subline.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.ExtractLineByLocation"/> class.
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation.Extract(NetTopologySuite.LinearReferencing.LinearLocation,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Extracts a subline of the input.
            If <paramref name="end" /> is minor that <paramref name="start" />,
            the linear geometry computed will be reversed.
            </summary>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>A linear geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation.Reverse(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="linear"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation.ComputeLinear(NetTopologySuite.LinearReferencing.LinearLocation,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Assumes input is valid
            (e.g. <paramref name="start" /> minor or equals to <paramref name="end" />).
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LengthIndexedLine">
            <summary>
            Supports linear referencing along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            using the length along the line as the index.
            Negative length values are taken as measured in the reverse direction
            from the end of the geometry.
            Out-of-range index values are handled by clamping
            them to the valid range of values.
            Non-simple lines (i.e. which loop back to cross or touch
            themselves) are supported.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs an object which allows a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            to be linearly referenced using length as an index.
            </summary>
            <param name="linearGeom">The linear geometry to reference along.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.ExtractPoint(System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> for the point
            on the line at the given index.
            If the index is out of range the first or last point on the
            line will be returned.
            </summary>
            <remarks>
            The Z-ordinate of the computed point will be interpolated from
            the Z-ordinates of the line segment containing it, if they exist.
            </remarks>
            <param name="index">The index of the desired point.</param>
            <returns>The <see cref="T:NetTopologySuite.Geometries.Coordinate" /> at the given index.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.ExtractPoint(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate"/> for the point on the line at the given index, offset by the given distance.
            </summary>
            <remarks>
            If the index is out of range the first or last point on the line will be returned.
            The computed point is offset to the left of the line if the offset distance is
            positive, to the right if negative.
            The Z-ordinate of the computed point will be interpolated from the Z-ordinates of the line segment containing it, if they exist.
            </remarks>
            <param name="index">The index of the desired point</param>
            <param name="offsetDistance">The distance the point is offset from the segment (positive is to the left, negative is to the right)</param>
            <returns>The Coordinate at the given index</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.ExtractLine(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.LineString" /> for the interval
            on the line between the given indices.
            If the <paramref name="endIndex" /> lies before the <paramref name="startIndex" />,
            the computed geometry is reversed.
            </summary>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.LocationOf(System.Double)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.IndexOf(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the minimum index for a point on the line.
            If the line is not simple (i.e. loops back on itself)
            a single point may have more than one possible index.
            In this case, the smallest index is returned.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The minimum index of the point.</returns>
            <seealso cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.IndexOfAfter(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Finds the index for a point on the line
            which is greater than the given index.
            If no such index exists, returns <paramref name="minIndex" />.
            This method can be used to determine all indexes for
            a point which occurs more than once on a non-simple line.
            It can also be used to disambiguate cases where the given point lies
            slightly off the line and is equidistant from two different
            points on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)" /> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <param name="minIndex">The value the returned index must be greater than.</param>
            <returns>The index of the point greater than the given minimum index.</returns>
            <seealso cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.IndicesOf(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline..</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LengthIndexedLine.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LengthIndexedLine.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.IsValidIndex(System.Double)">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><c>true</c> if the index is in the valid range.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine.ClampIndex(System.Double)">
            <summary>
            Computes a valid index for this line
            by clamping the given index to the valid range of index values
            </summary>
            <returns>A valid index value</returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LengthIndexOfPoint">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LengthIndexOfPoint"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint.IndexOf(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Find the nearest location along a linear <see cref="T:NetTopologySuite.Geometries.Geometry"/> to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint.IndexOfAfter(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Finds the nearest index along the linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            to a given <see cref="T:NetTopologySuite.Geometries.Coordinate"/> after the specified minimum index.
            If possible the location returned will be strictly
            greater than the <paramref name="minIndex" />.
            If this is not possible, the value returned
            will equal <paramref name="minIndex" />.
            (An example where this is not possible is when
            <paramref name="minIndex" /> = [end of line] ).
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint.IndexOfFromStart(NetTopologySuite.Geometries.Coordinate,System.Double)">
             <summary>
            
             </summary>
             <param name="inputPt"></param>
             <param name="minIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint.SegmentNearestMeasure(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.Coordinate,System.Double)">
             <summary>
            
             </summary>
             <param name="seg"></param>
             <param name="inputPt"></param>
             <param name="segmentStartMeasure"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LengthLocationMap">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> for a given length
            along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLocation(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> for a
            given length along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="length">The length index of the location.</param>
            <returns>The <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> for the length.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLocation(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> for a
            given length along a linear <see cref="T:NetTopologySuite.Geometries.Geometry"/>,
            with control over how the location
            is resolved at component endpoints.
            </summary>
            <param name="linearGeom">The linear geometry to use</param>
            <param name="length">The length index of the location</param>
            <param name="resolveLower">If true lengths are resolved to the lowest possible index</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLength(NetTopologySuite.Geometries.Geometry,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Computes the length for a given <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />
            on a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="loc">The <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> index of the location.</param>
            <returns>The length for the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LengthLocationMap"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLocation(System.Double)">
            <summary>
            Compute the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> corresponding to a length.
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            Ambiguous indexes are resolved to the lowest possible location value.
            </summary>
            <param name="length">The length index.</param>
            <returns>The corresponding <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLocation(System.Double,System.Boolean)">
            <summary>
            Compute the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> corresponding to a length.
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            Ambiguous indexes are resolved to the lowest or highest possible location value,
            depending on the value of <tt>resolveLower</tt>
            </summary>
            <param name="length">The length index</param>
            <param name="resolveLower"></param>
            <returns>The corresponding <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLocationForward(System.Double)">
             <summary>
            
             </summary>
             <param name="length"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap.GetLength(NetTopologySuite.LinearReferencing.LinearLocation)">
             <summary>
            
             </summary>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearGeometryBuilder">
            <summary>
            Builds a linear geometry (<see cref="T:NetTopologySuite.Geometries.LineString" /> or <see cref="T:NetTopologySuite.Geometries.MultiLineString" />)
            incrementally (point-by-point).
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="geomFact">The geometry factory to use.</param>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.FixInvalidLines">
            <summary>
            Allows invalid lines to be fixed rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.IgnoreInvalidLines">
            <summary>
            Allows invalid lines to be ignored rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.Add(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <see cref="T:NetTopologySuite.Geometries.Coordinate" /> to add.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.Add(NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <see cref="T:NetTopologySuite.Geometries.Coordinate" /> to add.</param>
            <param name="allowRepeatedPoints">If <c>true</c>, allows the insertions of repeated points.</param>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.LastCoordinate">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.EndLine">
            <summary>
            Terminate the current <see cref="T:NetTopologySuite.Geometries.LineString" />.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.ValidCoordinateSequence(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder.GetGeometry">
            <summary>
            Builds and returns the <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearIterator">
            <summary>
            An iterator over the components and coordinates of a linear geometry
            (<see cref="T:NetTopologySuite.Geometries.LineString" />s and <see cref="T:NetTopologySuite.Geometries.MultiLineString" />s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.SegmentEndVertexIndex(NetTopologySuite.LinearReferencing.LinearLocation)">
             <summary>
            
             </summary>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="F:NetTopologySuite.LinearReferencing.LinearIterator._currentLine">
            <summary>
            Invariant: currentLine &lt;&gt; null if the iterator is pointing at a valid coordinate
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an iterator initialized to the start of a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to iterate over.</param>
            <exception cref="T:System.ArgumentException"> if <paramref name="linearGeom"/> is not <see cref="T:NetTopologySuite.Geometries.ILineal"/></exception>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Creates an iterator starting at a <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> on a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to iterate over.</param>
            <param name="start">The location to start at.</param>
            <exception cref="T:System.ArgumentException"> if <paramref name="linearGeom"/> is not <see cref="T:NetTopologySuite.Geometries.ILineal"/></exception>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.#ctor(NetTopologySuite.Geometries.Geometry,System.Int32,System.Int32)">
            <summary>
            Creates an iterator starting at
            a component and vertex in a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to iterate over.</param>
            <param name="componentIndex">The component to start at.</param>
            <param name="vertexIndex">The vertex to start at.</param>
            <exception cref="T:System.ArgumentException"> if <paramref name="linearGeom"/> is not <see cref="T:NetTopologySuite.Geometries.ILineal"/></exception>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.LoadCurrentLine">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.HasNext">
            <summary>
            Tests whether there are any vertices left to iterator over.
            Specifically, <c>HasNext()</c> returns <tt>true</tt> if the
            current state of the iterator represents a valid location
            on the linear geometry.
            </summary>
            <returns><c>true</c> if there are more vertices to scan.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator.Next">
            <summary>
            Jump to the next element of the iteration.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.IsEndOfLine">
            <summary>
            Checks whether the iterator cursor is pointing to the
            endpoint of a component <see cref="T:NetTopologySuite.Geometries.LineString"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.ComponentIndex">
            <summary>
            The component index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.VertexIndex">
            <summary>
            The vertex index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.Line">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.LineString" /> component the iterator is current at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.SegmentStart">
            <summary>
            Gets the first <see cref="T:NetTopologySuite.Geometries.Coordinate" /> of the current segment
            (the coordinate of the current vertex).
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator.SegmentEnd">
            <summary>
            Gets the second <see cref="T:NetTopologySuite.Geometries.Coordinate" /> of the current segment
            (the coordinate of the next vertex).
            If the iterator is at the end of a line, <c>null</c> is returned.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearLocation">
            <summary>
            Represents a location along a <see cref="T:NetTopologySuite.Geometries.LineString" /> or <see cref="T:NetTopologySuite.Geometries.MultiLineString" />.<br/>
            The referenced geometry is not maintained within this location,
            but must be provided for operations which require it.
            Various methods are provided to manipulate the location value
            and query the geometry it references.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.GetEndLocation(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets a location which refers to the end of a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linear">The linear geometry.</param>
            <returns>A new <c>LinearLocation</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.PointAlongSegmentByFraction(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> of a point a given fraction
            along the line segment <c>(p0, p1)</c>.
            </summary>
            <remarks>
            <para>
            If the fraction is greater than 1.0 the last
            point of the segment is returned.</para>
            <para>If the fraction is less than or equal to 0.0 the first point
            of the segment is returned.</para>
            <para>
            The Z ordinate is interpolated from the Z-ordinates of the given points,
            if they are specified.</para>
            </remarks>
            <param name="p0">The first point of the line segment.</param>
            <param name="p1">The last point of the line segment.</param>
            <param name="fraction">The length to the desired point.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="componentIndex">Index of the component.</param>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.#ctor(System.Int32,System.Int32,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="componentIndex">Index of the component.</param>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
            <param name="normalize">If <c>true</c>, ensures the individual values are locally valid.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.#ctor(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Creates a new location equal to a given one.
            </summary>
            <param name="loc">A linear location</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.Normalize">
            <summary>
            Ensures the individual values are locally valid.
            Does not ensure that the indexes are valid for
            a particular linear geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.Clamp(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Ensures the indexes are valid for a given linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linear">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.SnapToVertex(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Snaps the value of this location to
            the nearest vertex on the given linear <see cref="T:NetTopologySuite.Geometries.Geometry" />,
            if the vertex is closer than <paramref name="minDistance" />.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <param name="minDistance">The minimum allowable distance to a vertex.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.GetSegmentLength(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the length of the segment in the given
            Geometry containing this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The length of the segment.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.SetToEnd(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets the value of this location to
            refer to the end of a linear geometry.
            </summary>
            <param name="linear">The linear geometry to use to set the end.</param>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation.ComponentIndex">
            <summary>
            Gets the component index for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation.SegmentIndex">
            <summary>
            Gets the segment index for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation.SegmentFraction">
            <summary>
            Gets the segment fraction for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation.IsVertex">
            <summary>
            Tests whether this location refers to a vertex:
            returns <c>true</c> if the location is a vertex.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.GetCoordinate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Coordinate" /> along the
            given linear <see cref="T:NetTopologySuite.Geometries.Geometry" /> which is
            referenced by this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The <see cref="T:NetTopologySuite.Geometries.Coordinate" /> at the location.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.GetSegment(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets a <see cref="T:NetTopologySuite.Geometries.LineSegment"/> representing the segment of the given linear <see cref="T:NetTopologySuite.Geometries.Geometry"/> which contains this location.
            </summary>
            <param name="linearGeom">A linear geometry</param>
            <returns>the <c>LineSegment</c> containing the location</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.IsValid(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this location refers to a valid
            location on the given linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns><c>true</c> if this location is valid.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="obj">
            The <c>LineStringLocation</c> with which this
            <c>Coordinate</c> is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this
            <c>LineStringLocation</c> is less than, equal to,
            or greater than the specified <c>LineStringLocation</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="obj" /> is not the same type as this instance.
            </exception>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.CompareTo(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="other">
            The <c>LineStringLocation</c> with which this
            <c>Coordinate</c> is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this
            <c>LineStringLocation</c> is less than, equal to,
            or greater than the specified <c>LineStringLocation</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.CompareLocationValues(System.Int32,System.Int32,System.Double)">
            <summary>
            Compares this object with the specified index values for order.
            </summary>
            <param name="componentIndex1">The component index.</param>
            <param name="segmentIndex1">The segment index.</param>
            <param name="segmentFraction1">The segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineStringLocation</c>
            is less than, equal to, or greater than the specified locationValues.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.CompareLocationValues(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Compares two sets of location values for order.
            </summary>
            <param name="componentIndex0">The first component index.</param>
            <param name="segmentIndex0">The first segment index.</param>
            <param name="segmentFraction0">The first segment fraction.</param>
            <param name="componentIndex1">The second component index.</param>
            <param name="segmentIndex1">The second segment index.</param>
            <param name="segmentFraction1">The second segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer
            as the first set of location values is less than, equal to,
            or greater than the second set of locationValues.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.IsOnSameSegment(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Tests whether two locations are on the same segment in the parent <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="loc">A location on the same geometry</param>
            <returns><c>true</c> if the locations are on the same segment of the parent geometry</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.IsEndpoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether this location is an endpoint of
            the linear component it refers to.
            </summary>
            <param name="linearGeom">The linear geometry referenced by this location</param>
            <returns>True if the location is a component endpoint</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.ToLowest(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Converts a linear location to the lowest equivalent location index.
            The lowest index has the lowest possible component and segment indices.
            Specifically:
            * if the location point is an endpoint, a location value is returned as (nseg-1, 1.0)
            * if the location point is ambiguous (i.e. an endpoint and a startpoint), the lowest endpoint location is returned
            If the location index is already the lowest possible value, the original location is returned.
            </summary>
            <param name="linearGeom">The linear geometry referenced by this location.</param>
            <returns>The lowest equivalent location.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation.NumSegments(NetTopologySuite.Geometries.LineString)">
            <summary>
            Gets the count of the number of line segments
            in a <see cref="T:NetTopologySuite.Geometries.LineString"/>.
            This is one less than the number of coordinates.
            </summary>
            <param name="line">A LineString</param>
            <returns>The number of segments</returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexedLine">
            <summary>
            Supports linear referencing along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            using <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />s as the index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs an object which allows linear referencing along
            a given linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
            <param name="linearGeom">The linear geometry to reference alo</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.ExtractPoint(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate" />for the point on the line at the given index.
            If the <paramref name="index" /> is out of range,
            the first or last point on the line will be returned.
            </summary>
            <remarks>
            The Z-ordinate of the computed point will be interpolated from
            the Z-ordinates of the line segment containing it, if they exist.
            </remarks>
            <param name="index">The index of the desired point.</param>
            <returns>The <see cref="T:NetTopologySuite.Geometries.Coordinate" /> at the given index.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.ExtractPoint(NetTopologySuite.LinearReferencing.LinearLocation,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate"/> for the point
            on the line at the given index, offset by the given distance.
            If the index is out of range the first or last point on the
            line will be returned.<para/>
            The computed point is offset to the left of the line if the offset distance is
            positive, to the right if negative.<para/>
            The Z-ordinate of the computed point will be interpolated from
            the Z-ordinates of the line segment containing it, if they exist.
            </summary>
            <param name="index">The index of the desired point</param>
            <param name="offsetDistance">The distance the point is offset from the segment
            (positive is to the left, negative is to the right)</param>
            <returns>The Coordinate at the given index</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.ExtractPoint(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Coordinate"/> for the point on the line at the given index, offset by the given distance.
            </summary>
            <remarks>
            If the index is out of range the first or last point on the line will be returned.
            The computed point is offset to the left of the line if the offset distance is
            positive, to the right if negative.
            The Z-ordinate of the computed point will be interpolated from the Z-ordinates of the line segment containing it, if they exist.
            </remarks>
            <param name="index">The index of the desired point</param>
            <param name="offsetDistance">The distance the point is offset from the segment (positive is to the left, negative is to the right)</param>
            <returns>The Coordinate at the given index</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.ExtractLine(NetTopologySuite.LinearReferencing.LinearLocation,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.LineString" /> for the interval
            on the line between the given indices.
            If the start location is after the end location,
            the computed linear geometry has reverse orientation to the input line.
            </summary>
            <param name="startIndex">The index of the start of the interval.</param>
            <param name="endIndex">The index of the end of the interval.</param>
            <returns>The linear interval between the indices.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.IndexOf(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the index for a given point on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)" /> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
            <seealso cref="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.IndicesOf(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.IndexOfAfter(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Finds the index for a point on the line which is greater than the given index.
            If no such index exists, returns <paramref name="minIndex" />.
            </summary>
            <remarks>
            <para>
            This method can be used to determine all indexes for
            a point which occurs more than once on a non-simple line.
            It can also be used to disambiguate cases where the given point lies
            slightly off the line and is equidistant from two different
            points on the line.
            </para>
            <para>
            The supplied point does not <i>necessarily</i> have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/> to compute a guaranteed result for points
            which may be far from the line.
            </para>
            </remarks>
            <param name="pt">A point on the line</param>
            <param name="minIndex">The value the returned index must be greater than</param>
            <returns>The index of the point greater than the given minimum index</returns>
            <seealso cref="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.Project(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LocationIndexedLine.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LocationIndexedLine.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.IsValidIndex(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><c>true</c> if the index is in the valid range.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine.ClampIndex(NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Computes a valid index for this line by clamping
            the given index to the valid range of index values.
            </summary>
            <param name="index"></param>
            <returns>A valid index value.</returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexOfLine">
            <summary>
            Determines the location of a subline along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            The location is reported as a pair of <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />s.
            NOTE: Currently this algorithm is not guaranteed to
            return the correct substring in some situations where
            an endpoint of the test line occurs more than once in the input line.
            (However, the common case of a ring is always handled correctly).
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfLine.IndicesOf(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="linearGeom"></param>
             <param name="subLine"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfLine.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LocationIndexOfLine"/> class.
            </summary>
            <param name="linearGeom">The linear geom.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfLine.IndicesOf(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="subLine"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexOfPoint">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> of the point
            on a linear <see cref="T:NetTopologySuite.Geometries.Geometry" />nearest a given <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            The nearest point is not necessarily unique; this class
            always computes the nearest point closest
            to the start of the geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint.IndexOf(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="linearGeom"></param>
             <param name="inputPt"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LocationIndexOfPoint"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint.IndexOf(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Find the nearest location along a linear <see cref="T:NetTopologySuite.Geometries.Geometry" /> to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint.IndexOfAfter(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.LinearReferencing.LinearLocation)">
            <summary>
            Find the nearest <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" /> along the linear <see cref="T:NetTopologySuite.Geometries.Geometry" />
            to a given <see cref="T:NetTopologySuite.Geometries.Geometry" /> after the specified minimum <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation" />.
            If possible the location returned will be strictly greater than the <paramref name="minIndex" />.
            If this is not possible, the value returned will equal <paramref name="minIndex" />.
            (An example where this is not possible is when <paramref name="minIndex" /> = [end of line] ).
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="T:NetTopologySuite.Mathematics.DD">
            <summary>
            Implements extended-precision floating-point numbers
            which maintain 106 bits (approximately 30 decimal digits) of precision.
            <para/>
            A DoubleDouble uses a representation containing two double-precision values.
            A number x is represented as a pair of doubles, x.hi and x.lo,
            such that the number represented by x is x.hi + x.lo, where
            <pre>
                |x.lo| &lt;= 0.5*ulp(x.hi)
            </pre>
            and ulp(y) means "unit in the last place of y".
            The basic arithmetic operations are implemented using
            convenient properties of IEEE-754 floating-point arithmetic.
            <para/>
            The range of values which can be represented is the same as in IEEE-754.
            The precision of the representable numbers
            is twice as great as IEEE-754 double precision.
            <para/>
            The correctness of the arithmetic algorithms relies on operations
            being performed with standard IEEE-754 double precision and rounding.
            This is the Java standard arithmetic model, but for performance reasons
            Java implementations are not
            constrained to using this standard by default.
            Some processors (notably the Intel Pentium architecture) perform
            floating point operations in (non-IEEE-754-standard) extended-precision.
            A JVM implementation may choose to use the non-standard extended-precision
            as its default arithmetic mode.
            To prevent this from happening, this code uses the
            Java <tt>strictfp</tt> modifier,
            which forces all operations to take place in the standard IEEE-754 rounding model.
            <para/>
            The API provides both a set of value-oriented operations
            and a set of mutating operations.
            Value-oriented operations treat DoubleDouble values as
            immutable; operations on them return new objects carrying the result
            of the operation.  This provides a simple and safe semantics for
            writing DoubleDouble expressions.  However, there is a performance
            penalty for the object allocations required.
            The mutable interface updates object values in-place.
            It provides optimum memory performance, but requires
            care to ensure that aliasing errors are not created
            and constant values are not changed.
            <para/>
            This implementation uses algorithms originally designed variously by
            Knuth, Kahan, Dekker, and Linnainmaa.
            Douglas Priest developed the first C implementation of these techniques.
            Other more recent C++ implementation are due to Keith M. Briggs and David Bailey et al.
            <h3>References</h3>
            <list type="bullet">
            <item><description>Priest, D., <i>Algorithms for Arbitrary Precision Floating Point Arithmetic</i>,
            in P. Kornerup and D. Matula, Eds., Proc. 10th Symposium on Computer Arithmetic,
            IEEE Computer Society Press, Los Alamitos, Calif., 1991.</description></item>
            <item><description>Yozo Hida, Xiaoye S. Li and David H. Bailey,
            <i>Quad-Double Arithmetic: Algorithms, Implementation, and Application</i>,
            manuscript, Oct 2000; Lawrence Berkeley National Laboratory Report BNL-46996.</description></item>
            <item><description>David Bailey, <i>High Precision Software Directory</i>;
            <tt>http://crd.lbl.gov/~dhbailey/mpdist/index.html</tt></description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.PI">
            <summary>The value nearest to the constant Pi.</summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.TwoPi">
            <summary>The value nearest to the constant 2 * Pi.</summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.PiHalf">
            <summary>The value nearest to the constant Pi / 2.</summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.E">
            <summary>
            The value nearest to the constant e (the natural logarithm base).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.NaN">
            <summary>
            A value representing the result of an operation which does not return a valid number.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.Epsilon">
            <summary>
            The smallest representable relative difference between two <see cref="T:NetTopologySuite.Mathematics.DD"/> values
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ValueOf(System.String)">
            <summary>
            Converts the string argument to a DoubleDouble number.
            </summary>
            <param name="str">A string containing a representation of a numeric value</param>
            <returns>The extended precision version of the value</returns>
            <exception cref="T:System.FormatException">Thrown if <paramref name="str"/> is not a valid representation of a number</exception>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Explicit(System.String)~NetTopologySuite.Mathematics.DD">
            <summary>
            Operator to parse a <tt>DoubleDouble</tt> from a string
            </summary>
            <param name="val">The DoubleDouble string</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ValueOf(System.Double)">
            <summary>
            Converts the <tt>double</tt> argument to a <tt>DoubleDouble</tt> number.
            </summary>
            <param name="x">A numeric value</param>
            <returns>The extended precision version of the value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Implicit(System.Double)~NetTopologySuite.Mathematics.DD">
            <summary>
            Operator to convert the <tt>double</tt> value to a <tt>DoubleDouble</tt> value.
            </summary>
            <param name="val">The DoubleDouble string</param>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD.Split">
            <summary>
            The value to split a double-precision value on during multiplication
            </summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD._hi">
            <summary>
            The high-order component of the double-double precision value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.DD._lo">
            <summary>
            The low-order component of the double-double precision value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Mathematics.DD"/> with value x.
            </summary>
            <param name="x">The initial value</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Mathematics.DD"/> with value (hi, lo).
            </summary>
            <param name="hi">The high order component</param>
            <param name="lo">The low order component</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.#ctor(NetTopologySuite.Mathematics.DD)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Mathematics.DD"/> with a value equal to the argument
            </summary>
            <param name="dd">The initial value</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Mathematics.DD"/> with value equal to the argument.
            </summary>
            <param name="str">The value to initialize by</param>
            <exception cref="T:System.FormatException"> if <paramref name="str"/> is not a valid representation of a number</exception>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Copy(NetTopologySuite.Mathematics.DD)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Mathematics.DD"/> with the value of the argument.
            </summary>
            <param name="dd">The value to copy</param>
            <returns>A copy of <paramref name="dd"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Clone">
            <summary>
            Creates and returns a copy of this value.
            </summary>
            <returns>A copy of this value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Addition(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Returns the sum of <paramref name="lhs"/> and <paramref name="rhs"/>.
            </summary>
            <param name="lhs">The left hand side</param>
            <param name="rhs">The right hand side</param>
            <returns>The sum of <paramref name="lhs"/> and <paramref name="rhs"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Addition(NetTopologySuite.Mathematics.DD,System.Double)">
            <summary>
            Returns the sum of <paramref name="lhs"/> and <paramref name="rhs"/>.
            </summary>
            <param name="lhs">The left hand side</param>
            <param name="rhs">The right hand side</param>
            <returns>The sum of <paramref name="lhs"/> and <paramref name="rhs"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Subtraction(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Returns the difference of <paramref name="lhs"/> and <paramref name="rhs"/>.
            </summary>
            <param name="lhs">The left hand side</param>
            <param name="rhs">The right hand side</param>
            <returns>The difference of <paramref name="lhs"/> and <paramref name="rhs"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Subtraction(NetTopologySuite.Mathematics.DD,System.Double)">
            <summary>
            Returns the difference of <paramref name="lhs"/> and <paramref name="rhs"/>.
            </summary>
            <param name="lhs">The left hand side</param>
            <param name="rhs">The right hand side</param>
            <returns>The difference of <paramref name="lhs"/> and <paramref name="rhs"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_UnaryNegation(NetTopologySuite.Mathematics.DD)">
            <summary>
            Subtracts the argument from the value of <tt>this</tt>.
            </summary>
            <param name="val">The subtrahend</param>
            <returns>The result of this - y</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Multiply(NetTopologySuite.Mathematics.DD,System.Double)">
            <summary>
            Multiplies <paramref name="lhs"/> by <paramref name="rhs"/>.
            </summary>
            <param name="lhs">A DoubleDouble value.</param>
            <param name="rhs">A double value.</param>
            <returns>The result of the multiplication.<para/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Multiply(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Multiplies <paramref name="lhs"/> by <paramref name="rhs"/>.
            </summary>
            <param name="lhs">A DoubleDouble value.</param>
            <param name="rhs">A DoubleDouble value.</param>
            <returns>The result of the multiplication.<para/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Division(NetTopologySuite.Mathematics.DD,System.Double)">
            <summary>
            Divides <paramref name="lhs"/> by <paramref name="rhs"/>.
            </summary>
            <param name="lhs">A DoubleDouble numerator.</param>
            <param name="rhs">A double divisor.</param>
            <returns>The result of the division.<para/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Division(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Divides <paramref name="lhs"/> by <paramref name="rhs"/>.
            </summary>
            <param name="lhs">A DoubleDouble numerator.</param>
            <param name="rhs">A DoubleDouble divisor.</param>
            <returns>The result of the division.<para/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Reciprocal">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Mathematics.DD"/> whose value is <c>1 / this</c>.
            </summary>
            <returns>The reciprocal of this value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Determinant(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the determinant of the 2x2 matrix with the given entries.
            </summary>
            <param name="x1">A matrix entry</param>
            <param name="y1">A matrix entry</param>
            <param name="x2">A matrix entry</param>
            <param name="y2">A matrix entry</param>
            <returns>The determinant of the matrix of values</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Determinant(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Computes the determinant of the 2x2 matrix with the given entries.
            </summary>
            <param name="x1">A matrix entry</param>
            <param name="y1">A matrix entry</param>
            <param name="x2">A matrix entry</param>
            <param name="y2">A matrix entry</param>
            <returns>The determinant of the matrix of values</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Min(NetTopologySuite.Mathematics.DD)">
            <summary>
            Computes the minimum of this and another DD number.
            </summary>
            <param name="x">A DD number</param>
            <returns>The minimum of the two numbers</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Max(NetTopologySuite.Mathematics.DD)">
            <summary>
            Computes the maximum of this and another DD number.
            </summary>
            <param name="x">A DD number</param>
            <returns>The maximum of the two numbers</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Floor">
            <summary>
            Returns the largest (closest to positive infinity)
            value that is not greater than the argument
            and is equal to a mathematical integer.
            Special cases:
            <list type="bullet">
            <item><description>If this value is NaN, returns NaN.</description></item>
            </list>
            </summary>
            <returns>The largest (closest to positive infinity)
            value that is not greater than the argument
             and is equal to a mathematical integer.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Ceiling">
            <summary>
            Returns the smallest (closest to negative infinity) value
            that is not less than the argument and is equal to a mathematical integer.
            Special cases:
            <list type="bullet">
             <item><description>If this value is NaN, returns NaN.</description></item>
            </list>
            </summary>
            <returns>
            The smallest (closest to negative infinity) value
            that is not less than the argument and is equal to a mathematical integer.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Signum">
            <summary>
            Returns an integer indicating the sign of this value.
            <para>
            <list type="bullet">
            <item><description>if this value is &gt; 0, returns 1</description></item>
            <item><description>if this value is &lt; 0, returns -1</description></item>
            <item><description>if this value is = 0, returns 0</description></item>
            <item><description>if this value is NaN, returns 0</description></item>
            </list>
            </para>
            </summary>
            <returns>An integer indicating the sign of this value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Rint">
            <summary>
            Rounds this value to the nearest integer.
            The value is rounded to an integer by adding 1/2 and taking the floor of the result.
            Special cases:
            <list type="bullet">
            <item><description>If this value is NaN, returns NaN.</description></item>
            </list>
            </summary>
            <returns>This value rounded to the nearest integer</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Truncate">
            <summary>
            Returns the integer which is largest in absolute value and not further
            from zero than this value.
            <para/>
            Special cases:
            <list type="bullet">
            <item><description>If this value is NaN, returns NaN.</description></item>
            </list>
            </summary>
            <returns>
            The integer which is largest in absolute value and not further from zero than this value
            </returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Abs">
            <summary>
            Returns the absolute value of this value.
            <para/>
            Special cases:
            <list type="bullet">
            <item><description>if this value is NaN, it is returned.</description></item>
            </list>
            </summary>
            <returns>The absolute value of this value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Sqr">
            <summary>
            Computes the square of this value.
            </summary>
            <returns>The square of this value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Sqr(System.Double)">
            <summary>
            Computes the square of this value.
            </summary>
            <returns>The square of this value.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Sqrt">
            <summary>
            Computes the positive square root of this value.<para/>
            If the number is NaN or negative, NaN is returned.
            </summary>
            <returns>If this is NaN or less than zero, the result is NaN.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Sqrt(System.Double)">
            <summary>
            Computes the positive square root of a <tt>DoubleDouble</tt> value.<para/>
            If the number is NaN or negative, NaN is returned.
            </summary>
            <param name="x">A numeric value</param>
            <returns>the positive square root of this number.<para/>
            If the argument is NaN or less than zero, the result is NaN.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Pow(System.Int32)">
            <summary>
            Computes the value of this number raised to an integral power.
            Follows semantics of .Net Math.Pow as closely as possible.
            </summary>
            <param name="exp">The integer exponent</param>
            <returns>x raised to the integral power exp</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ToDoubleValue">
            <summary>
            Converts this value to the nearest <see cref="T:System.Double"/> number.
            </summary>
            <returns>The nearest <see cref="T:System.Double"/> value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ToIntValue">
            <summary>
            Converts this value to the nearest <see cref="T:System.Int32"/> value.
            </summary>
            <returns>The nearest <see cref="T:System.Int32"/> value</returns>
        </member>
        <member name="P:NetTopologySuite.Mathematics.DD.IsZero">
            <summary>
            Gets a value indicating whether this object is zero (0) or not
            </summary>
        </member>
        <member name="P:NetTopologySuite.Mathematics.DD.IsNegative">
            <summary>
            Gets a value indicating whether this object is negative or not
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.IsPositive">
            <summary>
            Gets a value indicating whether this object is positive or not
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.IsNaN(NetTopologySuite.Mathematics.DD)">
            <summary>
            Gets a value indicating whether this object is positive or not
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.IsInfinity(NetTopologySuite.Mathematics.DD)">
            <summary>
            Checks if <paramref name="value"/> is infinity.
            </summary>
            <param name="value">A DoubleDouble value</param>
            <returns><c>true</c> if <c>value</c> is infinity.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Equals(NetTopologySuite.Mathematics.DD)">
            <summary>
            Tests whether this value is equal to another <tt>DoubleDouble</tt> value.
            </summary>
            <param name="y">A DoubleDouble value</param>
            <returns><c>true</c> if this value == <paramref name="y"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Equality(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Equality operator for <tt>DoubleDouble</tt> values
            </summary>
            <param name="lhs">A DoubleDouble value</param>
            <param name="rhs">A DoubleDouble value</param>
            <returns><c>true</c> if <paramref name="lhs"/> == <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.op_Inequality(NetTopologySuite.Mathematics.DD,NetTopologySuite.Mathematics.DD)">
            <summary>
            Inequality operator for <tt>DoubleDouble</tt> values
            </summary>
            <param name="lhs">A DoubleDouble value</param>
            <param name="rhs">A DoubleDouble value</param>
            <returns><c>true</c> if <paramref name="lhs"/> != <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.GreaterThan(NetTopologySuite.Mathematics.DD)">
            <summary>
            Tests whether this value is greater than another <tt>DoubleDouble</tt> value.
            </summary>
            <param name="y">A DoubleDouble value</param>
            <returns><c>true</c> if this value &gt; <paramref name="y"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.GreaterOrEqualThan(NetTopologySuite.Mathematics.DD)">
            <summary>
            Tests whether this value is greater than or equals to another <tt>DoubleDouble</tt> value.
            </summary>
            <param name="y">A DoubleDouble value</param>
            <returns><c>true</c> if this value &gt;= <paramref name="y"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.LessThan(NetTopologySuite.Mathematics.DD)">
            <summary>
            Tests whether this value is less than another <tt>DoubleDouble</tt> value.
            </summary>
            <param name="y">A DoubleDouble value</param>
            <returns><c>true</c> if this value is &lt; <paramref name="y"/> </returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.LessOrEqualThan(NetTopologySuite.Mathematics.DD)">
            <summary>
            Tests whether this value is less than or equal to another <tt>DoubleDouble</tt> value.
            </summary>
            <param name="y">A <tt>DoubleDouble</tt></param>
            <returns><c>true</c> if this value is &lt;= <paramref name="y"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.CompareTo(NetTopologySuite.Mathematics.DD)">
            <summary>
            Compares two <tt>DoubleDouble</tt> objects numerically.
            </summary>
            <param name="other">An other <tt>DoubleDouble</tt> value</param>
            <returns>
            <c>-1,0</c> or <c>1</c> depending on whether this value is less than, equal to
            or greater than the value of <paramref name="other"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Dump">
            <summary>
            Dumps the components of this number to a string.
            </summary>
            <returns>A string showing the components of the number</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ToString">
            <summary>
            Returns a string representation of this number, in either standard or scientific notation.
            If the magnitude of the number is in the range [ 10<sup>-3</sup>, 10<sup>8</sup> ]
            standard notation will be used.  Otherwise, scientific notation will be used.
            </summary>
            <returns>A string representation of this number</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ToStandardNotation">
            <summary>
            Returns the string representation of this value in standard notation.
            </summary>
            <returns>The string representation in standard notation</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ToSciNotation">
            <summary>
            Returns the string representation of this value in scientific notation.
            </summary>
            <returns>The string representation in scientific notation</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.ExtractSignificantDigits(System.Boolean,System.Int32[])">
            <summary>
            Extracts the significant digits in the decimal representation of the argument.
            A decimal point may be optionally inserted in the string of digits
            (as long as its position lies within the extracted digits
            - if not, the caller must prepend or append the appropriate zeroes and decimal point).
            </summary>
            <param name="insertDecimalPoint"></param>
            <param name="magnitudes"></param>
            <returns>The string containing the significant digits and possibly a decimal point</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.GetSpecialNumberString">
            <summary>
            Returns the string for this value if it has a known representation (e.g. NaN or 0.0).
            </summary>
            <returns>The string for this special number <br/>
            or <c>null</c> if the number is not a special number</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Magnitude(System.Double)">
            <summary>
            Determines the decimal magnitude of a number.<para/>
            The magnitude is the exponent of the greatest power of 10 which is less than
            or equal to the number.
            </summary>
            <param name="x">The number to find the magnitude of</param>
            <returns>The decimal magnitude of <paramref name="x"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Parse(System.String)">
            <summary>
            Converts a string representation of a real number into a DoubleDouble value.
            The format accepted is similar to the standard Java real number syntax.
            It is defined by the following regular expression:
            <pre>
            [<tt>+</tt>|<tt>-</tt>] {<i>digit</i>} [ <tt>.</tt> {<i>digit</i>} ] [ ( <tt>e</tt> | <tt>E</tt> ) [<tt>+</tt>|<tt>-</tt>] {<i>digit</i>}+
            </pre>
             </summary>
            <param name="str">The string to parse</param>
            <returns>The value of the parsed number</returns>
            <exception cref="T:System.FormatException">Thrown if <tt>str</tt> is not a valid representation of a number</exception>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Mathematics.DD.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:NetTopologySuite.Mathematics.MathUtil">
            <summary>
            Various utility functions for mathematical and numerical operations.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamps a <c>double</c> value to a given range.
            </summary>
            <param name="x">The value to clamp</param>
            <param name="min">The minimum value of the range</param>
            <param name="max">The maximum value of the range</param>
            <returns>The clamped value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps a <c>int</c> value to a given range.
            </summary>
            <param name="x">The value to clamp</param>
            <param name="min">The minimum value of the range</param>
            <param name="max">The maximum value of the range</param>
            <returns>The clamped value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.ClampMax(System.Int32,System.Int32)">
            <summary>
            Clamps an integer to a given maximum limit.
            </summary>
            <param name="x">The value to clamp</param>
            <param name="max">The maximum value of the range</param>
            <returns>The clamped value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Ceiling(System.Int32,System.Int32)">
            <summary>
            Computes the ceiling function of the dividend of two integers.
            </summary>
            <param name="num">The numerator</param>
            <param name="denom">The denominator</param>
            <returns>The ceiling of <c>num / denom</c></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Log10(System.Double)">
            <summary>
            Computes the base-10 logarithm of a <c>double</c> value.
            <para>
            <list type="bullet">
            <item><description>If the argument is NaN or less than zero, then the result is NaN.</description></item>
            <item><description>If the argument is positive infinity, then the result is positive infinity.</description></item>
            <item><description>If the argument is positive zero or negative zero, then the result is negative infinity.</description></item>
            </list>
            </para>
            </summary>
            <param name="x">A positive number</param>
            <returns>The value log a, the base-10 logarithm of the input value</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Wrap(System.Int32,System.Int32)">
            <summary>
            Computes an index which wraps around a given maximum value.
            For values &gt;= 0, this is equals to <c>val % max</c>.
            For values &lt; 0, this is equal to <c>max - (-val) % max</c>
            </summary>
            <param name="index">The index to wrap</param>
            <param name="max">The maximum value (or modulus)</param>
            <returns>The wrapped index</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Average(System.Double,System.Double)">
            <summary>
            Computes the average of two numbers.
            </summary>
            <param name="x1">A number</param>
            <param name="x2">A number</param>
            <returns>The average of the inputs</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Max(System.Double,System.Double,System.Double)">
            <summary>
            Computes the maximum fo three values
            </summary>
            <param name="v1">A number</param>
            <param name="v2">A number</param>
            <param name="v3">A number</param>
            <returns>The maximum value of <paramref name="v1"/>, <paramref name="v2"/> and <paramref name="v3"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Max(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the maximum of four values
            </summary>
            <param name="v1">A number</param>
            <param name="v2">A number</param>
            <param name="v3">A number</param>
            <param name="v4">A number</param>
            <returns>The maximum value of <paramref name="v1"/>, <paramref name="v2"/>, <paramref name="v3"/> and <paramref name="v4"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Min(System.Double,System.Double,System.Double)">
            <summary>
            Computes the minimum of four values
            </summary>
            <param name="v1">A number</param>
            <param name="v2">A number</param>
            <param name="v3">A number</param>
            <returns>The minimum value of <paramref name="v1"/>, <paramref name="v2"/> and <paramref name="v3"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.Min(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the minimum of four values
            </summary>
            <param name="v1">A number</param>
            <param name="v2">A number</param>
            <param name="v3">A number</param>
            <param name="v4">A number</param>
            <returns>The minimum value of <paramref name="v1"/>, <paramref name="v2"/>, <paramref name="v3"/> and <paramref name="v4"/></returns>
        </member>
        <member name="F:NetTopologySuite.Mathematics.MathUtil.PhiInv">
            <summary>The inverse of the Golden Ratio phi.</summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.QuasiRandom(System.Double)">
            <summary>
            Generates a quasi-random sequence of numbers in the range [0,1].
            They are produced by an additive recurrence with 1/&#966; as the constant.
            This produces a low-discrepancy sequence which is more evenly
            distribute than random numbers.
            <para/>
            See <a href='https://en.wikipedia.org/wiki/Low-discrepancy_sequence#Additive_recurrence'>Wikipedia: Low-discrepancy Sequences - Additive Recurrence</a>.
            <para/>
            The sequence is initialized by calling it
            with any positive fractional number; 0 works well for most uses.
            </summary>
            <param name="curr">The current number in the sequence</param>
            <returns>The next value in the sequence</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.MathUtil.QuasiRandom(System.Double,System.Double)">
            <summary>
            Generates a quasi-random sequence of numbers in the range [0,1].
            They are produced by an additive recurrence with constant &#945;.
            <code>
            R(&#945;) :  t<sub>n</sub> = { t<sub>0</sub> + n&#945; },  n = 1,2,3,...
            </code>
            When &#945; is irrational this produces a
            <a href='https://en.wikipedia.org/wiki/Low-discrepancy_sequence#Additive_recurrence'>Low discrepancy sequence</a>
            which is more evenly distributed than random numbers.
            <para/>
            The sequence is initialized by calling it
            with any positive fractional number. 0 works well for most uses.
            </summary>
            <param name="curr">The current number in the sequence</param>
            <param name="alpha">the sequence's additive constant</param>
            <returns>The next value in the sequence</returns>
        </member>
        <member name="T:NetTopologySuite.Mathematics.Matrix">
            <summary>
            Implements some 2D matrix operations
            (in particular, solving systems of linear equations).
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Matrix.Solve(System.Double[][],System.Double[])">
            <summary>
            Solves a system of equations using Gaussian Elimination.
            In order to avoid overhead the algorithm runs in-place
            on <see paramref="a"/> - if <see paramref="a"/> should not be modified the client must supply a copy.
            </summary>
            <param name="a">An nxn matrix in row/column order )modified by this method)</param>
            <param name="b">A vector of length n</param>
            <returns>A vector containing the solution (if any)<br/>or <c>null</c> if the system has no or no unique solution
            </returns>
            <exception cref="T:System.ArgumentException">If the matrix has the wrong size</exception>
        </member>
        <member name="T:NetTopologySuite.Mathematics.Plane">
            <summary>
            Enumeration for the 3 coordinate planes
            </summary>
        </member>
        <member name="T:NetTopologySuite.Mathematics.Plane3D">
            <summary>
            Models a plane in 3-dimensional Cartesian space.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Plane3D.OrientedDistance(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the oriented distance from a point to the plane.<br/>
            The distance is:
            <list type="bullet">
            <item><description><b>positive</b> if the point lies above the plane (relative to the plane normal)</description></item>
            <item><description><b>zero</b> if the point is on the plane</description></item>
            <item><description><b>negative</b> if the point lies below the plane (relative to the plane normal)</description></item>
            </list>
            </summary>
            <param name="p">The point to compute the distance for</param>
            <returns>The oriented distance to the plane</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Plane3D.ClosestAxisPlane">
            <summary>
            Computes the axis plane that this plane lies closest to.
            <para/>
            Geometries lying in this plane undergo least distortion
            (and have maximum area)
            when projected to the closest axis plane.
            This provides optimal conditioning for
            computing a Point-in-Polygon test.
            </summary>
            <returns>The index of the closest axis plane</returns>
        </member>
        <member name="T:NetTopologySuite.Mathematics.Vector2D">
            <summary>
            A 2-dimensional mathematical vector represented by double-precision X and Y components.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector2D.Zero">
            <summary>
            Creates a new vector with all components set to Zero
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Create(System.Double,System.Double)">
            <summary>
            Creates a new vector with given X and Y components.
            </summary>
            <param name="x">The x component</param>
            <param name="y">The y component</param>
            <returns>A new vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Create(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Creates a new vector from an existing one.
            </summary>
            <param name="v">The vector to copy</param>
            <returns>A new vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Create(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a vector from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="coord">The coordinate to copy</param>
            <returns>A new vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Create(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Creates a vector with the direction and magnitude
            of the difference between the
            <paramref name="to"/> and <paramref name="from"/> <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="from">The origin coordinate</param>
            <param name="to">The destination coordinate</param>
            <returns>A new vector</returns>
        </member>
        <member name="F:NetTopologySuite.Mathematics.Vector2D._x">
            <summary>The X component of this vector</summary>
        </member>
        <member name="F:NetTopologySuite.Mathematics.Vector2D._y">
            <summary>The Y component of this vector.</summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.#ctor">
            <summary>
            Creates an new vector instance
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new vector instance using the provided <paramref name="x"/> and <paramref name="y"/> ordinates
            </summary>
            <param name="x">The x-ordinate value</param>
            <param name="y">The y-ordinate value</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.#ctor(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Creates a new vector instance based on <paramref name="v"/>.
            </summary>
            <param name="v">The vector</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>Creates a new vector with the direction and magnitude
            of the difference between the
            <paramref name="to"/> and <paramref name="from"/> <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="from">The origin coordinate</param>
            <param name="to">The destination coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a vector from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            </summary>
            <param name="v">The coordinate</param>
            <returns>A new vector</returns>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector2D.X">
            <summary>
            Gets the x-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector2D.Y">
            <summary>
            Gets the y-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector2D.Item(System.Int32)">
            <summary>
            Gets the ordinate values by index
            </summary>
            <param name="index">The index</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index &lt; 0 or &gt; 1</exception>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Add(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Adds <paramref name="v"/> to this vector instance.
            </summary>
            <param name="v">The vector to add</param>
            <returns>The result vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Subtract(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Subtracts <paramref name="v"/> from this vector instance
            </summary>
            <param name="v">The vector to subtract</param>
            <returns>The result vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Multiply(System.Double)">
            <summary>
            Multiplies the vector by a scalar value.
            </summary>
            <param name="d">The value to multiply by</param>
            <returns>A new vector with the value v * d</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Divide(System.Double)">
            <summary>
            Divides the vector by a scalar value.
            </summary>
            <param name="d">The value to divide by</param>
            <returns>A new vector with the value v / d</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Negate">
            <summary>
            Negates this vector
            </summary>
            <returns>A new vector with [-_x, -_y]</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Length">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.LengthSquared">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Normalize">
            <summary>
            Normalizes the vector
            </summary>
            <returns>A new normalized vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Average(NetTopologySuite.Mathematics.Vector2D)">
             <summary>
            
             </summary>
             <param name="v"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.WeightedSum(NetTopologySuite.Mathematics.Vector2D,System.Double)">
            <summary>
            Computes the weighted sum of this vector
            with another vector,
            with this vector contributing a fraction
            of <tt>frac</tt> to the total.
            <para/>
            In other words,
            <pre>
            sum = frac * this + (1 - frac) * v
            </pre>
            </summary>
            <param name="v">The vector to sum</param>
            <param name="frac">The fraction of the total contributed by this vector</param>
            <returns>The weighted sum of the two vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Distance(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Computes the distance between this vector and another one.
            </summary>
            <param name="v">A vector</param>
            <returns>The distance between the vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Dot(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Computes the dot-product of two vectors
            </summary>
            <param name="v">A vector</param>
            <returns>The dot product of the vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Angle">
            <summary>
            Computes the angle this vector describes to the horizontal axis
            </summary>
            <returns>The angle</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Angle(NetTopologySuite.Mathematics.Vector2D)">
             <summary>
            
             </summary>
             <param name="v"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.AngleTo(NetTopologySuite.Mathematics.Vector2D)">
             <summary>
            
             </summary>
             <param name="v"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Rotate(System.Double)">
            <summary>
            Rotates this vector by <paramref name="angle"/>
            </summary>
            <param name="angle">The angle</param>
            <returns>The rotated vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.RotateByQuarterCircle(System.Int32)">
            <summary>
            Rotates a vector by a given number of quarter-circles (i.e. multiples of 90
            degrees or Pi/2 radians). A positive number rotates counter-clockwise, a
            negative number rotates clockwise. Under this operation the magnitude of
            the vector and the absolute values of the ordinates do not change, only
            their sign and ordinate index.
            </summary>
            <param name="numQuarters">The number of quarter-circles to rotate by</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.IsParallel(NetTopologySuite.Mathematics.Vector2D)">
             <summary>
            
             </summary>
             <param name="v"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Translate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> made of this vector translated by <paramref name="coord"/>.
            </summary>
            <param name="coord">The translation coordinate</param>
            <returns>A coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.ToCoordinate">
            <summary>
            Gets a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> from this vector
            </summary>
            <returns>A coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Clone">
            <summary>
            Creates a copy of this vector
            </summary>
            <returns>A copy of this vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.ToString">
            <summary>
            Gets a string representation of this vector
            </summary>
            <returns>A string representing this vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.Equals(System.Object)">
            <summary>
            Tests if a vector <paramref name="o"/> has the same values for the x and y components.
            </summary>
            <param name="o">A <see cref="T:NetTopologySuite.Mathematics.Vector2D"/> with which to do the comparison.</param>
            <returns>true if <paramref name="o"/> is a <see cref="T:NetTopologySuite.Mathematics.Vector2D"/>with the same values for the X and Y components.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.GetHashCode">
            <summary>
            Gets a hashcode for this vector.
            </summary>
            <returns>A hashcode for this vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Addition(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="left">The first vector to add.</param>
            <param name="right">The second vector to add.</param>
            <returns>The sum of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Multiply(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Modulates a vector with another by performing component-wise multiplication"/>.
            </summary>
            <param name="left">The first vector to multiply.</param>
            <param name="right">The second vector to multiply.</param>
            <returns>The multiplication of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Subtraction(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Subtracts two vectors.
            </summary>
            <param name="left">The first vector to subtract.</param>
            <param name="right">The second vector to subtract.</param>
            <returns>The difference of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_UnaryNegation(NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Reverses the direction of a given vector.
            </summary>
            <param name="value">The vector to negate.</param>
            <returns>A vector facing in the opposite direction.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Multiply(System.Double,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Multiply(NetTopologySuite.Mathematics.Vector2D,System.Double)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Division(NetTopologySuite.Mathematics.Vector2D,System.Double)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Division(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Equality(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Tests for equality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has the same value as
            <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector2D.op_Inequality(NetTopologySuite.Mathematics.Vector2D,NetTopologySuite.Mathematics.Vector2D)">
            <summary>
            Tests for inequality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has a different value
            than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:NetTopologySuite.Mathematics.Vector3D">
            <summary>
            Represents a vector in 3-dimensional Cartesian space.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector3D.Zero">
            <summary>
            Creates a new vector with all components set to Zero
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Dot(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the dot product of the 3D vectors AB and CD.
            </summary>
            <param name="A">The start point of the 1st vector</param>
            <param name="B">The end point of the 1st vector</param>
            <param name="C">The start point of the 2nd vector</param>
            <param name="D">The end point of the 2nd vector</param>
            <returns>The dot product</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Cross(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Calculates the cross product of two vectors.
            </summary>
            <param name="left">First source vector.</param>
            <param name="right">Second source vector.</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Create(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with given <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/> components.
            </summary>
            <param name="x">The x component</param>
            <param name="y">The y component</param>
            <param name="z">The z component</param>
            <returns>A new vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Create(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a vector from a 3D <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.
            <para/>
            The coordinate should have the
            X,Y and Z ordinates specified.
            </summary>
            <param name="coord">The coordinate to copy</param>
            <returns>A new vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Dot(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the 3D dot-product of two <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s
            </summary>
            <param name="v1">The 1st vector</param>
            <param name="v2">The 2nd vector</param>
            <returns>The dot product of the (coordinate) vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new 3D vector from a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.<para/> The coordinate should have
            the X,Y and Z ordinates specified.
            </summary>
            <param name="coord">The coordinate to copy</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new vector with the direction and magnitude
            of the difference between the <paramref name="to"/>
            and <paramref name="from"/> <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="from">The origin coordinate</param>
            <param name="to">The destination coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with the given <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/> components
            </summary>
            <param name="x">The x component</param>
            <param name="y">The y component</param>
            <param name="z">The z component</param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.#ctor(NetTopologySuite.Mathematics.Vector2D,System.Double)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Mathematics.Vector3D"/> using a <see cref="T:NetTopologySuite.Mathematics.Vector2D"/> plus a value for <paramref name="z"/> component
            </summary>
            <param name="value">A vector containing the values with which to initialize the X and Y components.</param>
            <param name="z">Initial value for the Z component of the vector.</param>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector3D.X">
            <summary>
            Gets a value indicating the x-ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector3D.Y">
            <summary>
            Gets a value indicating the y-ordinate
            </summary>
        </member>
        <member name="P:NetTopologySuite.Mathematics.Vector3D.Z">
            <summary>
            Gets a value indicating the z-ordinate
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Add(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Computes a vector which is the sum
            of this vector and the given vector.
            </summary>
            <param name="v">The vector to add</param>
            <returns>The sum of this and <c>v</c></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Subtract(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Computes a vector which is the difference
            of this vector and the given vector.
            </summary>
            <param name="v">The vector to subtract</param>
            <returns>The difference of this and <c>v</c></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Divide(System.Double)">
            <summary>
            Creates a new vector which has the same direction
            and with length equals to the length of this vector
            divided by the scalar value <c>d</c>.
            </summary>
            <param name="d">The scalar divisor</param>
            <returns>A new vector with divided length</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Dot(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Computes the dot-product of this <see cref="T:NetTopologySuite.Mathematics.Vector3D"/> and <paramref name="v"/>
            </summary>
            <paramref name="v">The 2nd vector</paramref>
            <returns>The dot product of the vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Cross(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Computes the cross-product of this <see cref="T:NetTopologySuite.Mathematics.Vector3D"/> and <paramref name="v"/>
            </summary>
            <paramref name="v">The 2nd vector</paramref>
            <returns>The cross product of the vectors</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Length">
            <summary>
            Computes the length of this vector
            </summary>
            <returns>The length of this vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Length(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the length of vector <paramref name="v"/>.
            </summary>
            <param name="v">A coordinate representing a 3D Vector</param>
            <returns>The length of <paramref name="v"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Normalize">
            <summary>
            Computes a vector having identical direction
            but normalized to have length 1.
            </summary>
            <returns>A new normalized vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Normalize(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes a vector having identical direction as <c>v</c>
            but normalized to have length 1.
            </summary>
            <param name="v">A coordinate representing a 3D vector</param>
            <returns>A coordinate representing the normalized vector</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Addition(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="left">The first vector to add.</param>
            <param name="right">The second vector to add.</param>
            <returns>The sum of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Multiply(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Modulates a vector with another by performing component-wise multiplication.
            </summary>
            <param name="left">The first vector to multiply.</param>
            <param name="right">The second vector to multiply.</param>
            <returns>The multiplication of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_UnaryPlus(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Assert a vector (return it unchanged).
            </summary>
            <param name="value">The vector to assert (unchanged).</param>
            <returns>The asserted (unchanged) vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Subtraction(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Subtracts two vectors.
            </summary>
            <param name="left">The first vector to subtract.</param>
            <param name="right">The second vector to subtract.</param>
            <returns>The difference of the two vectors.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_UnaryNegation(NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Reverses the direction of a given vector.
            </summary>
            <param name="value">The vector to negate.</param>
            <returns>A vector facing in the opposite direction.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Multiply(System.Double,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Multiply(NetTopologySuite.Mathematics.Vector3D,System.Double)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Division(NetTopologySuite.Mathematics.Vector3D,System.Double)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Division(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Scales a vector by the given value.
            </summary>
            <param name="value">The vector to scale.</param>
            <param name="scale">The amount by which to scale the vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Equality(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Tests for equality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.Vector3D.op_Inequality(NetTopologySuite.Mathematics.Vector3D,NetTopologySuite.Mathematics.Vector3D)">
            <summary>
            Tests for inequality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:NetTopologySuite.Mathematics.VectorMath">
            <summary>
            Functions for performing vector mathematics.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Mathematics.VectorMath.NormalToTriangle(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the normal vector to the triangle p0-p1-p2. In order to compute the normal each
            triangle coordinate must have a Z value. If this is not the case, the returned Coordinate
            will have NaN values. The returned vector has unit length.
            </summary>
            <param name="p0">A point</param>
            <param name="p1">A point</param>
            <param name="p2">A point</param>
            <returns>The normal vector to the triangle <paramref name="p0"/>-<paramref name="p1"/>-<paramref name="p2"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.VectorMath.Normalize(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Normalizes the vector <paramref name="v"/>
            </summary>
            <param name="v">The normalized <paramref name="v"/></param>
        </member>
        <member name="M:NetTopologySuite.Mathematics.VectorMath.CrossProduct(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the cross product of <paramref name="v1"/> and <paramref name="v2"/>
            </summary>
            <param name="v1">A vector</param>
            <param name="v2">A vector</param>
            <returns>The cross product of <paramref name="v1"/> and <paramref name="v2"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.VectorMath.DotProduct(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the dot product of <paramref name="v1"/> and <paramref name="v2"/>
            </summary>
            <param name="v1">A vector</param>
            <param name="v2">A vector</param>
            <returns>The dot product of <paramref name="v1"/> and <paramref name="v2"/></returns>
        </member>
        <member name="M:NetTopologySuite.Mathematics.VectorMath.Det(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes the determinant of a 2x2 matrix
            </summary>
            <param name="a1">The m[0,0] value</param>
            <param name="a2">The m[0,1] value</param>
            <param name="b1">The m[1,0] value</param>
            <param name="b2">The m[1,1] value</param>
            <returns>The determinant</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.BasicSegmentString">
            <summary>
            Represents a read-only list of contiguous line segments.
            This can be used for detection of intersections or nodes.
            <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s can carry a context object, which is useful
            for preserving topological or parentage information.
            <para/>
            If adding nodes is required use <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>.
            </summary>
            <seealso cref="T:NetTopologySuite.Noding.NodedSegmentString"/>
        </member>
        <member name="M:NetTopologySuite.Noding.BasicSegmentString.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Object)">
            <summary>
            Creates a new segment string from a list of vertices.
            </summary>
            <param name="pts">the vertices of the segment string</param>
            <param name="data">the user-defined data of this segment string (may be null)</param>
        </member>
        <member name="P:NetTopologySuite.Noding.BasicSegmentString.Context">
            <summary>Gets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.BasicSegmentString.GetSegmentOctant(System.Int32)">
            <summary>
            Gets the octant of the segment starting at vertex <c>index</c>
            </summary>
            <param name="index">the index of the vertex starting the segment. Must not be the last index in the vertex list</param>
            <returns>octant of the segment at the vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.BasicSegmentString.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Noding.BoundaryChainNoder">
            <summary>
            A noder which extracts chains of boundary segments
            as {@link SegmentString}s.
            Boundary segments are those which are not duplicated in the input.
            The segment strings are extracted in a way that maximises their length,
            and minimizes the total number of edges.
            This produces the most efficient topological graph structure.
            <para/>
            Segments which are not on the boundary are those which
            have an identical segment in another polygon ring.
            <para/>
            This enables fast overlay of polygonal coverages in {@link CoverageUnion}.
            This noder is faster than {@link SegmentExtractingNoder}
            and {@link BoundarySegmentNoder}.
            <para/>
            No precision reduction is carried out.
            If that is required, another noder must be used (such as a snap-rounding noder),
            or the input must be precision-reduced beforehand.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundaryChainNoder.#ctor">
            <summary>
            Creates a new boundary-extracting noder.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundaryChainNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <inheritdoc/>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundaryChainNoder.GetNodedSubstrings">
            <inheritdoc/>
        </member>
        <member name="T:NetTopologySuite.Noding.BoundarySegmentNoder">
            <summary>
            A noder which extracts boundary line segments
            as <see cref="T:NetTopologySuite.Noding.ISegmentString"/>.
            Boundary segments are those which are not duplicated in the input.
            It is appropriate for use with valid polygonal coverages.
            <para/>
            No precision reduction is carried out.
            If that is required, another noder must be used (such as a snap-rounding noder),
            or the input must be precision-reduced beforehand.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundarySegmentNoder.#ctor">
            <summary>
            Creates a new segment-dissolving noder.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundarySegmentNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <inheritdoc/>
        </member>
        <member name="M:NetTopologySuite.Noding.BoundarySegmentNoder.GetNodedSubstrings">
            <inheritdoc/>
        </member>
        <member name="T:NetTopologySuite.Noding.FastNodingValidator">
            <summary>
            Validates that a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s is correctly noded.
            Indexing is used to improve performance.
            </summary>
            <remarks>
            <para>
            By default validation stops after a single
            non-noded intersection is detected.
            Alternatively, it can be requested to detect all intersections
            by using the <see cref="P:NetTopologySuite.Noding.FastNodingValidator.FindAllIntersections"/> property.
            <para/>
            The validator does not check for topology collapse situations
            (e.g. where two segment strings are fully co-incident).
            <para/>
            The validator checks for the following situations which indicated incorrect noding:
            <list type="Bullen">
            <item><description>Proper intersections between segments (i.e. the intersection is interior to both segments)</description></item>
            <item><description>Intersections at an interior vertex (i.e. with an endpoint or another interior vertex)</description></item>
            </list>
            </para>
            <para>
            The client may either test the <see cref="P:NetTopologySuite.Noding.FastNodingValidator.IsValid"/> condition,
            or request that a suitable <see cref="T:NetTopologySuite.Geometries.TopologyException"/> be thrown.
            </para>
            </remarks>
            <seealso cref="T:NetTopologySuite.Noding.NodingValidator"/>
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator.ComputeIntersections(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Gets a list of all intersections found.
            Intersections are represented as <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            List is empty if none were found.
            <param name="segStrings">A collection of SegmentStrings</param>
            <returns>a list of <see cref="T:NetTopologySuite.Geometries.Coordinate"/></returns>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Creates a new noding validator for a given set of linework.
            </summary>
            <param name="segStrings">A collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s</param>
        </member>
        <member name="P:NetTopologySuite.Noding.FastNodingValidator.FindAllIntersections">
            <summary>
            Gets or sets whether all intersections should be found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.FastNodingValidator.Intersections">
            <summary>
            Gets a list of all intersections found.
            <remarks>
            Intersections are represented as <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            List is empty if none were found.
            </remarks>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.FastNodingValidator.IsValid">
            <summary>
            Checks for an intersection and reports if one is found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator.GetErrorMessage">
            <summary>
            Returns an error message indicating the segments containing the intersection.
            </summary>
            <returns>an error message documenting the intersection location</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator.CheckValid">
            <summary>
            Checks for an intersection and throws
            a TopologyException if one is found.
            </summary>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">if an intersection is found</exception>
        </member>
        <member name="T:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder">
            <summary>
            Finds if two sets of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s intersect.
            </summary>
            <remarks>
            Uses indexing for fast performance and to optimize repeated tests
            against a target set of lines.
            Short-circuited to return as soon an intersection is found.
            <para/>
            Immutable and thread-safe.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Creates an intersection finder against a given set of segment strings.
            </summary>
            <param name="baseSegStrings">The segment strings to search for intersections</param>
        </member>
        <member name="P:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.SegmentSetIntersector">
            <summary>Gets the segment set intersector used by this class.</summary>
            <remarks>This allows other uses of the same underlying indexed structure.</remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.Intersects(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Tests for intersections with a given set of target <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            </summary>
            <param name="segStrings">The SegmentStrings to test</param>
            <returns><c>true</c> if an intersection was found</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.Intersects(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Noding.SegmentIntersectionDetector)">
            <summary>
            Tests for intersections with a given set of target <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            using a given SegmentIntersectionDetector.
            </summary>
            <param name="segStrings">The SegmentStrings to test</param>
            <param name="intDetector">The intersection detector to use</param>
            <returns><c>true</c> if the detector reports intersections</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.INodableSegmentString">
            <summary>
            An interface for classes which support adding nodes to a segment string.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.INodableSegmentString.AddIntersection(NetTopologySuite.Geometries.Coordinate,System.Int32)">
            <summary>Adds an intersection node for a given point and segment to this segment string.
            </summary>
            <param name="intPt">the location of the intersection</param>
            <param name="segmentIndex">the index of the segment containing the intersection</param>
        </member>
        <member name="T:NetTopologySuite.Noding.INoder">
            <summary>
            Computes all intersections between segments in a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Intersections found are represented as <see cref="T:NetTopologySuite.Noding.SegmentNode" />s and added to the
            <see cref="T:NetTopologySuite.Noding.ISegmentString" />s in which they occur.
            As a final step in the noding a new set of segment strings split at the nodes may be returned.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.INoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString" />s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.INoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1" /> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString" />s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.InteriorIntersectionFinderAdder">
            <summary>
            Finds <b>interior</b> intersections
            between line segments in <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s,
            and adds them as nodes
            using <see cref="M:NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)"/>.
            This class is used primarily for Snap-Rounding.
            For general-purpose noding, use <see cref="T:NetTopologySuite.Noding.IntersectionAdder"/>.
            </summary>
            <seealso cref="T:NetTopologySuite.Noding.IntersectionAdder"/>
        </member>
        <member name="M:NetTopologySuite.Noding.InteriorIntersectionFinderAdder.#ctor(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates an intersection finder which finds all proper intersections.
            </summary>
            <param name="li">The <see cref="T:NetTopologySuite.Algorithm.LineIntersector" /> to use.</param>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinderAdder.InteriorIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.InteriorIntersectionFinderAdder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString" />s being intersected.<br/>
            Note that some clients (such as <c>MonotoneChain</c>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinderAdder.IsDone">
            <summary>
            Always process all intersections
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.IntersectionAdder">
            <summary>
            Computes the possible intersections between two line segments in <see cref="T:NetTopologySuite.Noding.ISegmentString" />s
            and adds them to each string
            using <see cref="M:NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder.IsAdjacentSegments(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i1"></param>
             <param name="i2"></param>
             <returns></returns>
        </member>
        <member name="F:NetTopologySuite.Noding.IntersectionAdder.NumIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.IntersectionAdder.NumInteriorIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.IntersectionAdder.NumProperIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.IntersectionAdder.NumTests">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder.#ctor(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.IntersectionAdder"/> class.
            </summary>
            <param name="li"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.LineIntersector">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.ProperIntersectionPoint">
            <summary>
            Returns the proper intersection point, or <c>null</c> if none was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.HasIntersection">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire <see cref="T:NetTopologySuite.Geometries.Geometry" />, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the <see cref="T:NetTopologySuite.Geometries.Geometry" />.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" />.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.HasInteriorIntersection">
            <summary>
            An interior intersection is an intersection which is
            in the interior of some segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder.IsTrivialIntersection(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Note that closed edges require a special check for the point shared by the beginning and end segments.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString" /> being intersected.<br/>
            Note that some clients (such as <c>MonotoneChain</c>") may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder.IsDone">
            <summary>
            Always process all intersections
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.ISegmentIntersector">
            <summary>
            Processes possible intersections detected by a <see cref="T:NetTopologySuite.Noding.INoder"/>.
            </summary>
            <remarks>
            <para>
            The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> is passed to a <see cref="T:NetTopologySuite.Noding.INoder" />.
            </para>
            The <see cref="M:NetTopologySuite.Noding.ISegmentIntersector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)"/>
            method is called whenever the <see cref="T:NetTopologySuite.Noding.INoder" />
             detects that two <see cref="T:NetTopologySuite.Noding.ISegmentString" />s might intersect.
            <para>
            This class may be used either to find all intersections, or
            to detect the presence of an intersection.  In the latter case,
            Noders may choose to short-circuit their computation by calling the
            <see cref="P:NetTopologySuite.Noding.ISegmentIntersector.IsDone"/> property.
            </para>
            <para>
            </para>
            This class is an example of the <i>Strategy</i> pattern.
            <para>
            This class may be used either to find all intersections, or
            to detect the presence of an intersection.  In the latter case,
            Noders may choose to short-circuit their computation by calling the
            <see cref="P:NetTopologySuite.Noding.ISegmentIntersector.IsDone"/> property.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.ISegmentIntersector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> interface to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString" />s being intersected.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentIntersector.IsDone">
            <summary>
            Reports whether the client of this class needs to continue testing
            all intersections in an arrangement.
            </summary>
            <returns>if there is no need to continue testing segments</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.ISegmentString">
            <summary>
            An interface for classes which represent a sequence of contiguous line segments.
            SegmentStrings can carry a context object, which is useful
            for preserving topological or parentage information.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString.Context">
            <summary>
            Gets/Sets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString.Coordinates">
            <summary>
            Points that make up ISegmentString
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString.Count">
            <summary>
            Size of Coordinate Sequence
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString.IsClosed">
            <summary>
            States whether ISegmentString is closed
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.IteratedNoder">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s completely.
            The set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s is fully noded;
            i.e. noding is repeated until no further intersections are detected.
            <para>
            Iterated noding using a <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating" /> precision model is not guaranteed to converge,
            due to round off error. This problem is detected and an exception is thrown.
            Clients can choose to rerun the noding using a lower precision model.
            </para>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.IteratedNoder.MaxIterations">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.IteratedNoder"/> class.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.IteratedNoder.MaximumIterations">
            <summary>
            Gets/Sets the maximum number of noding iterations performed before
            the noding is aborted. Experience suggests that this should rarely need to be changed
            from the default. The default is <see cref="F:NetTopologySuite.Noding.IteratedNoder.MaxIterations" />.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Fully nodes a list of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s, i.e. performs noding iteratively
            until no intersections are found between segments.
            Maintains labelling of edges correctly through the noding.
            </summary>
            <param name="segStrings">A collection of SegmentStrings to be noded.</param>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If the iterated noding fails to converge.</exception>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder.Node(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString},System.Int32[])">
            <summary>
            Node the input segment strings once
            and create the split edges between the nodes.
            </summary>
            <param name="segStrings"></param>
            <param name="numInteriorIntersections"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.MCIndexNoder">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s using a index based
            on <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain" />s and a <see cref="T:NetTopologySuite.Index.ISpatialIndex`1" />.
            The <see cref="T:NetTopologySuite.Index.ISpatialIndex`1" /> used should be something that supports
            envelope (range) queries efficiently (such as a <c>Quadtree</c>"
            or <see cref="T:NetTopologySuite.Index.Strtree.STRtree`1" />.
            <para/>
            The noder supports using an overlap tolerance distance.
            This allows determining segment intersection using a buffer for uses
            involving snapping with a distance tolerance.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.MCIndexNoder"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.#ctor(NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.MCIndexNoder"/> class.
            </summary>
            <param name="si">The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.#ctor(NetTopologySuite.Noding.ISegmentIntersector,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.MCIndexNoder"/> class.
            </summary>
            <param name="si">The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> to use.</param>
            <param name="overlapTolerance">The expansion distance for overlap tests</param>
        </member>
        <member name="P:NetTopologySuite.Noding.MCIndexNoder.MonotoneChains">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.MCIndexNoder.Index">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.IntersectChains">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.Add(NetTopologySuite.Noding.ISegmentString)">
             <summary>
            
             </summary>
             <param name="segStr"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction.#ctor(NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction"/> class.
            </summary>
            <param name="si">The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /></param>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction.Overlap(NetTopologySuite.Index.Chain.MonotoneChain,System.Int32,NetTopologySuite.Index.Chain.MonotoneChain,System.Int32)">
             <summary>
            
             </summary>
             <param name="mc1"></param>
             <param name="start1"></param>
             <param name="mc2"></param>
             <param name="start2"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector">
            <summary>
            Intersects two sets of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s using a index based
            on <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain"/>s and a <see cref="T:NetTopologySuite.Index.ISpatialIndex`1"/>.
            <para/>
            Thread-safe and immutable.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Constructs a new intersector for a given set of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            </summary>
            <param name="baseSegStrings">The base segment strings to intersect</param>
        </member>
        <member name="P:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.Index">
            <summary>
            Gets the index constructed over the base segment strings
            </summary>
            <remarks>NOTE: To retain thread-safety, treat returned value as immutable</remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.Process(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Calls <see cref="M:NetTopologySuite.Noding.ISegmentIntersector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)"/>
            for all <i>candidate</i> intersections between
            the given collection of SegmentStrings and the set of indexed segments.
            </summary>
            <param name="segStrings">A set of segments to intersect</param>
            <param name="segInt">The <c>SegmentIntersector</c> to use</param>
        </member>
        <member name="T:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction">
            <summary>
            Segment overlap action class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction.#ctor(NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Creates an instance of this class using the provided <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/>
            </summary>
            <param name="si">The segment intersector to use</param>
        </member>
        <member name="T:NetTopologySuite.Noding.NodedSegmentString">
            <summary>
            Represents a list of contiguous line segments, and supports noding the segments.
            The line segments are represented by an array of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.
            Intended to optimize the noding of contiguous segments by
            reducing the number of allocated objects.
            <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s can carry a context object, which is useful
            for preserving topological or parentage information.
            All noded substrings are initialized with the same context object.
            <para/>
            For read-only applications use <see cref="T:NetTopologySuite.Noding.BasicSegmentString"/>,
            which is (slightly)more lightweight.
            </summary>
            <seealso cref="T:NetTopologySuite.Noding.BasicSegmentString"/>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.GetNodedSubstrings(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s which result from splitting this string at node points.
            </summary>
            <param name="segStrings">A collection of NodedSegmentStrings</param>
            <returns>A collection of NodedSegmentStrings representing the substrings</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.GetNodedSubstrings(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString},System.Collections.Generic.ICollection{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Adds the noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s which result from splitting this string at node points.
            </summary>
            <param name="segStrings">A collection of NodedSegmentStrings</param>
            <param name="resultEdgelist">A list which will collect the NodedSegmentStrings representing the substrings</param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Object)">
            <summary>
            Creates an instance from a list of vertices and optional data object.
            </summary>
            <param name="pts">The vertices of the segment string.</param>
            <param name="context">The user-defined data of this segment string (may be null).</param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.#ctor(NetTopologySuite.Noding.ISegmentString)">
            <summary>
            Creates a new instance from a <see cref="T:NetTopologySuite.Noding.ISegmentString"/>.
            </summary>
            <param name="ss">The segment string to use.</param>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.Context">
            <summary>
            Gets/Sets the user-defined data for this segment string.
            </summary>
            <remarks>In JTS this property is called <i>Data</i></remarks>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.NodeList">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.Count">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.NodedCoordinates">
            <summary>
            Gets a list of coordinates with all nodes included.
            </summary>
            <returns>An array of coordinates including nodes</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.GetSegmentOctant(System.Int32)">
            <summary>
             Gets the octant of the segment starting at vertex <c>index</c>.
            </summary>
            <param name="index">
            The index of the vertex starting the segment.
            Must not be the last index in the vertex list
            </param>
            <returns>The octant of the segment at the vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.AddIntersections(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an <see cref="T:NetTopologySuite.Noding.SegmentNode" /> for intersection intIndex.
            An intersection that falls exactly on a vertex
            of the <see cref="T:NetTopologySuite.Noding.NodedSegmentString" /> is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
            <param name="intIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Geometries.Coordinate,System.Int32)">
             <summary>
            
             </summary>
             <param name="intPt"></param>
             <param name="segmentIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Noding.NodingIntersectionFinder">
            <summary>
            Finds non-noded intersections in a set of {@link SegmentString}s,
            if any exist.
            <para/>
            Non-noded intersections include:
            <list type="Bullet">
            <item><term>Interior intersections</term><description>which lie in the interior of a segment
            (with another segment interior or with a vertex or endpoint)</description></item>
            <item><term>Vertex intersections</term><description>which occur at vertices in the interior of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s
            (with a segment string endpoint or with another interior vertex)</description></item>
            </list>
            The finder can be limited to finding only interior intersections
            by setting <see cref="P:NetTopologySuite.Noding.NodingIntersectionFinder.InteriorIntersectionsOnly"/>.
            <para/>
            By default only the first intersection is found,
            but all can be found by setting <see cref="P:NetTopologySuite.Noding.NodingIntersectionFinder.FindAllIntersections"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.CreateAnyIntersectionFinder(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates a finder which tests if there is at least one intersection.
            Uses short-circuiting for efficient performance.
            The intersection found is recorded.
            </summary>
            <param name="li">A line intersector.</param>
            <returns>A finder which tests if there is at least one intersection.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.CreateAllIntersectionsFinder(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates a finder which tests if there is at least one intersection.
            The intersections are recorded for later inspection.
            </summary>
            <param name="li">A line intersector.</param>
            <returns>A finder which finds all intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.CreateInteriorIntersectionsFinder(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates a finder which finds all interior intersections.
            The intersections are recorded for later inspection.
            </summary>
            <param name="li">A line intersector</param>
            <returns>A finder which finds all interior intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.CreateIntersectionCounter(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates a finder which counts all intersections.
            The intersections are note recorded to reduce memory usage.
            </summary>
            <param name="li">A line intersector.</param>
            <returns>A finder which counts all intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.CreateInteriorIntersectionCounter(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates a finder which counts all interior intersections.
            The intersections are note recorded to reduce memory usage.
            </summary>
            <param name="li">A line intersector.</param>
            <returns>A finder which counts all interior intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.#ctor(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates an intersection finder which finds an interior intersection if one exists
            </summary>
            <param name="li">the LineIntersector to use</param>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.FindAllIntersections">
            <summary>
            Gets/Sets whether all intersections should be computed.
            <remarks>
            When this is <c>false</c> (the default value), the value of <see cref="P:NetTopologySuite.Noding.NodingIntersectionFinder.IsDone"/>
            is <c>true</c> after the first intersection is found.
            Default is <c>false</c>.
            </remarks>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.InteriorIntersectionsOnly">
            <summary>
            Gets or sets a value indicating whether only interior (proper) intersections will be found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.KeepIntersections">
            <summary>
            Gets/Sets whether intersection points are recorded.
            <remarks>
            If the only need is to count intersection points, this can be set to <c>false</c>.
            Default is <c>true</c>.
            </remarks>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.CheckEndSegmentsOnly">
            <summary>
            Gets/Sets whether only end segments should be tested for intersection.
            This is a performance optimization that may be used if
            the segments have been previously noded by an appropriate algorithm.
            It may be known that any potential noding failures will occur only in
            end segments.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.HasIntersection">
            <summary>
            Tests whether an intersection was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.Intersections">
            <summary>
            Gets the intersections found.
            </summary>
            <returns>A list of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.Count">
            <summary>
            Gets the count of intersections found.
            </summary>
            <returns>The intersection count.</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.InteriorIntersection">
            <summary>
            Gets the computed location of the intersection.
            Due to round-off, the location may not be exact.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.Intersection">
            <summary>
            Gets the computed location of the intersection.
            Due to round-off, the location may not be exact.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.IntersectionSegments">
            <summary>
            Gets the endpoints of the intersecting segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s being intersected.<br/>
            Note that some clients (such as <c>MonotoneChain</c>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.IsInteriorVertexIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Tests if an intersection occurs between a segmentString interior vertex and another vertex.
            Note that intersections between two endpoint vertices are valid noding,
            and are not flagged.
            </summary>
            <param name="p00">A segment vertex</param>
            <param name="p01">A segment vertex</param>
            <param name="p10">A segment vertex</param>
            <param name="p11">A segment vertex</param>
            <param name="isEnd00">true if vertex is a segmentString endpoint</param>
            <param name="isEnd01">true if vertex is a segmentString endpoint</param>
            <param name="isEnd10">true if vertex is a segmentString endpoint</param>
            <param name="isEnd11">true if vertex is a segmentString endpoint</param>
            <returns><c>true</c> if an intersection is found/</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.IsInteriorVertexIntersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Boolean,System.Boolean)">
            <summary>
            Tests if two vertices with at least one in a segmentString interior
            are equal.
            </summary>
            <param name="p0">A segment vertex</param>
            <param name="p1">A segment vertex</param>
            <param name="isEnd0"><c>true</c> if vertex is a segmentString endpoint</param>
            <param name="isEnd1"><c>true</c> if vertex is a segmentString endpoint</param>
            <returns><c>true</c> if an intersection is found</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingIntersectionFinder.IsEndSegment(NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            Tests whether a segment in a <see cref="T:NetTopologySuite.Noding.ISegmentString" /> is an end segment.
            (either the first or last).
            </summary>
            <param name="segStr">a segment string</param>
            <param name="index">the index of a segment in the segment string</param>
            <returns>true if the segment is an end segment</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.NodingIntersectionFinder.IsDone">
            <summary>
            
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.NodingValidator">
            <summary>
            Validates that a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator.#ctor(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Creates a new validator for the given collection
            of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            </summary>
            <param name="segStrings">The seg strings.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator.CheckValid">
            <summary>
            Checks whether the supplied segment strings
            are correctly noded.  Throws an exception if they are not.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator.CheckCollapses">
            <summary>
            Checks if a segment string contains a segment pattern a-b-a (which implies a self-intersection).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator.CheckInteriorIntersections">
            <summary>
            Checks all pairs of segments for intersections at an interior point of a segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator.CheckEndPtVertexIntersections">
            <summary>
            Checks for intersections between an endpoint of a segment string
            and an interior vertex of another segment string
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Octants">
            <summary>
            Octants in the Cartesian plane.
            Octants are numbered as follows:
             <para>
              \2|1/
             3 \|/ 0
             ---+--
             4 /|\ 7
              /5|6\
            </para>
             If line segments lie along a coordinate axis, the octant is the lower of the two possible values.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Null">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Zero">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.One">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Two">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Three">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Four">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Five">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Six">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Octants.Seven">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Octant">
            <summary>
             Methods for computing and working with <see cref="T:NetTopologySuite.Noding.Octants"/> of the Cartesian plane.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Octant.GetOctant(System.Double,System.Double)">
            <summary>
            Returns the octant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Octant.GetOctant(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the octant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.OrientedCoordinateArray">
            <summary>
             Allows comparing <see cref="T:NetTopologySuite.Geometries.Coordinate" /> arrays in an orientation-independent way.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.OrientedCoordinateArray.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Noding.OrientedCoordinateArray" />}
            for the given <see cref="T:NetTopologySuite.Geometries.Coordinate" /> array.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.OrientedCoordinateArray.Orientation(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the canonical orientation for a coordinate array.
            </summary>
            <param name="pts"></param>
            <returns>
            <c>true</c> if the points are oriented forwards <br/>
            or <c>false</c>if the points are oriented in reverse.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.OrientedCoordinateArray.CompareTo(System.Object)">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Noding.OrientedCoordinateArray" />s for their relative order.
            </summary>
            <param name="o1"></param>
            <returns>
            -1 this one is smaller;<br/>
             0 the two objects are equal;<br/>
             1 this one is greater.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.OrientedCoordinateArray.CompareOriented(NetTopologySuite.Geometries.Coordinate[],System.Boolean,NetTopologySuite.Geometries.Coordinate[],System.Boolean)">
             <summary>
            
             </summary>
             <param name="pts1"></param>
             <param name="orientation1"></param>
             <param name="pts2"></param>
             <param name="orientation2"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.ScaledNoder">
            <summary>
            Wraps a <see cref="T:NetTopologySuite.Noding.INoder" /> and transforms its input into the integer domain.
            This is intended for use with Snap-Rounding noders,
            which typically are only intended to work in the integer domain.
            <para>
            Clients should be aware that rescaling can involve loss of precision,
            which can cause zero-length line segments to be created.
            These in turn can cause problems when used to build a planar graph.
            This situation should be checked for and collapsed segments removed if necessary.
            </para>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder.#ctor(NetTopologySuite.Noding.INoder,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.ScaledNoder"/> class.
            </summary>
            <param name="noder">The noder to use</param>
            <param name="scaleFactor">The scale factor to use</param>
        </member>
        <member name="P:NetTopologySuite.Noding.ScaledNoder.IsIntegerPrecision">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder.GetNodedSubstrings">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
             <summary>
            
             </summary>
             <param name="inputSegStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder.Scale(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder.Scale(NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentExtractingNoder">
            <summary>
            A noder which extracts all line segments 
            as <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            This enables fast overlay of geometries which are known to be already fully noded.
            In particular, it provides fast union of polygonal and linear coverages.
            Unioning a noded set of lines is an effective way 
            to perform line merging and line dissolving.
            <para/>
            No precision reduction is carried out. 
            If that is required, another noder must be used (such as a snap-rounding noder),
            or the input must be precision-reduced beforehand.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentIntersectionDetector">
            <summary>
            Detects and records an intersection between two <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s,
            if one exists.  Only a single intersection is recorded.
            </summary>
            <remarks>
            This strategy can be configured to search for <b>proper</b> intersections.
            In this case, the presence of <i>any</i> intersection will still be recorded,
            but searching will continue until either a proper intersection has been found
            or no intersections are detected.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentIntersectionDetector.#ctor">
            <summary>
            Creates an intersection finder using a <see cref="T:NetTopologySuite.Algorithm.RobustLineIntersector"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentIntersectionDetector.#ctor(NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Creates an intersection finder using a given <see cref="T:NetTopologySuite.Algorithm.LineIntersector"/>
            </summary>
            <param name="li">The LineIntersector to use</param>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.FindProper">
            <summary>
            Gets or sets whether processing must continue until a proper intersection is found
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.FindAllIntersectionTypes">
            <summary>
            Gets or sets whether processing can terminate once any intersection is found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.HasIntersection">
            <summary>
            Tests whether an intersection was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.HasProperIntersection">
            <summary>
            Tests whether a proper intersection was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.HasNonProperIntersection">
            <summary>
            Tests whether a non-proper intersection was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.Intersection">
            <summary>
            Gets the computed location of the intersection. Due to round-off, the location may not be exact.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.IntersectionSegments">
            <summary>Gets the endpoints of the intersecting segments.
            </summary>
            <remarks>An array of the segment endpoints (p00, p01, p10, p11)</remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentIntersectionDetector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s being intersected.
            </summary>
            <remarks>
            Note that some clients (such as <c>MonotoneChain</c>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentIntersectionDetector.IsDone">
            <summary>
            Tests whether processing can terminate,
            because all required information has been obtained
            (e.g. an intersection of the desired type has been detected).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentNode">
            <summary>
            Represents an intersection point between two <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.SegmentNode.Coord">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.SegmentNode.SegmentIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode.#ctor(NetTopologySuite.Noding.INodableSegmentString,NetTopologySuite.Geometries.Coordinate,System.Int32,NetTopologySuite.Noding.Octants)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SegmentNode"/> class.
            </summary>
            <param name="segString"></param>
            <param name="coord"></param>
            <param name="segmentIndex"></param>
            <param name="segmentOctant"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentNode.Coordinate">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.Coordinate"/> giving the location of this node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentNode.IsInterior">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode.IsEndPoint(System.Int32)">
             <summary>
            
             </summary>
             <param name="maxSegmentIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode.CompareTo(System.Object)">
            <summary>
            </summary>
            <param name="obj"></param>
            <returns>
            -1 this SegmentNode is located before the argument location;<br/>
             0 this SegmentNode is at the argument location;<br/>
             1 this SegmentNode is located after the argument location.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentNodeList">
            <summary>
            A list of the <see cref="T:NetTopologySuite.Noding.SegmentNode" />s present along a noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.#ctor(NetTopologySuite.Noding.NodedSegmentString)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SegmentNodeList"/> class.
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentNodeList.Edge">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.Add(NetTopologySuite.Geometries.Coordinate,System.Int32)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
            <returns>The SegmentIntersection found or added.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.GetEnumerator">
            <summary>
            Returns an iterator of SegmentNodes.
            </summary>
            <returns>An iterator of SegmentNodes.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.AddEndpoints">
            <summary>
            Adds nodes for the first and last points of the edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.AddCollapsedNodes">
            <summary>
            Adds nodes for any collapsed edge pairs.
            Collapsed edge pairs can be caused by inserted nodes, or they can be
            pre-existing in the edge vertex list.
            In order to provide the correct fully noded semantics,
            the vertex at the base of a collapsed pair must also be added as a node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.FindCollapsesFromExistingVertices(System.Collections.Generic.List{System.Int32})">
            <summary>
            Adds nodes for any collapsed edge pairs
            which are pre-existing in the vertex list.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.FindCollapsesFromInsertedNodes(System.Collections.Generic.List{System.Int32})">
            <summary>
            Adds nodes for any collapsed edge pairs caused by inserted nodes
            Collapsed edge pairs occur when the same coordinate is inserted as a node
            both before and after an existing edge vertex.
            To provide the correct fully noded semantics,
            the vertex must be added as a node as well.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.FindCollapseIndex(NetTopologySuite.Noding.SegmentNode,NetTopologySuite.Noding.SegmentNode,System.Int32@)">
             <summary>
            
             </summary>
             <param name="ei0"></param>
             <param name="ei1"></param>
             <param name="collapsedVertexIndex"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.AddSplitEdges(System.Collections.Generic.ICollection{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the provided argument list
            (this is so a single list can be used to accumulate all split edges
            for a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.CreateSplitEdge(NetTopologySuite.Noding.SegmentNode,NetTopologySuite.Noding.SegmentNode)">
            <summary>
             Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.CreateSplitEdgePts(NetTopologySuite.Noding.SegmentNode,NetTopologySuite.Noding.SegmentNode)">
            <summary>
            Extracts the points for a split edge running between two nodes.
            The extracted points should contain no duplicate points.
            There should always be at least two points extracted
            (which will be the given nodes).
            </summary>
            <param name="ei0">The start node of the split edge</param>
            <param name="ei1">The end node of the split edge</param>
            <returns>The points for the split edge</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.GetSplitCoordinates">
            <summary>Gets the list of coordinates for the fully noded segment string,
            including all original segment string vertices and vertices
            introduced by nodes in this list.
            Repeated coordinates are collapsed.
            </summary>
            <returns>An array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.NodeVertexIterator">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodeVertexIterator.#ctor(NetTopologySuite.Noding.SegmentNodeList)">
             <summary>
            
             </summary>
             <param name="nodeList"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodeVertexIterator.ReadNextNode">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.NodeVertexIterator.Current">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodeVertexIterator.MoveNext">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodeVertexIterator.Reset">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentPointComparator">
            <summary>
            Implements a robust method of comparing the relative position of two points along the same segment.
            The coordinates are assumed to lie "near" the segment.
            This means that this algorithm will only return correct results
            if the input coordinates have the same precision and correspond to rounded values
            of exact coordinates lying on the segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentPointComparator.Compare(NetTopologySuite.Noding.Octants,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.Coordinate" />s for their relative position along a segment
            lying in the specified <see cref="T:NetTopologySuite.Noding.Octant" />.
            </summary>
            <param name="octant"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns>
            -1 if node0 occurs first, or<br/>
             0 if the two nodes are equal, or <br/>
             1 if node1 occurs first.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentPointComparator.RelativeSign(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="x0"></param>
             <param name="x1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentPointComparator.CompareValue(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="compareSign0"></param>
             <param name="compareSign1"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.ISegmentSetMutualIntersector">
            <summary>
            An intersector for the red-blue intersection problem.
            In this class of line arrangement problem,
            two disjoint sets of linestrings are intersected.
            <para/>
            Implementing classes must provide a way
            of supplying the base set of segment strings to
            test against (e.g. in the constructor,
            for straightforward thread-safety).
            <para/>
            In order to allow optimizing processing,
            the following condition is assumed to hold for each set:
            <list Type="Bullet">
            <item><description>the only intersection between any two linestrings occurs at their endpoints.</description></item>
            </list>
            Implementations can take advantage of this fact to optimize processing
            (i.e. by avoiding testing for intersections between linestrings
            belonging to the same set).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.ISegmentSetMutualIntersector.Process(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Computes the intersections with a given set of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s,
            using the supplied <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/>.
            </summary>
            <param name="segmentStrings">A collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s to node</param>
            <param name="segmentIntersector">The intersection detector to either record intersection occurrences
            or add intersection nodes to the input segment strings.</param>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentStringDissolver">
            <summary>
            Dissolves a noded collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s to produce
            a set of merged linework with unique segments.
            </summary>
            <remarks>
            A custom <see cref="T:NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger"/> merging strategy
            can be supplied.
            This strategy will be called when two identical (up to orientation)
            strings are dissolved together.
            The default merging strategy is simply to discard one of the merged strings.
            <para>
            A common use for this class is to merge noded edges
            while preserving topological labelling.
            This requires a custom merging strategy to be supplied
            to merge the topology labels appropriately.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger">
            <summary>
            A merging strategy which can be used to update the context data of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s
            which are merged during the dissolve process.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger.Merge(NetTopologySuite.Noding.ISegmentString,NetTopologySuite.Noding.ISegmentString,System.Boolean)">
            <summary>
            Updates the context data of a <see cref="T:NetTopologySuite.Noding.ISegmentString" />
            when an identical (up to orientation) one is found during dissolving.
            </summary>
            <param name="mergeTarget">The segment string to update.</param>
            <param name="ssToMerge">The segment string being dissolved.</param>
            <param name="isSameOrientation">
            <c>true</c> if the strings are in the same direction,
            <c>false</c> if they are opposite.
            </param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.#ctor(NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger)">
            <summary>
            Creates a dissolver with a user-defined merge strategy.
            </summary>
            <param name="merger"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.#ctor">
            <summary>
            Creates a dissolver with the default merging strategy.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.Dissolve(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Dissolve all <see cref="T:NetTopologySuite.Noding.ISegmentString" />s in the input <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.Add(NetTopologySuite.Noding.OrientedCoordinateArray,NetTopologySuite.Noding.ISegmentString)">
             <summary>
            
             </summary>
             <param name="oca"></param>
             <param name="segString"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.Dissolve(NetTopologySuite.Noding.ISegmentString)">
            <summary>
            Dissolve the given <see cref="T:NetTopologySuite.Noding.ISegmentString" />.
            </summary>
            <param name="segString"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver.FindMatching(NetTopologySuite.Noding.OrientedCoordinateArray)">
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentStringDissolver.Dissolved">
            <summary>
            Gets the collection of dissolved (i.e. unique) <see cref="T:NetTopologySuite.Noding.ISegmentString" />s
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentStringUtil">
            <summary>
            Utility methods for processing <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringUtil.ExtractSegmentStrings(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts all linear components from a given <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            to <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.<br/>
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>'s data item is set to be the source <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to extract from.</param>
            <returns>a list of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringUtil.ExtractNodedSegmentStrings(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts all linear components from a given <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            to <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s.<br/>
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>'s data item is set to be the source <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to extract from.</param>
            <returns>a list of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringUtil.ExtractBasicSegmentStrings(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts all linear components from a given <see cref="T:NetTopologySuite.Geometries.Geometry"/> to <see cref="T:NetTopologySuite.Noding.BasicSegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.BasicSegmentString"/>'s data item is set to be the source Geometry.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to extract from.</param>
            <returns>a list of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringUtil.ToGeometry(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Converts a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s into a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The geometry will be either a <see cref="T:NetTopologySuite.Geometries.LineString"/>
            or a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> (possibly empty).
            </summary>
            <param name="segStrings">A collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>.</param>
            <param name="geomFact">A geometry factory</param>
            <returns>A <see cref="T:NetTopologySuite.Geometries.LineString"/> or a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.SimpleNoder">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s by
            performing a brute-force comparison of every segment to every other one.
            This has n^2 performance, so is too slow for use on large numbers of segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SimpleNoder"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder.#ctor(NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SimpleNoder"/> class.
            </summary>
            <param name="segInt"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of fully noded <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString" />s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder.ComputeIntersects(NetTopologySuite.Noding.ISegmentString,NetTopologySuite.Noding.ISegmentString)">
             <summary>
            
             </summary>
             <param name="e0"></param>
             <param name="e1"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector">
            <summary>
            Intersects two sets of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s using
            brute-force comparison.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Constructs a new intersector for a given set of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            </summary>
            <param name="baseSegStrings">The base segment strings to intersect</param>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.Process(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Calls <see cref="M:NetTopologySuite.Noding.ISegmentIntersector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)"/>
            for all <i>candidate</i> intersections between
            the given collection of SegmentStrings and the set of base segments.
            </summary>
            <param name="segmentStrings">A collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s to node</param>
            <param name="segmentIntersector">The intersection detector to either record intersection occurences
            or add intersection nodes to the input segment strings.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.Intersect(NetTopologySuite.Noding.ISegmentString,NetTopologySuite.Noding.ISegmentString,NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Processes all of the segment pairs in the given segment strings
            using the given <paramref name="segInt">SegmentIntersector</paramref>.
            </summary>
            <param name="ss0">A segment string</param>
            <param name="ss1">A segment string</param>
            <param name="segInt">The segment intersector to use</param>
        </member>
        <member name="T:NetTopologySuite.Noding.SinglePassNoder">
            <summary>
            Base class for <see cref="T:NetTopologySuite.Noding.INoder" />s which make a single pass to find intersections.
            This allows using a custom <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" />
            (which for instance may simply identify intersections, rather than insert them).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SinglePassNoder"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder.#ctor(NetTopologySuite.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SinglePassNoder"/> class.
            </summary>
            <param name="segInt">The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> to use.</param>
        </member>
        <member name="P:NetTopologySuite.Noding.SinglePassNoder.SegmentIntersector">
            <summary>
            Gets/sets the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" /> to use with this noder.
            A <see cref="T:NetTopologySuite.Noding.ISegmentIntersector" />  will normally add intersection nodes
            to the input segment strings, but it may not - it may
            simply record the presence of intersections.
            However, some <see cref="T:NetTopologySuite.Noding.INoder" />s may require that intersections be added.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder">
            <summary>
            Finds intersections between line segments which are being snapped,
            and adds them as nodes.
            </summary>
            <version>1.17</version>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.#ctor(System.Double,NetTopologySuite.Noding.Snap.SnappingPointIndex)">
            <summary>
            Creates an intersector which finds all snapped intersections,
            and adds them as nodes.
            </summary>
            <param name="snapTolerance">The snapping tolerance distance</param>
            <param name="snapPointIndex">A snap index to use</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s being intersected.
            Note that some clients (such as <c>MonotoneChain</c>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.ProcessNearVertex(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            If an endpoint of one segment is near
            the <i>interior</i> of the other segment, add it as an intersection.
            EXCEPT if the endpoint is also close to a segment endpoint
            (since this can introduce "zigs" in the linework).
            <para/>
            This resolves situations where
            a segment A endpoint is extremely close to another segment B,
            but is not quite crossing.  Due to robustness issues
            in orientation detection, this can
            result in the snapped segment A crossing segment B
            without a node being introduced.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.IsAdjacent(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            Test if two segments are adjacent segments on the same SegmentString.
            Note that closed edges require a special check for the point shared by the beginning
            and end segments.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.IsDone">
            <inheritdoc cref="P:NetTopologySuite.Noding.ISegmentIntersector.IsDone"/>>
            <remarks>Always process all intersections</remarks>>
            <returns><c>false</c></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snap.SnappingNoder">
            <summary>
            Nodes a set of segment strings
            snapping vertices and intersection points together if
            they lie within the given snap tolerance distance.
            Vertices take priority over intersection points for snapping.
            Input segment strings are generally only split at true node points
            (i.e.the output segment strings are of maximal length in the output arrangement).
            <para/>
            The snap tolerance should be chosen to be as small as possible
            while still producing a correct result.
            It probably only needs to be small enough to eliminate
            "nearly-coincident" segments, for which intersection points cannot be computed accurately.
            This implies a factor of about 10e-12
            smaller than the magnitude of the segment coordinates.
            <para/>
            With an appropriate snap tolerance this algorithm appears to be very robust.
            So far no failure cases have been found,
            given a small enough snap tolerance.
            <para/>
            The correctness of the output is not verified by this noder.
            If required this can be done by <see cref="T:NetTopologySuite.Noding.ValidatingNoder"/>. 
            </summary>
            <version>1.17</version>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingNoder.#ctor(System.Double)">
            <summary>
            Creates a snapping noder using the given snap distance tolerance.
            </summary>
            <param name="snapTolerance">Points are snapped if within this distance</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingNoder.GetNodedSubstrings">
            <inheritdoc cref="M:NetTopologySuite.Noding.INoder.GetNodedSubstrings"/>>
            <returns>A collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s representing the substrings</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>Computes the noding of a set of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s</summary>
            <param name="inputSegmentStrings">A Collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingNoder.SeedSnapIndex(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Seeds the snap index with a small set of vertices
            chosen quasi-randomly using a low-discrepancy sequence.
            Seeding the snap index KdTree induces a more balanced tree.
            This prevents monotonic runs of vertices
            unbalancing the tree and causing poor query performance.
            </summary>
            <param name="segStrings">The segStrings to be noded</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingNoder.ComputeIntersections(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s,
            and returns their <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s.
            <para/>
            Also adds the intersection nodes to the segments.
            </summary>
            <returns>A list of noded substrings</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snap.SnappingPointIndex">
            <summary>
            An index providing fast creation and lookup of snap points.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Snap.SnappingPointIndex._snapPointIndex">
            <summary>
            Since points are added incrementally, this index needs to be dynamic.
            This class also makes use of the KdTree support for a tolerance distance
            for point equality.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingPointIndex.#ctor(System.Double)">
            <summary>
            Creates a snap point index using a specified distance tolerance.
            </summary>
            <param name="snapTolerance">Points are snapped if within this distance</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snap.SnappingPointIndex.Snap(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Snaps a coordinate to an existing snap point,
            if it is within the snap tolerance distance.
            Otherwise adds the coordinate to the snap point index.
            </summary>
            <param name="p">The point to snap</param>
            <returns>The point it snapped to, or the input point</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.Snap.SnappingPointIndex.Tolerance">
            <summary>
            Gets a value indicating the snapping tolerance value for the index
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snap.SnappingPointIndex.Depth">
            <summary>
            Gets a value indicating the depth of the tree
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.GeometryNoder">
            <summary>
            Nodes the linework in a list of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s using Snap-Rounding
            to a given <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            <para>
            The input coordinates do not need to be rounded to the
            precision model.
            All output coordinates are rounded to the precision model.
            </para><para>
            This class does <b>not</b> dissolve the output linework,
            so there may be duplicate linestrings in the output.
            Subsequent processing (e.g. polygonization) may require
            the linework to be unique.  Using <c>UnaryUnion</c> is one way
            to do this (although this is an inefficient approach).
            </para></summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.GeometryNoder.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates a new noder which snap-rounds to a grid specified by the given <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>
            </summary>
            <param name="pm">The precision model for the grid to snap-round to.</param>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.GeometryNoder.IsValidityChecked">
            <summary>
            Gets or sets whether noding validity is checked after noding is performed.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.GeometryNoder.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Nodes the linework of a set of Geometrys using SnapRounding.
            </summary>
            <param name="geoms">A collection of Geometrys of any type</param>
            <returns>A list of LineStrings representing the noded linework of the input</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.HotPixel">
            <summary>
            Implements a "hot pixel" as used in the Snap Rounding algorithm.
            A hot pixel is a square region centred
            on the rounded valud of the coordinate given,
            and of width equal to the size of the scale factor.
            It is a partially open region, which contains
            the interior of the tolerance square and
            the boundary
            <b>minus</b> the top and right segments.
            This ensures that every point of the space lies in a unique hot pixel.
            It also matches the rounding semantics for numbers.
            <para/>
            The hot pixel operations are all computed in the integer domain
            to avoid rounding problems.
            <para/>
            Hot Pixels support being marked as nodes.
            This is used to prevent introducing nodes at line vertices
            which do not have other lines snapped to them.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Snapround.HotPixel._hpx">
            <summary>The <b>scaled</b> x-ordinate of the hot pixel point (<see cref="P:NetTopologySuite.Noding.Snapround.HotPixel.Coordinate"/>)</summary>
        </member>
        <member name="F:NetTopologySuite.Noding.Snapround.HotPixel._hpy">
            <summary>The <b>scaled</b> y-ordinate of the hot pixel point (<see cref="P:NetTopologySuite.Noding.Snapround.HotPixel.Coordinate"/>)</summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.#ctor(NetTopologySuite.Geometries.Coordinate,System.Double,NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.HotPixel"/> class.
            </summary>
            <param name="pt">The coordinate at the center of the hot pixel</param>
            <param name="scaleFactor">The scale factor determining the pixel size</param>
            <param name="li">The intersector to use for testing intersection with line segments</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.#ctor(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Creates a new hot pixel centered on a rounded point, using a given scale factor.
            The scale factor must be strictly positive(non-zero).
            </summary>
            <param name="pt">The coordinate at the center of the hot pixel (already rounded)</param>
            <param name="scaleFactor">The scale factor determining the pixel size</param>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.HotPixel.Coordinate">
            <summary>
            Gets the coordinate this hot pixel is based at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.HotPixel.ScaleFactor">
            <summary>
            Gets the scale factor for the precision grid for this pixel.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.HotPixel.Width">
            <summary>
            Gets the width of the hot pixel in the original coordinate system.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.HotPixel.IsNode">
            <summary>
            Gets or sets a value indicating whether this pixel has been marked as a node.
            </summary>
            <returns><c>true</c> if the pixel is marked as a node</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.Scale(System.Double)">
            <summary>
            Scale without rounding.
            This ensures intersections are checked against original
            linework.
            This is required to ensure that intersections are not missed
            because the segment is moved by snapping.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.GetSafeEnvelope">
            <summary>
            Returns a "safe" envelope that is guaranteed to contain the hot pixel.
            The envelope returned will be larger than the exact envelope of the pixel.
            </summary>
            <returns>An envelope which contains the pixel</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.Intersects(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a coordinate lies in (intersects) this hot pixel.
            </summary>
            <param name="p">The coordinate to test</param>
            <returns><c>true</c> if the coordinate intersects this hot pixel</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the line segment (p0-p1)
            intersects this hot pixel.
            </summary>
            <param name="p0">The first coordinate of the line segment to test</param>
            <param name="p1">The second coordinate of the line segment to test</param>
            <returns>true if the line segment intersects this hot pixel.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.IntersectsScaled(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.IntersectsPixelClosure(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Test whether the given segment intersects
            the closure of this hot pixel.
            This is NOT the test used in the standard snap-rounding
            algorithm, which uses the partially closed tolerance square instead.
            This routine is provided for testing purposes only.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel.AddSnappedNode(NetTopologySuite.Noding.INodableSegmentString,System.Int32)">
            <summary>
            Adds a new node (equal to the snap pt) to the specified segment
            if the segment passes through the hot pixel
            </summary>
            <param name="segStr"></param>
            <param name="segIndex"></param>
            <returns><c>true</c> if a node was added to the segment</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.HotPixelIndex">
            <summary>
             An index which creates unique <see cref="T:NetTopologySuite.Noding.Snapround.HotPixel"/>s for provided points,
            and performs range queries on them.
            The points passed to the index do not needed to be
            rounded to the specified scale factor; this is done internally
            when creating the HotPixels for them.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates a new hot pixel index using the provided <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            </summary>
            <param name="pm">The precision model</param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates">
            <summary>
            Utility class to enumerate through a shuffled array of
            <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s using the
            <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle algorithm</a>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates an instance of this class using the provided <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="pts">An array of coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.ShuffledCoordinatesEnumerator.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates an instance of this class using the provided <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="pts">An array of coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.ShuffledCoordinatesEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.ShuffledCoordinatesEnumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset"/>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.ShuffledCoordinatesEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.ShuffledCoordinatesEnumerator.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.ShuffledCoordinates.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Adds a series of points as non-node pixels
            </summary>
            <param name="pts">The points to add</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.AddNodes(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Adds a list of points as node pixels.
            </summary>
            <param name="pts">The points to add</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.Add(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds a point as a Hot Pixel. <br/>
            If the point has been added already, it is marked as a node.
            </summary>
            <param name="p">The point to add</param>
            <returns>The hot-pixel for the point</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixelIndex.Query(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Index.KdTree.IKdNodeVisitor{NetTopologySuite.Noding.Snapround.HotPixel})">
            <summary>
            Visits all the hot pixels which may intersect a segment (p0-p1).
            The visitor must determine whether each hot pixel actually intersects
            the segment.
            </summary>
            <param name="p0">The segment start point</param>
            <param name="p1">The segment end point</param>
            <param name="visitor">The visitor to apply</param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper">
            <summary>
            "Snaps" all <see cref="T:NetTopologySuite.Noding.ISegmentString" />s in a <see cref="!:ISpatialIndex" /> containing
            <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain" />s to a given <see cref="T:NetTopologySuite.Noding.Snapround.HotPixel" />.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.#ctor(NetTopologySuite.Index.ISpatialIndex{NetTopologySuite.Index.Chain.MonotoneChain})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper"/> class.
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.QueryVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.QueryVisitor.#ctor(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <param name="action"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.QueryVisitor.VisitItem(NetTopologySuite.Index.Chain.MonotoneChain)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.Snap(NetTopologySuite.Noding.Snapround.HotPixel,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            Snaps (nodes) all interacting segments to this hot pixel.
            The hot pixel may represent a vertex of an edge,
            in which case this routine uses the optimization
            of not noding the vertex itself
            </summary>
            <param name="hotPixel">The hot pixel to snap to.</param>
            <param name="parentEdge">The edge containing the vertex, if applicable, or <c>null</c>.</param>
            <param name="hotPixelVertexIndex"></param>
            <returns><c>true</c> if a node was added for this pixel.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.Snap(NetTopologySuite.Noding.Snapround.HotPixel)">
            <summary>
            Snaps (nodes) all interacting segments to this hot pixel.
            The hot pixel may represent a vertex of an edge,
            in which case this routine uses the optimization
            of not noding the vertex itself
            </summary>
            <param name="hotPixel">The hot pixel to snap to.</param>
            <returns><c>true</c> if a node was added for this pixel.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.GetSafeEnvelope(NetTopologySuite.Noding.Snapround.HotPixel)">
            <summary>
            Returns a "safe" envelope that is guaranteed to contain the hot pixel.
            The envelope returned is larger than the exact envelope of the
            pixel by a safe margin.
            </summary>
            <returns>An envelope which contains the hot pixel</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.#ctor(NetTopologySuite.Noding.Snapround.HotPixel,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction"/> class.
            </summary>
            <param name="hotPixel"></param>
            <param name="parentEdge"></param>
            <param name="hotPixelVertexIndex"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.IsNodeAdded">
            <summary>
            Reports whether the HotPixel caused a node to be added in any target
            segmentString(including its own). If so, the HotPixel must be added as a
            node as well.
            </summary>
            <returns>
            <c>true</c> if a node was added in any target segmentString.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.Select(NetTopologySuite.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            Check if a segment of the monotone chain intersects
            the hot pixel vertex and introduce a snap node if so.
            Optimized to avoid noding segments which
            contain the vertex (which otherwise
            would cause every vertex to be noded).
            </summary>
            <param name="mc">A monotone chain</param>
            <param name="startIndex">A start index</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.AddSnappedNode(NetTopologySuite.Noding.Snapround.HotPixel,NetTopologySuite.Noding.INodableSegmentString,System.Int32)">
            <summary>
            Adds a new node (equal to the snap pt) to the specified segment
            if the segment passes through the hot pixel
            </summary>
            <returns><see langword="true"/> if a node was added to the segment</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Implements the Snap Rounding technique described in
            papers by Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid;
            hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision.
            <para/>
            This implementation uses a monotone chains and a spatial index to
            speed up the intersection tests.
            <para/>
            <h3>KNOWN BUGS</h3>
            This implementation is not fully robust.
            instead.
            </summary>
            <seealse cref="T:NetTopologySuite.Noding.Snapround.SnapRoundingNoder"/>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString" />s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.SnapRound(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Algorithm.LineIntersector)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <param name="li"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.FindInteriorIntersections(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString},NetTopologySuite.Algorithm.LineIntersector)">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s,
            and returns their <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.
            <para/>
            Does NOT node the segStrings.
            </summary>
            <param name="segStrings"></param>
            <param name="li"></param>
            <returns>A list of Coordinates for the intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.ComputeIntersectionSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Snaps segments to nodes created by segment intersections.
            </summary>
            <param name="snapPts"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.ComputeVertexSnaps(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Snaps segments to all vertices
            </summary>
            <param name="edges">The list of segment strings to snap together</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.ComputeVertexSnaps(NetTopologySuite.Noding.INodableSegmentString)">
            <summary>
            Snaps segments to the vertices of a Segment String.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.SimpleSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            <para/>
            Implements the Snap Rounding technique described in
            the papers by Hobby, Guibas &amp; Marimont, and Goodrich et al.
            Snap Rounding enforces that all vertices lie on a uniform grid,
            which is determined by the provided <seealso cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            Input vertices do not have to be rounded to this grid;
            this will be done during the snap-rounding process.
            <para/>
            This implementation uses simple iteration over the line segments.
            This is not an efficient approach for large sets of segments.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.SimpleSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:NetTopologySuite.Geometries.PrecisionModel" /> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s.
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s have the same context as their parent.
            </summary>
            <returns>A Collection of NodedSegmentStrings representing the substrings</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.ISegmentString" />s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings">A collection of NodedSegmentStrings</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.SnapRound(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.Round(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Gets a list of the rounded coordinates.
            Duplicate (collapsed) coordinates are removed.
            </summary>
            <param name="pts">The coordinates to round</param>
            <returns>An array of rounded coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.FindInteriorIntersections(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:NetTopologySuite.Noding.ISegmentString" />s,
            and returns their <see cref="T:NetTopologySuite.Geometries.Coordinate" />s.
            <para/>
            Also adds the intersection nodes to the segments.
            </summary>
            <param name="segStrings"></param>
            <returns>A list of <see cref="T:NetTopologySuite.Geometries.Coordinate" />s for the intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(NetTopologySuite.Noding.NodedSegmentString)">
             <summary>
            
             </summary>
             <param name="ss"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.SnapSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Noding.NodedSegmentString,System.Int32)">
            <summary>
            This is where all the work of snapping to hot pixels gets done
            (in a very inefficient brute-force way).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
            <param name="edges">The list of segment strings to snap together</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(NetTopologySuite.Noding.INodableSegmentString,NetTopologySuite.Noding.INodableSegmentString)">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:NetTopologySuite.Noding.ISegmentString" />.
            This has n^2 performance.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder">
            <summary>
            Finds intersections between line segments which will be snap-rounded,
            and adds them as nodes to the segments.
            <para/>
            Intersections are detected and computed using full precision.
            Snapping takes place in a subsequent phase.
            <para/>
            The intersection points are recorded, so that HotPixels can be created for them.
            <para/>
            To avoid robustness issues with vertices which lie very close to line segments
            a heuristic is used:
            nodes are created if a vertex lies within a tolerance distance
            of the interior of a segment.
            The tolerance distance is chosen to be significantly below the snap-rounding grid size.
            This has empirically proven to eliminate noding failures.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates an intersector which finds all snapped interior intersections,
            and adds them as nodes.
            </summary>
            <param name="pm">The precision model to use</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.#ctor(System.Double)">
            <summary>
            Creates an intersector which finds all snapped interior intersections,
            and adds them as nodes.
            </summary>
            <param name="nearnessTol">the intersection distance tolerance</param>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.Intersections">
            <summary>
            Gets the created intersection nodes,
            so they can be processed as hot pixels.
            </summary>
            <returns>A list of intersection points</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString"/>
            s being intersected.
            Note that some clients (such as <c>MonotoneChain</c> s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g.by an disjoint envelope test).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.ProcessNearVertex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            If an endpoint of one segment is near
            the <i>interior</i> of the other segment, add it as an intersection.
            EXCEPT if the endpoint is also close to a segment endpoint
            (since this can introduce "zigs" in the linework).
            <para/>
            This resolves situations where
            a segment A endpoint is extremely close to another segment B,
            but is not quite crossing.Due to robustness issues
            in orientation detection, this can
            result in the snapped segment A crossing segment B
            without a node being introduced.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.IsDone">
            <summary>
            Always process all intersections
            </summary>
            <returns>Always <c>false</c></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.SnapRoundingNoder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s,
            in a performant way, and avoiding unnecessary noding.
            <para/>
            Implements the Snap Rounding technique described in 
            the papers by Hobby, Guibas &amp; Marimont, and Goodrich et al.
            Snap Rounding enforces that all output vertices lie on a uniform grid,
            which is determined by the provided <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            <para/>
            Input vertices do not have to be rounded to the grid beforehand; 
            this is done during the snap-rounding process.
            In fact, rounding cannot be done a priori,
            since rounding vertices by themselves can distort the rounded topology
            of the arrangement (i.e. by moving segments away from hot pixels
            that would otherwise intersect them, or by moving vertices
            across segments).
            <para/>
            To minimize the number of introduced nodes,
            the Snap-Rounding Noder avoids creating nodes
            at edge vertices if there is no intersection or snap at that location.
            However, if two different input edges contain identical segments,
            each of the segment vertices will be noded.
            This still provides fully-noded output.
            This is the same behaviour provided by other noders,
            such as <see cref="T:NetTopologySuite.Noding.MCIndexNoder"/>
            and <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/>.
            </summary>
            <version>1.17</version>
        </member>
        <member name="F:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.NEARNESS_FACTOR">
            <summary>
            The division factor used to determine
            nearness distance tolerance for intersection detection.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.GetNodedSubstrings">
            <summary>
            Gets a Collection of NodedSegmentStrings representing the substrings
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes the nodes in the snap-rounding line arrangement.
            The nodes are added to the <see cref="T:NetTopologySuite.Noding.NodedSegmentString"/>s provided as the input.
            </summary>
            <param name="inputSegmentStrings">A Collection of NodedSegmentStrings</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.AddIntersectionPixels(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Detects interior intersections in the collection of {@link SegmentString}s,
            and adds nodes for them to the segment strings.
            Also creates HotPixel nodes for the intersection points.
            </summary>
            <param name="segStrings">The input NodedSegmentStrings</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.AddVertexPixels(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Creates HotPixels for each vertex in the input segStrings.
            The HotPixels are not marked as nodes, since they will
            only be nodes in the final line arrangement
            if they interact with other segments(or they are already
            created as intersection nodes).
            </summary>
            <param name="segStrings">The input NodedSegmentStrings</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.Round(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Gets a list of the rounded coordinates.
            Duplicate (collapsed) coordinates are removed.
            </summary>
            <param name="pts">The coordinates to round</param>
            <returns>Array of rounded coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.ComputeSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Computes new segment strings which are rounded and contain
            intersections added as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="segStrings">Segments to snap</param>
            <returns>The snapped segment strings</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.ComputeSegmentSnaps(NetTopologySuite.Noding.NodedSegmentString)">
            <summary>
            Add snapped vertices to a segment string.
            If the segment string collapses completely due to rounding,
            null is returned.
            </summary>
            <param name="ss">The segment string to snap</param>
            <returns>
            The snapped segment string, or null if it collapses completely
            </returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.SnapSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Noding.NodedSegmentString,System.Int32)">
            <summary>
            Snaps a segment in a segmentString to HotPixels that it intersects.
            </summary>
            <param name="p0">The segment start coordinate</param>
            <param name="p1">The segment end coordinate</param>
            <param name="ss">The segment string to add intersections to</param>
            <param name="segIndex">The index of the segment/</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SnapRoundingNoder.AddVertexNodeSnaps(NetTopologySuite.Noding.NodedSegmentString)">
            <summary>
            Add nodes for any vertices in hot pixels that were
            added as nodes during segment noding.
            </summary>
            <param name="ss">A noded segment string</param>
        </member>
        <member name="T:NetTopologySuite.Noding.ValidatingNoder">
            <summary>
            A wrapper for <see cref="T:NetTopologySuite.Noding.INoder"/>s which validates
            the output arrangement is correctly noded.
            An arrangement of line segments is fully noded if
            there is no line segment
            which has another segment intersecting its interior.
            If the noding is not correct, a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown
            with details of the first invalid location found.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Noding.FastNodingValidator"/>
        </member>
        <member name="M:NetTopologySuite.Noding.ValidatingNoder.#ctor(NetTopologySuite.Noding.INoder)">
            <summary>
            Creates a noding validator wrapping the given <paramref name="noder"/>
            </summary>
            <param name="noder">The noder to validate</param>
        </member>
        <member name="M:NetTopologySuite.Noding.ValidatingNoder.ComputeNodes(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Checks whether the output of the wrapped noder is fully noded.
            Throws an exception if it is not.
            </summary>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException"></exception>
        </member>
        <member name="M:NetTopologySuite.Noding.ValidatingNoder.GetNodedSubstrings">
            <inheritdoc cref="M:NetTopologySuite.Noding.INoder.GetNodedSubstrings"/>
        </member>
        <member name="T:NetTopologySuite.NtsGeometryServices">
            <summary>
            A geometry service provider class
            </summary>
            <remarks>
            When overriding this class, you need to provide a public constructor with the following arguments:
            <list type="number">
            <item><c>CoordinateSequenceFactory</c><description>A factory to create coordinate sequences</description></item>
            <item><term><c>PrecisionModel</c></term><description>A precision model</description></item>
            <item><term><c>int</c></term><description>spatial reference id (srid)</description></item>
            <item><term><c>GeometryOverlay</c></term><description>A class that bundles an overlay operation function set</description></item>
            <item><term><c>CoordinateEqualityComparer</c></term><description>A class that performs checks <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s for equality.</description></item>
            </list>
            <see cref="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.GeometryOverlay,NetTopologySuite.Geometries.CoordinateEqualityComparer)"/>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor">
            <summary>
            Creates an instance of this class, using the <see cref="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory"/>
            as default and a <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> precision model.<br/>
            No <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/> is specified.<br/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryOverlay.Legacy"/> function set for overlay operations is being used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.GeometryOverlay)">
            <summary>
            Creates an instance of this class, using the <see cref="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory"/>
            as default and a <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> precision model.
            No <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/> is specified
            </summary>
            <param name="geometryOverlay">The function set to perform overlay operations</param>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates an instance of this class, using the <see cref="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory"/> as default.<br/>
            No <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/> is specified.<br/>
            The default precision model is defined by <paramref name="precisionModel"/>.<br/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryOverlay.Legacy"/> function set for overlay operations is being used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Creates an instance of this class, using the <see cref="T:NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory"/> as default.<br/>
            A value of <paramref name="srid"/> is assigned to <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/>.<br/>
            The default precision model is defined by <paramref name="precisionModel"/>.<br/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryOverlay.Legacy"/> function set for overlay operations is being used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Creates an instance of this class, using a <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> precision model as default.<br/>
            No <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/> is specified.<br/>
            The default coordinate sequence factory is defined by <paramref name="coordinateSequenceFactory"/>.<br/>
            The <see cref="P:NetTopologySuite.Geometries.GeometryOverlay.Legacy"/> function set for overlay operations is being used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Creates an instance of this class, using the provided <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/>,
            <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/> and spatial reference Id (<paramref name="srid"/>).
            </summary>
            <param name="coordinateSequenceFactory">The coordinate sequence factory to use.</param>
            <param name="precisionModel">The precision model.</param>
            <param name="srid">The default spatial reference ID</param>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.#ctor(NetTopologySuite.Geometries.CoordinateSequenceFactory,NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.GeometryOverlay,NetTopologySuite.Geometries.CoordinateEqualityComparer)">
            <summary>
            Creates an instance of this class, using the provided <see cref="T:NetTopologySuite.Geometries.CoordinateSequenceFactory"/>,
            <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>, a spatial reference Id (<paramref name="srid"/>) and
            a <see cref="T:NetTopologySuite.Geometries.GeometryOverlay"/>.
            </summary>
            <param name="coordinateSequenceFactory">The coordinate sequence factory to use.</param>
            <param name="precisionModel">The precision model.</param>
            <param name="srid">The default spatial reference ID</param>
            <param name="geometryOverlay">The geometry overlay function set to use.</param>
            <param name="coordinateEqualityComparer">The equality comparer for coordinates</param>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.Instance">
            <summary>
            Gets or sets the default instance of <see cref="T:NetTopologySuite.NtsGeometryServices"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            Thrown when trying to set the value to <see langword="null"/>.
            </exception>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.GeometryOverlay">
            <summary>
            Gets or sets a value indicating the operations to use for geometry overlay.  
            </summary>
            <returns>A set of geometry overlay functions.</returns>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.CoordinateEqualityComparer">
            <summary>
            Gets an object that is used to test 2 coordinates for equality.
            </summary>
            <returns>A coordinate equality tester object</returns>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.DefaultSRID">
            <summary>
            Gets the default spatial reference id
            </summary>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.DefaultCoordinateSequenceFactory">
            <summary>
            Gets or sets the coordiate sequence factory to use
            </summary>
        </member>
        <member name="P:NetTopologySuite.NtsGeometryServices.DefaultPrecisionModel">
            <summary>
            Gets or sets the default precision model
            </summary>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreatePrecisionModel(NetTopologySuite.Geometries.PrecisionModels)">
            <summary>
            Creates a precision model based on given precision model type
            </summary>
            <returns>The precision model type</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreatePrecisionModel(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates a precision model based on given precision model.
            </summary>
            <returns>The precision model</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreatePrecisionModel(System.Double)">
            <summary>
            Creates a precision model based on the given scale factor.
            </summary>
            <param name="scale">The scale factor</param>
            <returns>The precision model.</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory">
            <summary>
            Creates or retrieves a geometry factory using <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/>, <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultPrecisionModel"/> and
            <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultCoordinateSequenceFactory"/>.
            </summary>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory(System.Int32)">
            <summary>
            Creates or retrieves a geometry factory using <paramref name="srid"/>, <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultPrecisionModel"/> and
            <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultCoordinateSequenceFactory"/>.
            </summary>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory(NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Creates or retrieves a geometry factory using <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/>, <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultPrecisionModel"/> and
            <paramref name="coordinateSequenceFactory"/>.
            </summary>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates or retrieves a geometry factory using <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultSRID"/>, <paramref name="precisionModel"/> and
            <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultCoordinateSequenceFactory"/>.
            </summary>
            <param name="precisionModel">The precision model to use.</param>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory(NetTopologySuite.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Creates or retrieves a geometry factory using <paramref name="srid"/>, <paramref name="precisionModel"/> and
            <see cref="P:NetTopologySuite.NtsGeometryServices.DefaultCoordinateSequenceFactory"/>.
            </summary>
            <param name="precisionModel">The precision model to use.</param>
            <param name="srid">The spatial reference id.</param>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactory(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Creates or retrieves a geometry factory using <paramref name="srid"/>, <paramref name="precisionModel"/> and
            <paramref name="coordinateSequenceFactory"/>.
            </summary>
            <param name="precisionModel">The precision model to use.</param>
            <param name="srid">The spatial reference id.</param>
            <param name="coordinateSequenceFactory"></param>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.NtsGeometryServices.CreateGeometryFactoryCore(NetTopologySuite.Geometries.PrecisionModel,System.Int32,NetTopologySuite.Geometries.CoordinateSequenceFactory)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> based on the given parameters.
            </summary>
            <param name="precisionModel">
            The value for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.PrecisionModel"/>.
            </param>
            <param name="srid">
            The value for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.SRID"/>.
            </param>
            <param name="coordinateSequenceFactory">
            The value for <see cref="P:NetTopologySuite.Geometries.GeometryFactory.CoordinateSequenceFactory"/>.
            </param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> that has the given values.
            </returns>
            <remarks>
            <para>
            This method is expected to be safe to call from any number of threads at once.
            </para>
            <para>
            Implementations <strong>must</strong> make sure to use a constructor which
            is properly assigning <see cref="P:NetTopologySuite.NtsGeometryServices.GeometryOverlay"/> to the factory.
            </para>
            <para>
            Although the result for a given set of parameters is cached, there is no guarantee that,
            once this method is called with some set of parameters, it will never be called again
            with an exactly equal set of parameters.  When this does happen, an arbitrary result is
            chosen as the winner (not necessarily the first one to start or finish), and all other
            results are discarded.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Operation.BoundaryOp">
            <summary>
            Computes the boundary of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Allows specifying the <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> to be used.
            This operation will always return a <see cref="T:NetTopologySuite.Geometries.Geometry"/> of the appropriate
            dimension for the boundary (even if the input geometry is empty).
            The boundary of zero-dimensional geometries (Points) is
            always the empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.GetBoundary(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a geometry representing the boundary of a geometry.
            </summary>
            <param name="g">The input geometry.</param>
            <returns>The computed boundary.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.GetBoundary(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Computes a geometry representing the boundary of a geometry,
            using an explicit <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>.
            </summary>
            <param name="g">The input geometry.</param>
            <param name="bnRule">The Boundary Node Rule to use.</param>
            <returns>The computed boundary.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.HasBoundary(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Tests if a geometry has a boundary (it is non-empty).<br/>
            The semantics are:
            <list type="bullet">
            <item><description>Empty geometries do not have boundaries.</description></item>
            <item><description>Points do not have boundaries.</description></item>
            <item><description>For linear geometries the existence of the boundary 
            is determined by the <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>.</description></item>
            <item><description>Non-empty polygons always have a boundary.</description></item>
            </list>
            </summary>
            <param name="geom">The geometry providing the boundary</param>
            <param name="boundaryNodeRule">The Boundary Node Rule to use</param>
            <returns><c>true</c> if the boundary exists</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Operation.BoundaryOp"/> class for the given geometry.
            </summary>
            <param name="geom">The input geometry.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Operation.BoundaryOp"/> class for the given geometry.
            </summary>
            <param name="geom">The input geometry.</param>
            <param name="bnRule">Tthe Boundary Node Rule to use.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.BoundaryOp.GetBoundary">
            <summary>
            Gets the computed boundary.
            </summary>
            <returns>The boundary geometry.</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.BoundaryOp._endpointMap">
            <summary>
            A map which maintains the edges in sorted order around the node.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Counter">
            <summary>
            Stores an integer count, for use as a Map entry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferBuilder">
            <summary>
            Builds the buffer geometry for a given input geometry and precision model.
            Allows setting the level of approximation for circular arcs,
            and the precision model in which to carry out the computation.
            </summary>
            <remarks>
            When computing buffers in floating point double-precision
            it can happen that the process of iterated noding can fail to converge (terminate).
            In this case a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> will be thrown.
            Retrying the computation in a fixed precision
            can produce more robust results.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder.DepthDelta(NetTopologySuite.GeometriesGraph.Label)">
            <summary>Compute the change in depth as an edge is crossed from R to L</summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder.#ctor(NetTopologySuite.Operation.Buffer.BufferParameters)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Operation.Buffer.BufferBuilder"/> class using the given parameters.
            </summary>
            <param name="bufParams">The buffer parameters to use.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder.WorkingPrecisionModel">
            <summary>
            Sets the precision model to use during the curve computation and noding,
            if it is different to the precision model of the Geometry.
            </summary>
            <remarks>
            If the precision model is less than the precision of the Geometry precision model,
            the Geometry must have previously been rounded to that precision.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder.Noder">
            <summary>
            Sets the <see cref="T:NetTopologySuite.Noding.INoder"/> to use during noding.
            This allows choosing fast but non-robust noding, or slower
            but robust noding.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder.InvertOrientation">
            <summary>
            Sets whether the offset curve is generated
            using the inverted orientation of input rings.
            This allows generating a buffer(0) polygon from the smaller lobes
            of self-crossing rings.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder.InsertUniqueEdge(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Inserted edges are checked to see if an identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder.BuildSubgraphs(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Buffer.BufferSubgraph},NetTopologySuite.Operation.Overlay.PolygonBuilder)">
            <summary>
            Completes the building of the input subgraphs by depth-labelling them,
            and adds them to the PolygonBuilder.
            </summary>
            <remarks>
            The subgraph list must be sorted in rightmost-coordinate order.
            </remarks>
            <param name="subgraphList"> the subgraphs to build</param>
            <param name="polyBuilder"> the PolygonBuilder which will build the final polygons</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder.CreateEmptyResultGeometry">
            <summary>
            Gets the standard result for an empty buffer.
            Since buffer always returns a polygonal result, this is chosen to be an empty polygon.
            </summary>
            <returns>The empty result geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder">
            <summary>
            Creates all the raw offset curves for a buffer of a <c>Geometry</c>.
            Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.#ctor(NetTopologySuite.Geometries.Geometry,System.Double,NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Operation.Buffer.BufferParameters)">
             <summary>
            
             </summary>
             <param name="inputGeom">The input geometry</param>
             <param name="distance">The offset distance</param>
             <param name="precisionModel">A precision model</param>
             <param name="parameters">The buffer parameters</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.InvertOrientation">
            <summary>
            Gets or sets a value indicating whether the offset curve is generated
            using the inverted orientation of input rings.
            This allows generating a buffer(0) polygon from the smaller lobes
            of self-crossing rings.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.IsRingCCW(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes orientation of a ring using a signed-area orientation test.
            For invalid (self-crossing) rings this ensures the largest enclosed area
            is taken to be the interior of the ring.
            This produces a more sensible result when
            used for repairing polygonal geometry via buffer-by-zero.
            For buffer  use the lower robustness of orientation-by-area
            doesn't matter, since narrow or flat rings
            produce an acceptable offset curve for either orientation.
            </summary>
            <param name="coord">The ring coordinates</param>
            <returns>true if the ring is CCW</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.GetCurves">
            <summary>
            Computes the set of raw offset curves for the buffer.
            Each offset curve has an attached {Label} indicating
            its left and right location.
            </summary>
            <returns>A Collection of SegmentStrings representing the raw buffer curves.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.AddCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Creates a {SegmentString} for a coordinate list which is a raw offset curve,
            and adds it to the list of buffer curves.
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Location.Exterior.
            Right: Location.Interior.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.Add(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.AddCollection(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.AddPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.Clean(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Keeps only valid coordinates, and removes repeated points.
            </summary>
            <param name="coords">The coordinates to clean</param>
            <returns>An array of clean coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.AddPolygon(NetTopologySuite.Geometries.Polygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.AddRingSide(NetTopologySuite.Geometries.Coordinate[],System.Double,NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Adds an offset curve for a polygon ring.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.IsRingCurveInverted(NetTopologySuite.Geometries.Coordinate[],System.Double,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether the offset curve for a ring is fully inverted.
            An inverted ("inside-out") curve occurs in some specific situations
            involving a buffer distance which should result in a fully-eroded (empty) buffer.
            It can happen that the sides of a small, convex polygon
            produce offset segments which all cross one another to form
            a curve with inverted orientation.<br/>
            This happens at buffer distances slightly greater than the distance at
            which the buffer should disappear.<br/>
            The inverted curve will produce an incorrect non-empty buffer (for a shell)
            or an incorrect hole (for a hole).
            It must be discarded from the set of offset curves used in the buffer.
            Heuristics are used to reduce the number of cases which area checked,
            for efficiency and correctness.
            <para/>
            See <a href="https://github.com/locationtech/jts/issues/472"/>
            </summary>
            <param name="inputPts">the input ring</param>
            <param name="distance">the buffer distance</param>
            <param name="curvePts">the generated offset curve</param>
            <returns>true if the offset curve is inverted</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.MaxDistance(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the maximum distance out of a set of points to a linestring.
            </summary>
            <param name="pts">The points</param>
            <param name="line">The linestring vertices</param>
            <returns>The maximum distance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.IsErodedCompletely(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Tests whether a ring buffer is eroded completely (is empty)
            based on simple heuristics.
            <para/>
            The <paramref name="ringCoord"/> is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
            <param name="ringCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.IsTriangleErodedCompletely(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.
            </summary>
            <param name="triangleCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier">
            <summary>
            Simplifies a buffer input line to remove concavities with shallow depth.
            </summary>
            <remarks>
            <para>
            The most important benefit of doing this
            is to reduce the number of points and the complexity of
            shape which will be buffered.
            It also reduces the risk of gores created by
            the quantized fillet arcs (although this issue
            should be eliminated in any case by the
            offset curve generation logic).
            </para>
            <para>
            A key aspect of the simplification is that it
            affects inside (concave or inward) corners only.
            Convex (outward) corners are preserved, since they
            are required to ensure that the generated buffer curve
            lies at the correct distance from the input geometry.
            </para>
            <para>
            Another important heuristic used is that the end segments
            of the input are never simplified.  This ensures that
            the client buffer code is able to generate end caps faithfully.
            </para>
            <para>
            No attempt is made to avoid self-intersections in the output.
            This is acceptable for use for generating a buffer offset curve,
            since the buffer algorithm is insensitive to invalid polygonal
            geometry.  However,
            this means that this algorithm
            cannot be used as a general-purpose polygon simplification technique.
            </para>
            </remarks>
            <author> Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.Simplify(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Simplify the input coordinate list.
            If the distance tolerance is positive,
            concavities on the LEFT side of the line are simplified.
            If the supplied distance tolerance is negative,
            concavities on the RIGHT side of the line are simplified.
            </summary>
            <param name="inputLine">The coordinate list to simplify</param>
            <param name="distanceTol">simplification distance tolerance to use</param>
            <returns>The simplified coordinate list</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.Simplify(System.Double)">
            <summary>
            Simplify the input coordinate list.
            </summary>
            <remarks>
            If the distance tolerance is positive, concavities on the LEFT side of the line are simplified.
            If the supplied distance tolerance is negative, concavities on the RIGHT side of the line are simplified.
            </remarks>
            <param name="distanceTol">Simplification distance tolerance to use</param>
            <returns>
            The simplified coordinates list
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.DeleteShallowConcavities">
            <summary>
            Uses a sliding window containing 3 vertices to detect shallow angles
            in which the middle vertex can be deleted, since it does not
            affect the shape of the resulting buffer in a significant way.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.FindNextNonDeletedIndex(System.Int32)">
            <summary>
            Finds the next non-deleted index, or the end of the point array if none
            </summary>
            <param name="index">The start index to search from</param>
            <returns>The next non-deleted index, if any <br/>
            or <c>_inputLine.Length</c> if there are no more non-deleted indices
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.IsShallowSampled(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Int32,System.Int32,System.Double)">
            <summary>
            Checks for shallowness over a sample of points in the given section.
            This helps to prevent the simplification from incrementally
            "skipping" over points which are in fact non-shallow.
            </summary>
            <param name="p0">A coordinate of section</param>
            <param name="p2">A coordinate of section</param>
            <param name="i0">The start index of section</param>
            <param name="i2">The end index of section</param>
            <param name="distanceTol">The tolerated distance</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferOp">
            <summary>
            Computes the buffer of a geometry, for both positive and negative buffer distances.
            </summary>
            <remarks>
            <para>
            In GIS, the positive (or negative) buffer of a geometry is defined as
            the Minkowski sum (or difference) of the geometry
            with a circle of radius equal to the absolute value of the buffer distance.
            In the CAD/CAM world buffers are known as <i>offset curves</i>.
            In morphological analysis the
            operation of positive and negative buffering
            is referred to as <i>erosion</i> and <i>dilation</i>
            </para>
            <para>
            The buffer operation always returns a polygonal result.
            The negative or zero-distance buffer of lines and points is always an empty <see cref="T:NetTopologySuite.Geometries.Polygon" />.
            </para>
            <para>
            Since true buffer curves may contain circular arcs,
            computed buffer polygons are only approximations to the true geometry.
            The user can control the accuracy of the approximation by specifying
            the number of linear segments used to approximate arcs.
            This is specified via <see cref="P:NetTopologySuite.Operation.Buffer.BufferParameters.QuadrantSegments"/>
            or <see cref="P:NetTopologySuite.Operation.Buffer.BufferOp.QuadrantSegments"/>.
            </para>
            <para>
            The <see cref="P:NetTopologySuite.Operation.Buffer.BufferParameters.EndCapStyle"/> of a linear buffer may be specified.
            The following end cap styles are supported:
            <ul>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round" /> - the usual round end caps</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat" /> - end caps are truncated flat at the line ends</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square" /> - end caps are squared off at the buffer distance beyond the line ends</li>
            </ul>
            </para>
            <para>
            The <see cref="P:NetTopologySuite.Operation.Buffer.BufferParameters.JoinStyle"/> of the corners in a buffer may be specified.
            The following join styles are supported:
            <ul>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Round" /> - the usual round join</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Mitre" /> - corners are "sharp" (up to a <see cref="P:NetTopologySuite.Operation.Buffer.BufferParameters.MitreLimit"/> distance limit})</li>
            <li><see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Bevel" /> - corners are beveled (clipped off)</li>
            </ul>
            </para>
            <para>
            The buffer algorithm may perform simplification on the input to increase performance.
            The simplification is performed a way that always increases the buffer area
            (so that the simplified input covers the original input).
            The degree of simplification can be specified with <see cref="P:NetTopologySuite.Operation.Buffer.BufferParameters.SimplifyFactor"/>,
            with a <see cref="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultSimplifyFactor"/> used otherwise.
            Note that if the buffer distance is zero then so is the computed simplify tolerance,
            no matter what the simplify factor.
            </para>
            <para>
            Buffer results are always valid geometry.
            Given this, computing a zero-width buffer of an invalid polygonal geometry is
            an effective way to "validify" the geometry.
            Note however that in the case of self-intersecting "bow-tie" geometries,
            only the largest enclosed area will be retained.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferOp.MaxPrecisionDigits">
            <summary>
            A number of digits of precision which leaves some computational "headroom"
            for floating point operations.
            </summary>
            <remarks>
            This value should be less than the decimal precision of double-precision values (16).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.PrecisionScaleFactor(NetTopologySuite.Geometries.Geometry,System.Double,System.Int32)">
             <summary>
             Compute a scale factor to limit the precision of
             a given combination of Geometry and buffer distance.
             The scale factor is determined by
             the number of digits of precision in the (geometry + buffer distance),
             limited by the supplied <paramref name="maxPrecisionDigits"/> value.
             <para/>
             The scale factor is based on the absolute magnitude of the (geometry + buffer distance).
             since this determines the number of digits of precision which must be handled.
             </summary>
             <param name="g"> the Geometry being buffered</param>
             <param name="distance"> the buffer distance</param>
             <param name="maxPrecisionDigits"> the max # of digits that should be allowed by
                      the precision determined by the computed scale factor</param>
            
             <returns> a scale factor for the buffer computation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.Buffer(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the buffer of a geometry for a given buffer distance.
            </summary>
            <param name="g"> the geometry to buffer</param>
            <param name="distance"> the buffer distance</param>
            <returns> the buffer of the input geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.Buffer(NetTopologySuite.Geometries.Geometry,System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)">
            <summary>
            Computes the buffer for a geometry for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g"> the geometry to buffer</param>
            <param name="distance"> the buffer distance</param>
            <param name="parameters"> the buffer parameters to use</param>
            <returns> the buffer of the input geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.Buffer(NetTopologySuite.Geometries.Geometry,System.Double,System.Int32)">
            <summary>
            Computes the buffer for a geometry for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g"> the geometry to buffer</param>
            <param name="distance"> the buffer distance</param>
            <param name="quadrantSegments"> the number of segments used to approximate a quarter circle</param>
            <returns> the buffer of the input geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.BufferByZero(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Buffers a geometry with distance zero.
            The result can be computed using the maximum-signed-area orientation,
            or by combining both orientations.
            <para/>
            This can be used to fix an invalid polygonal geometry to be valid
            (i.e.with no self-intersections).
            For some uses(e.g.fixing the result of a simplification)
            a better result is produced by using only the max-area orientation.
            Other uses (e.g.fixing geometry) require both orientations to be used.
            <para/>
            This function is for INTERNAL use only.
            </summary>
            <param name="geom">The polygonal geometry to buffer by zero</param>
            <param name="isBothOrientations">A flag indicating if both orientations of input rings should be used</param>
            <returns>The buffered polygonal geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.Combine(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Combines the elements of two polygonal geometries together.
            The input geometries must be non-adjacent, to avoid
            creating an invalid result.
            </summary>
            <param name="poly0">A polygonal geometry (which may be empty)</param>
            <param name="poly1">Another polygonal geometry (which may be empty)</param>
            <returns>A combined polygonal geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Initializes a buffer computation for the given geometry
            </summary>
            <param name="g"> the geometry to buffer</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Buffer.BufferParameters)">
            <summary>
            Initializes a buffer computation for the given geometry
            with the given set of parameters
            </summary>
            <param name="g"> the geometry to buffer</param>
            <param name="bufParams"> the buffer parameters to use</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferOp.QuadrantSegments">
            <summary>
            Gets or sets the number of line segments in a quarter-circle
            used to approximate angle fillets for round end caps and joins.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp.GetResultGeometry(System.Double)">
            <summary>
            Returns the buffer computed for a geometry for a given buffer distance.
            </summary>
            <param name="distance"> the buffer distance</param>
            <returns> the buffer of the input geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferParameters">
            <summary>
            A value class containing the parameters which
            specify how a buffer should be constructed.
            <para/>
            The parameters allow control over:
            <list type="bullet">
            <item><description>Quadrant segments (accuracy of approximation for circular arcs)</description></item>
            <item><description>End Cap style</description></item>
            <item><description>Join style</description></item>
            <item><description>Mitre limit</description></item>
            <item><description>whether the buffer is single-sided</description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultQuadrantSegments">
            <summary>
            The default number of facets into which to divide a fillet of 90 degrees.<br/>
            A value of 8 gives less than 2% max error in the buffer distance.<para/>
            For a max error of &lt; 1%, use QS = 12.<para/>
            For a max error of &lt; 0.1%, use QS = 18.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultJoinStyle">
            <summary>
            The default number of facets into which to divide a fillet of 90 degrees.<br/>
            A value of 8 gives less than 2% max error in the buffer distance.<para/>
            For a max error of &lt; 1%, use QS = 12.<para/>
            For a max error of &lt; 0.1%, use QS = 18.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultMitreLimit">
            <summary>
            The default mitre limit
            Allows fairly pointy mitres.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultSimplifyFactor">
            <summary>
            The default simplify factor.
            Provides an accuracy of about 1%, which matches
            the accuracy of the <see cref="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultQuadrantSegments"/> parameter.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.#ctor">
            <summary>
            Creates a default set of parameters
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.#ctor(System.Int32)">
            <summary>
            Creates a set of parameters with the given quadrantSegments value.
            </summary>
            <param name="quadrantSegments">The number of quadrant segments to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.#ctor(System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle)">
            <summary>
            Creates a set of parameters with the
            given quadrantSegments and endCapStyle values.
            </summary>
            <param name="quadrantSegments"> the number of quadrant segments to use</param>
            <param name="endCapStyle"> the end cap style to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.#ctor(System.Int32,NetTopologySuite.Operation.Buffer.EndCapStyle,NetTopologySuite.Operation.Buffer.JoinStyle,System.Double)">
            <summary>
            Creates a set of parameters with the
            given parameter values.
            </summary>
            <param name="quadrantSegments"> the number of quadrant segments to use</param>
            <param name="endCapStyle"> the end cap style to use</param>
            <param name="joinStyle"> the join style to use</param>
            <param name="mitreLimit"> the mitre limit to use</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.QuadrantSegments">
            <summary>
            Gets or sets the number of line segments in a quarter-circle
            used to approximate angle fillets in round endcaps and joins.
            The value should be at least 1.
            <para/>
            This determines the
            error in the approximation to the true buffer curve.<br/>
            The default value of 8 gives less than 2% error in the buffer distance.<para/>
            For an error of &lt; 1%, use QS = 12.<para/>
            For an error of &lt; 0.1%, use QS = 18.<para/>
            The error is always less than the buffer distance
            (in other words, the computed buffer curve is always inside the true
            curve).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.BufferDistanceError(System.Int32)">
            <summary>
            Computes the maximum distance error due to a given level of approximation to a true arc.
            </summary>
            <param name="quadSegs">The number of segments used to approximate a quarter-circle</param>
            <returns>The error of approximation</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.EndCapStyle">
            <summary>
            Gets or sets the end cap style of the generated buffer.
            </summary>
            <remarks>
            <para>
            The styles supported are <see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round"/>,
            <see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat"/>, and
            <see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square"/>.
            </para>
            <para>The default is <see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round"/>.</para>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.JoinStyle">
            <summary>
            Gets/Sets the join style for outside (reflex) corners between line segments.
            </summary>
            <remarks>
            <para>The styles supported are <see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Round"/>,
            <see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Mitre"/> and <see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Bevel"/></para>
            The default is <see cref="F:NetTopologySuite.Operation.Buffer.JoinStyle.Round"/>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.MitreLimit">
            <summary>
            Sets the limit on the mitre ratio used for very sharp corners.
            </summary>
            <remarks>
            <para>
            The mitre ratio is the ratio of the distance from the corner
            to the end of the mitred offset corner.
            When two line segments meet at a sharp angle,
            a miter join will extend far beyond the original geometry.
            (and in the extreme case will be infinitely far.)
            To prevent unreasonable geometry, the mitre limit
            allows controlling the maximum length of the join corner.
            Corners with a ratio which exceed the limit will be beveled.
            </para>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.IsSingleSided">
            <summary>
            Gets or sets whether the computed buffer should be single-sided.
            A single-sided buffer is constructed on only one side of each input line.
            <para>
            The side used is determined by the sign of the buffer distance:
            <list type="bullet">
            <item><description>a positive distance indicates the left-hand side</description></item>
            <item><description>a negative distance indicates the right-hand side</description></item>
            </list>
            The single-sided buffer of point geometries is  the same as the regular buffer.
            </para><para>
            The End Cap Style for single-sided buffers is always ignored,
            and forced to the equivalent of <see cref="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat"/>.
            </para>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferParameters.SimplifyFactor">
            <summary>
            Factor used to determine the simplify distance tolerance
            for input simplification.
            Simplifying can increase the performance of computing buffers.
            Generally the simplify factor should be greater than 0.
            Values between 0.01 and .1 produce relatively good accuracy for the generate buffer.
            Larger values sacrifice accuracy in return for performance.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferParameters.Copy">
            <summary>
            Creates a copy 
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferSubgraph">
            <summary>
            A connected subset of the graph of
            <c>DirectedEdges</c> and <c>Node</c>s.
            Its edges will generate either
            a single polygon in the complete buffer, with zero or more holes, or
            one or more connected holes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferSubgraph.DirectedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferSubgraph.Nodes">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferSubgraph.RightMostCoordinate">
            <summary>
            Gets the rightmost coordinate in the edges of the subgraph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.Create(NetTopologySuite.GeometriesGraph.Node)">
            <summary>
            Creates the subgraph consisting of all edges reachable from this node.
            Finds the edges in the graph and the rightmost coordinate.
            </summary>
            <param name="node">A node to start the graph traversal from.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.AddReachable(NetTopologySuite.GeometriesGraph.Node)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode">A node known to be in the subgraph.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.Add(NetTopologySuite.GeometriesGraph.Node,System.Collections.Generic.Stack{NetTopologySuite.GeometriesGraph.Node})">
            <summary>
            Adds the argument node and all its out edges to the subgraph
            </summary>
            <param name="node">The node to add.</param>
            <param name="nodeStack">The current set of nodes being traversed.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.ClearVisitedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.ComputeDepth(System.Int32)">
             <summary>
            
             </summary>
             <param name="outsideDepth"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.ComputeDepths(NetTopologySuite.GeometriesGraph.DirectedEdge)">
            <summary>
            Compute depths for all dirEdges via breadth-first traversal of nodes in graph.
            </summary>
            <param name="startEdge">Edge to start processing with.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.ComputeNodeDepth(NetTopologySuite.GeometriesGraph.Node)">
             <summary>
            
             </summary>
             <param name="n"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.CopySymDepths(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.FindResultEdges">
            <summary>
            Find all edges whose depths indicates that they are in the result area(s).
            Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph.CompareTo(System.Object)">
            <summary>
            BufferSubgraphs are compared on the x-value of their rightmost Coordinate.
            This defines a partial ordering on the graphs such that:
            g1 >= g2 - Ring(g2) does not contain Ring(g1)
            where Polygon(g) is the buffer polygon that is built from g.
            This relationship is used to sort the BufferSubgraphs so that shells are guaranteed to
            be built before holes.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.EndCapStyle">
            <summary>
             End cap style constants
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Round">
            <summary>
            Specifies a round line buffer end cap style.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Flat">
            <summary>
            Specifies a flat line buffer end cap style.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.EndCapStyle.Square">
            <summary>
            Specifies a square line buffer end cap style.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.JoinStyle">
            <summary>
            Join style constants
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.JoinStyle.Round">
            <summary>
            Specifies a round join style.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.JoinStyle.Mitre">
            <summary>
            Specifies a mitre join style.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.JoinStyle.Bevel">
            <summary>
            Specifies a bevel join style.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurve">
            <summary>
            Computes an offset curve from a geometry.
            The offset curve is a linear geometry which is offset a specified distance
            from the input.
            If the offset distance is positive the curve lies on the left side of the input;
            if it is negative the curve is on the right side.
            <list type="bullet">
            <item><description>For a <see cref="T:NetTopologySuite.Geometries.LineString"/> the offset curve is a line.</description></item>
            <item><description>For a <see cref="T:NetTopologySuite.Geometries.Point"/> the offset curve is an empty <see cref="T:NetTopologySuite.Geometries.LineString"/>.</description></item>
            <item><description>For a <see cref="T:NetTopologySuite.Geometries.Polygon"/> the offset curve is the boundary of the polygon buffer (which
            may be a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>).</description></item>
            <item><description>For a collection the output is a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/> containing the element offset curves.</description></item>
            </list>
            <para/>
            The offset curve is computed as a single contiguous section of the geometry buffer boundary.
            In some geometric situations this definition is ill-defined.
            This algorithm provides a "best-effort" interpretation.
            In particular:
            <list type="bullet">
            <item><description>For self-intersecting lines, the buffer boundary includes
            offset lines for both left and right sides of the input line.
            Only a single contiguous portion on the specified side is returned.</description></item>
            <item><description>If the offset corresponds to buffer holes, only the largest hole is used.</description></item>
            </list>
            Offset curves support setting the number of quadrant segments,
            the join style, and the mitre limit(if applicable) via
            the <see cref="T:NetTopologySuite.Operation.Buffer.BufferParameters"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurve.NearnessFactor">
            <summary>
            The nearness tolerance between the raw offset linework and the buffer curve.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.GetCurve(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the offset curve of a geometry at a given distance.
            </summary>
            <param name="geom">A geometry</param>
            <param name="distance">the offset distance (positive = left, negative = right)</param>
            <returns>The offset curve</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.GetCurve(NetTopologySuite.Geometries.Geometry,System.Double,System.Int32,NetTopologySuite.Operation.Buffer.JoinStyle,System.Double)">
            <summary>
            Computes the offset curve of a geometry at a given distance,
            and for a specified quadrant segments, join style and mitre limit.
            </summary>
            <param name="geom">A geometry</param>
            <param name="distance">The offset distance (positive = left, negative = right)</param>
            <param name="quadSegs">The quadrant segments</param>
            <param name="joinStyle">The join style</param>
            <param name="mitreLimit">The mitre limit</param>
            <returns>The offset curve</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.#ctor(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates a new instance for computing an offset curve for a geometryat a given distance.
            with default quadrant segments(<see cref="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultQuadrantSegments"/>
            and join style (<see cref="F:NetTopologySuite.Operation.Buffer.BufferParameters.DefaultJoinStyle"/>).
            </summary>
            <param name="geom">The geometry</param>
            <param name="distance">A distance value</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.#ctor(NetTopologySuite.Geometries.Geometry,System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)">
            Creates a new instance for computing an offset curve for a geometry at a given distance.
            allowing the quadrant segments and join style and mitre limit to be set
            via {@link BufferParameters}.
            
            @param geom
            @param distance
            @param bufParams
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.GetCurve">
            <summary>
            Gets the computed offset curve.
            </summary>
            <returns>The offset curve geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.OffsetCurveMapOp.ToLineString(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Force LinearRings to be LineStrings.
            </summary>
            <param name="geom">A geometry, which may be a <c>LinearRing</c></param>
            <returns>A geometry which will be a <c>LineString</c> or <c>MulitLineString</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.RawOffset(NetTopologySuite.Geometries.LineString,System.Double,NetTopologySuite.Operation.Buffer.BufferParameters)">
            <summary>
            Gets the raw offset line.
            The quadrant segments and join style and mitre limit to be set
            via <see cref="T:NetTopologySuite.Operation.Buffer.BufferParameters"/>.
            <para/>
            The raw offset line may contain loops and other artifacts which are
            not present in the true offset curve.
            The raw offset line is matched to the buffer ring (which is clean)
            to extract the offset curve.
            </summary>
            <param name="geom">The <c>LineString</c> to offset</param>
            <param name="distance">The offset distance</param>
            <param name="bufParams">The buffer parameters to use</param>
            <returns>The raw offset line</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.RawOffset(NetTopologySuite.Geometries.LineString,System.Double)">
            <summary>
            Gets the raw offset line, with default buffer parameters.
            </summary>
            <param name="geom">The <c>LineString</c> to offset</param>
            <param name="distance">The offset distance</param>
            <returns>The raw offset line</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.ExtractMaxAreaPolygon(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the largest polygon by area from a geometry.
            Used here to avoid issues with non-robust buffer results which have spurious extra polygons.
            </summary>
            <param name="geom">A geometry</param>
            <returns>The polygon element of largest area</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurve.MatchCurveSegmentAction">
            <summary>
            An action to match a raw offset curve segment
            to segments in the buffer ring
            and mark them as being in the offset curve.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurve.ExtractSection(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Boolean[])">
            <summary>
            Extracts a section of a ring of coordinates, starting at a given index,
            and keeping coordinates which are flagged as being required.
            </summary>
            <param name="ring">The ring of points</param>
            <param name="startIndex">The index of the start coordinate</param>
            <param name="isExtracted">A flag indicating if coordinate is to be extracted</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder">
            <summary>
            Computes the raw offset curve for a
            single <see cref="T:NetTopologySuite.Geometries.Geometry"/> component (ring, line or point).
            A raw offset curve line is not noded -
            it may contain self-intersections (and usually will).g
            The final buffer polygon is computed by forming a topological graph
            of all the noded raw curves and tracing outside contours.
            The points in the raw curve are rounded
            to a given <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.BufferParameters">
            <summary>
            Gets the buffer parameters being used to generate the curve.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.GetLineCurve(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            This method handles single points as well as LineStrings.
            LineStrings are assumed <b>not</b> to be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <param name="inputPts">The vertices of the line to offset</param>
            <param name="distance">The offset distance</param>
            <returns>A Coordinate array representing the curve <br/>
            or <c>null</c> if the curve is empty
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.IsLineOffsetEmpty(System.Double)">
            <summary>
            Tests whether the offset curve for line or point geometries
            at the given offset distance is empty (does not exist).
            This is the case if:
            <list type="bullet">
            <item><term>the distance is zero</term></item>
            <item><term>the distance is negative, except for the case of singled-sided buffers</term></item>
            </list>
            </summary>
            <param name="distance">The offset curve distance</param>
            <returns><c>true</c> if the offset curve is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.GetRingCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.GeometriesGraph.Positions,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines,
            as well as rings.
            </summary>
            <returns>A Coordinate array representing the curve<br/>
            or <c>null</c> if the curve is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.GetRingCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Position,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines,
            as well as rings.
            </summary>
            <returns>A Coordinate array representing the curve<br/>
            or <c>null</c> if the curve is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.SimplifyTolerance(System.Double)">
            <summary>
            Computes the distance tolerance to use during input
            line simplification.
            </summary>
            <param name="bufDistance">The buffer distance</param>
            <returns>The simplification tolerance</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder">
            <summary>
            Creates all the raw offset curves for a buffer of a <c>Geometry</c>.
            Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.#ctor(NetTopologySuite.Geometries.Geometry,System.Double,NetTopologySuite.Operation.Buffer.OffsetCurveBuilder)">
             <summary>
            
             </summary>
             <param name="inputGeom"></param>
             <param name="distance"></param>
             <param name="curveBuilder"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.InvertOrientation">
            <summary>
            Gets or sets a value indicating whether the offset curve is generated
            using the inverted orientation of input rings.
            This allows generating a buffer(0) polygon from the smaller lobes
            of self-crossing rings.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.IsRingCCW(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes orientation of a ring using a signed-area orientation test.
            For invalid (self-crossing) rings this ensures the largest enclosed area
            is taken to be the interior of the ring.
            This produces a more sensible result when
            used for repairing polygonal geometry via buffer-by-zero.
            For buffer  use the lower robustness of orientation-by-area
            doesn't matter, since narrow or flat rings
            produce an acceptable offset curve for either orientation.
            </summary>
            <param name="coord">The ring coordinates</param>
            <returns>true if the ring is CCW</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.GetCurves">
            <summary>
            Computes the set of raw offset curves for the buffer.
            Each offset curve has an attached {Label} indicating
            its left and right location.
            </summary>
            <returns>A Collection of SegmentStrings representing the raw buffer curves.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.AddCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Creates a {SegmentString} for a coordinate list which is a raw offset curve,
            and adds it to the list of buffer curves.
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Location.Exterior.
            Right: Location.Interior.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.Add(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.AddCollection(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.AddPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.Clean(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Keeps only valid coordinates, and removes repeated points.
            </summary>
            <param name="coords">The coordinates to clean</param>
            <returns>An array of clean coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.AddPolygon(NetTopologySuite.Geometries.Polygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.AddRingSide(NetTopologySuite.Geometries.Coordinate[],System.Double,NetTopologySuite.Geometries.Position,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Adds an offset curve for a polygon ring.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.IsRingCurveInverted(NetTopologySuite.Geometries.Coordinate[],System.Double,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether the offset curve for a ring is fully inverted.
            An inverted ("inside-out") curve occurs in some specific situations
            involving a buffer distance which should result in a fully-eroded (empty) buffer.
            It can happen that the sides of a small, convex polygon
            produce offset segments which all cross one another to form
            a curve with inverted orientation.<br/>
            This happens at buffer distances slightly greater than the distance at
            which the buffer should disappear.<br/>
            The inverted curve will produce an incorrect non-empty buffer (for a shell)
            or an incorrect hole (for a hole).
            It must be discarded from the set of offset curves used in the buffer.
            Heuristics are used to reduce the number of cases which area checked,
            for efficiency and correctness.
            <para/>
            See <a href="https://github.com/locationtech/jts/issues/472"/>
            </summary>
            <param name="inputPts">the input ring</param>
            <param name="distance">the buffer distance</param>
            <param name="curvePts">the generated offset curve</param>
            <returns>true if the offset curve is inverted</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.MaxDistance(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the maximum distance out of a set of points to a linestring.
            </summary>
            <param name="pts">The points</param>
            <param name="line">The linestring vertices</param>
            <returns>The maximum distance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.IsErodedCompletely(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Tests whether a ring buffer is eroded completely (is empty)
            based on simple heuristics.
            <para/>
            The <paramref name="ringCoord"/> is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
            <param name="ringCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.IsTriangleErodedCompletely(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.
            </summary>
            <param name="triangleCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList">
            <summary>
            A list of the vertices in a constructed offset curve.
            </summary>
            <remarks>Automatically removes close adjacent vertices.</remarks>
            <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.PrecisionModel">
            <summary>
            Gets/Sets the precision model to use when adding new points.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.MinimumVertexDistance">
            <summary>
            The distance below which two adjacent points on the curve are considered to be coincident.
            </summary>
            <remarks>This is chosen to be a small fraction of the offset distance.</remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.AddPt(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Function to add a point
            </summary>
            <remarks>
            The point is only added if <see cref="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.IsDuplicate(NetTopologySuite.Geometries.Coordinate)"/> evaluates to false.
            </remarks>
            <param name="pt">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.IsDuplicate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the given point duplicates the previous point in the list (up to tolerance)
            </summary>
            <param name="pt">The point to test</param>
            <returns>true if the point duplicates the previous point</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.CloseRing">
            <summary>
            Automatically closes the ring (if it not alread is).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.Coordinates">
            <summary>
            Gets the Coordinates for the curve.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator">
            <summary>
            Generates segments which form an offset curve.
            Supports all end cap and join options
            provided for buffering.
            This algorithm implements various heuristics to
            produce smoother, simpler curves which are
            still within a reasonable tolerance of the
            true curve.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.OffsetSegmentSeparationFactor">
            <summary>
            Factor which controls how close offset segments can be to
            skip adding a filler or mitre.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.InsideTurnVertexSnapDistanceFactor">
            <summary>
            Factor which controls how close curve vertices on inside turns can be to be snapped
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.CurveVertexSnapDistanceFactor">
            <summary>
            Factor which controls how close curve vertices can be to be snapped
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.MaxClosingSegLenFactor">
            <summary>
            Factor which determines how short closing segs can be for round buffers
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator._maxCurveSegmentError">
            <summary>
            The max error of approximation (distance) between a quad segment and the true fillet curve
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator._filletAngleQuantum">
            <summary>
            The angle quantum with which to approximate a fillet curve
            (based on the input # of quadrant segments)
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator._closingSegLengthFactor">
            <summary>
            The Closing Segment Length Factor controls how long
            "closing segments" are.  Closing segments are added
            at the middle of inside corners to ensure a smoother
            boundary for the buffer offset curve.
            In some cases (particularly for round joins with default-or-better
            quantization) the closing segments can be made quite short.
            This substantially improves performance (due to fewer intersections being created).
            <list type="bullet">
            <item><description>A closingSegFactor of 0 results in lines to the corner vertex</description></item>
            <item><description>A closingSegFactor of 1 results in lines halfway to the corner vertex</description></item>
            <item><description> A closingSegFactor of 80 results in lines 1/81 of the way to the corner vertex
            (this option is reasonable for the very common default situation of round joins
            and quadrantSegs >= 8)</description></item>
            </list>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.HasNarrowConcaveAngle">
            <summary>
            Gets whether the input has a narrow concave angle
            (relative to the offset distance).
            In this case the generated offset curve will contain self-intersections
            and heuristic closing segments.
            This is expected behaviour in the case of buffer curves.
            For pure offset curves,
            the output needs to be further treated
            before it can be used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddLastSegment">
            <summary>
            Add last offset point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddOutsideTurn(NetTopologySuite.Algorithm.OrientationIndex,System.Boolean)">
            <summary>
            Adds the offset points for an outside (convex) turn
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddInsideTurn(NetTopologySuite.Algorithm.OrientationIndex,System.Boolean)">
            <summary>
            Adds the offset points for an inside (concave) turn.
            </summary>
            <param name="orientation"></param>
            <param name="addStartPoint"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.ComputeOffsetSegment(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.Position,System.Double,NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Compute an offset segment for an input segment on a given side and at a given distance.
            The offset points are computed in full double precision, for accuracy.
            </summary>
            <param name="seg">The segment to offset</param>
            <param name="side">The side of the segment <see cref="T:NetTopologySuite.GeometriesGraph.Positions"/> the offset lies on</param>
            <param name="distance">The offset distance</param>
            <param name="offset">The points computed for the offset segment</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddLineEndCap(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Add an end cap around point <paramref name="p1"/>, terminating a line segment coming from <paramref name="p0"/>
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddMitreJoin(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment,System.Double)">
            <summary>
            Adds a mitre join connecting two convex offset segments.
            The mitre is beveled if it exceeds the mitre limit factor.
            The mitre limit is intended to prevent extremely long corners occurring.
            If the mitre limit is very small it can cause unwanted artifacts around fairly flat corners.
            This is prevented by using a simple bevel join in this case.
            In other words, the limit prevents the corner from getting too long,
            but it won't force it to be very short/flat.
            </summary>
            <param name="cornerPt">A corner point</param>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
            <param name="distance">The offset distance</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddLimitedMitreJoin(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment,System.Double,System.Double)">
            <summary>
            Adds a limited mitre join connecting two convex offset segments.
            A limited mitre join is beveled at the distance
            determined by the mitre limit factor,
            or as a standard bevel join, whichever is further.
            </summary>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
            <param name="distance">The offset distance</param>
            <param name="mitreLimitDistance">The mitre limit distance</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.Project(NetTopologySuite.Geometries.Coordinate,System.Double,System.Double)">
            <summary>
            Projects a point to a given distance in a given direction angle.
            </summary>
            <param name="pt">The point to project</param>
            <param name="d">The projection distance</param>
            <param name="dir">The direction angle (in radians)</param>
            <returns>The projected point</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddBevelJoin(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Adds a bevel join connecting the two offset segments
            around a reflex corner.
            </summary>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddCornerFillet(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.OrientationIndex,System.Double)">
            <summary>
            Add points for a circular fillet around a convex corner.
            Adds the start and end points
            </summary>
            <param name="p">Base point of curve</param>
            <param name="p0">Start point of fillet curve</param>
            <param name="p1">Endpoint of fillet curve</param>
            <param name="direction">The orientation of the fillet</param>
            <param name="radius">The radius of the fillet</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.AddDirectedFillet(NetTopologySuite.Geometries.Coordinate,System.Double,System.Double,NetTopologySuite.Algorithm.OrientationIndex,System.Double)">
            <summary>
            Adds points for a circular fillet arc
            between two specified angles.
            The start and end point for the fillet are not added -
            the caller must add them if required.
            </summary>
            <param name="p">The center point</param>
            <param name="direction">Is -1 for a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/> angle, 1 for a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.CounterClockwise"/> angle</param>
            <param name="startAngle">The start angle of the fillet</param>
            <param name="endAngle">The end angle of the fillet</param>
            <param name="radius">The radius of the fillet</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.CreateCircle(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/> circle around a point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator.CreateSquare(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a <see cref="F:NetTopologySuite.Algorithm.OrientationIndex.Clockwise"/> square around a point
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetSegmentString">
            <summary>
            A dynamic list of the vertices in a constructed offset curve.
            Automatically removes adjacent vertices
            which are closer than a given tolerance.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetSegmentString._minimumVertexDistance">
            <summary>
            The distance below which two adjacent points on the curve
            are considered to be coincident.<br/>
            This is chosen to be a small fraction of the offset distance.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetSegmentString.IsRedundant(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the given point is redundant
            relative to the previous
            point in the list (up to tolerance).
            </summary>
            <param name="pt"></param>
            <returns>true if the point is redundant</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder">
            <summary>
            Computes the raw offset curve for a single <see cref="T:NetTopologySuite.Geometries.Geometry"/> component (ring, line or point).
            </summary>
            <remarks>
            A raw offset curve line is not noded - it may contain self-intersections (and usually will).
            The final buffer polygon is computed by forming a topological graph
            of all the noded raw curves and tracing outside contours.
            The points in the raw curve are rounded to the required precision model.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder._filletAngleQuantum">
            <summary>
            The angle quantum with which to approximate a fillet curve
            (based on the input # of quadrant segments)
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder._maxCurveSegmentError">
            <summary>
            The max error of approximation (distance) between a quad segment and the true fillet curve
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.CurveVertexSnapDistanceFactor">
            <summary>
            Factor which controls how close curve vertices can be to be snapped
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.OffsetSegmentSeparationFactor">
            <summary>
            Factor which controls how close offset segments can be to
            skip adding a filler or mitre.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.InsideTurnVertexSnapDistanceFactor">
            <summary>
            Factor which controls how close curve vertices on inside turns can be to be snapped
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.MaxClosingSegFraction">
            <summary>
            Factor which determines how short closing segs can be for round buffers
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder._closingSegFactor">
            <summary>
            The Closing Segment Factor controls how long
            "closing segments" are.  Closing segments are added
            at the middle of inside corners to ensure a smoother
            boundary for the buffer offset curve.<br/>
            In some cases (particularly for round joins with default-or-better
            quantization) the closing segments can be made quite short.
            This substantially improves performance (due to fewer intersections being created).
            <br/>
            A closingSegFactor of 0 results in lines to the corner vertex<br/>
            A closingSegFactor of 1 results in lines halfway to the corner vertex<br/>
            A closingSegFactor of 80 results in lines 1/81 of the way to the corner vertex
            (this option is reasonable for the very common default situation of round joins
            and quadrantSegs >= 8)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.GetLineCurve(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            This method handles single points as well as lines.
            Lines are assumed to <b>not</b> be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <returns>a List of Coordinate[]</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.GetRingCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.GeometriesGraph.Positions,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines, as well as rings.
            </summary>
            <returns>a List of Coordinate[]</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.GetRingCurve(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Position,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines, as well as rings.
            </summary>
            <returns>a List of Coordinate[]</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.SimplifyFactor">
            <summary>
            Use a value which results in a potential distance error which is
            significantly less than the error due to
            the quadrant segment discretization.
            For QS = 8 a value of 100 is reasonable.
            This should produce a maximum of 1% distance error.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.SimplifyTolerance(System.Double)">
            <summary>
            Computes the distance tolerance to use during input
            line simplification.
            </summary>
            <param name="bufDistance">The buffer distance</param>
            <returns>The simplification tolerance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddOutsideTurn(NetTopologySuite.Algorithm.OrientationIndex,System.Boolean)">
            <summary>
            Adds the offset points for an outside (convex) turn
            </summary>
            <param name="orientation">
            </param>
            <param name="addStartPoint"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddInsideTurn(NetTopologySuite.Algorithm.OrientationIndex,System.Boolean)">
            <summary>
            Adds the offset points for an inside (concave) turn.
            </summary>
            <param name="orientation"></param>
            <param name="addStartPoint"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddLastSegment">
            <summary>
            Add last offset point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.ComputeOffsetSegment(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.Position,System.Double,NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Compute an offset segment for an input segment on a given side and at a given distance.
            The offset points are computed in full double precision, for accuracy.
            </summary>
            <param name="seg">The segment to offset</param>
            <param name="side">The side of the segment (<see cref="T:NetTopologySuite.GeometriesGraph.Positions"/>) the offset lies on</param>
            <param name="distance">The offset distance</param>
            <param name="offset">The points computed for the offset segment</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddLineEndCap(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Add an end cap around point p1, terminating a line segment coming from p0
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddMitreJoin(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment,System.Double)">
            <summary>
            Adds a mitre join connecting the two reflex offset segments.
            The mitre will be beveled if it exceeds the mitre ratio limit.
            </summary>
            <param name="p">The base point</param>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
            <param name="distance">The offset distance</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddLimitedMitreJoin(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment,System.Double,System.Double)">
            <summary>
            Adds a limited mitre join connecting the two reflex offset segments.
            </summary>
            <remarks>
            A limited mitre is a mitre which is beveled at the distance
            determined by the mitre ratio limit.
            </remarks>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
            <param name="distance">The offset distance</param>
            <param name="mitreLimit">The mitre limit ratio</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddBevelJoin(NetTopologySuite.Geometries.LineSegment,NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Adds a bevel join connecting the two offset segments around a reflex corner.
            </summary>
            <param name="offset0">The first offset segment</param>
            <param name="offset1">The second offset segment</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddFillet(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Algorithm.OrientationIndex,System.Double)">
            <summary>
            Add points for a circular fillet around a reflex corner. Adds the start and end points
            </summary>
            <param name="p">Base point of curve</param>
            <param name="p0">Start point of fillet curve</param>
            <param name="p1">Endpoint of fillet curve</param>
            <param name="direction">The orientation of the fillet</param>
            <param name="radius">The radius of the fillet</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddFillet(NetTopologySuite.Geometries.Coordinate,System.Double,System.Double,NetTopologySuite.Algorithm.OrientationIndex,System.Double)">
            <summary>
            Adds points for a circular fillet arc between two specified angles.
            </summary>
            <remarks>
            The start and end point for the fillet are not added - the caller must add them if required.
            </remarks>
            <param name="p">The point around which to add the fillet points</param>
            <param name="startAngle">The start angle (in radians)</param>
            <param name="endAngle">The end angle (in radians)</param>
            <param name="direction">Is -1 for a CW angle, 1 for a CCW angle</param>
            <param name="radius">The radius of the fillet</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddCircle(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Adds a CW circle around a point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.AddSquare(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Adds a CW square around a point
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder">
            <summary>
            A RightmostEdgeFinder find the DirectedEdge in a list which has the highest coordinate,
            and which is oriented L to R at that point. (I.e. the right side is on the RHS of the edge.)
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.FindEdge(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="dirEdgeList"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtNode">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtVertex">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.CheckForRightmostCoordinate(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.GetRightmostSide(NetTopologySuite.GeometriesGraph.DirectedEdge,System.Int32)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder.GetRightmostSideOfSegment(NetTopologySuite.GeometriesGraph.DirectedEdge,System.Int32)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.SegmentMCIndex">
            <summary>
            A spatial index over a segment sequence
            using <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain"/>s.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater">
            <summary>
            Locates a subgraph inside a set of subgraphs,
            in order to determine the outside depth of the subgraph.
            The input subgraphs are assumed to have had depths
            already calculated for their edges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.#ctor(System.Collections.Generic.IList{NetTopologySuite.Operation.Buffer.BufferSubgraph})">
             <summary>
            
             </summary>
             <param name="subgraphs"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.GetDepth(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>A List of {DepthSegments} intersecting the stabbing line.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(NetTopologySuite.Geometries.Coordinate,System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.DirectedEdge},System.Collections.Generic.IList{NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment})">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the list of dirEdges.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdges"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.GeometriesGraph.DirectedEdge,System.Collections.Generic.IList{NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment})">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the input dirEdge.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdge"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment">
            <summary>
            A segment from a directed edge which has been assigned a depth value
            for its sides.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment.LeftDepth">
            <summary>
            Gets or sets the depth to the left of this segment
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment.#ctor(NetTopologySuite.Geometries.LineSegment,System.Int32)">
            <summary>
            Initializes this DepthSegments
            </summary>
            <param name="seg">A line segment</param>
            <param name="depth">A depth value</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment.CompareTo(NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment)">
            <summary>
            Defines a comparison operation on <see cref="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater.DepthSegment"/>s
            which orders them left to right.
            </summary>
            <remarks>
            Assumes the segments are normalized.
            <para/>
            The definition of ordering is:
            <list type="table">
            <item><term>-1</term><description>if DS1.seg is left of or below DS2.seg (DS1 &lt; DS2).</description></item>
            <item><term>1</term><description>if DS1.seg is right of or above DS2.seg (DS1 &gt; DS2).</description></item>
            <item><term>0</term><description>if the segments are identical</description></item>
            </list>
            Known Bugs:
            <list type="bullet">
            <item><description>The logic does not obey the <see cref="M:System.IComparable.CompareTo(System.Object)"/> contract.
            This is acceptable for the intended usage, but may cause problems if used with some
            utilities in the .Net standard library (e.g. <see cref="T:System.Collections.List.Sort()"/>.</description></item>
            </list>
            </remarks>
            <param name="other">A DepthSegment</param>
            <returns>The comparison value</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder">
            <summary>
            Finds the approximate maximum distance from a buffer curve to
            the originating geometry.
            </summary>
            <remarks><para>The approximate maximum distance is determined by testing
            all vertices in the buffer curve, as well
            as midpoints of the curve segments.
            Due to the way buffer curves are constructed, this
            should be a very close approximation.</para>
            <para>This is similar to the Discrete Oriented Hausdorff distance
            from the buffer curve to the input.</para>
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator">
            <summary>
            Validates that a given buffer curve lies an appropriate distance
            from the input generating it.
            </summary>
            <remarks>
            Useful only for round buffers (cap and join).
            Can be used for either positive or negative distances.
            <para></para>
            <para>This is a heuristic test, and may return false positive results
            (I.e. it may fail to detect an invalid result.)
            It should never return a false negative result, however
            (I.e. it should never report a valid result as invalid.)</para>
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.ErrorIndicator">
            <summary>
            Gets a geometry which indicates the location and nature of a validation failure.
            <para>
            The indicator is a line segment showing the location and size
            of the distance discrepancy.
            </para>
            </summary>
            <returns>A geometric error indicator
            or <c>null</c>, if no error was found</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.CheckMinimumDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Checks that two geometries are at least a minimum distance apart.
            </summary>
            <param name="g1">A geometry</param>
            <param name="g2">A geometry</param>
            <param name="minDist">The minimum distance the geometries should be separated by</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.CheckMaximumDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Checks that the furthest distance from the buffer curve to the input
            is less than the given maximum distance.
            </summary>
            <remarks>
            This uses the Oriented Hausdorff distance metric. It corresponds to finding
            the point on the buffer curve which is furthest from <i>some</i> point on the input.
            </remarks>
            <param name="input">A geometry</param>
            <param name="bufCurve">A geometry</param>
            <param name="maxDist">The maximum distance that a buffer result can be from the input</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator">
            <summary>
            Validates that the result of a buffer operation
            is geometrically correct, within a computed tolerance.
            </summary>
            <remarks>
            <para>This is a heuristic test, and may return false positive results
            (I.e. it may fail to detect an invalid result.)
            It should never return a false negative result, however
            (I.e. it should never report a valid result as invalid.)</para>
            <para>This test may be (much) more expensive than the original buffer computation.</para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.IsValidMessage(NetTopologySuite.Geometries.Geometry,System.Double,NetTopologySuite.Geometries.Geometry)">
             <summary>Checks whether the geometry buffer is valid, and returns an error message if not.
             </summary>
             <param name="g"></param>
             <param name="distance"></param>
             <param name="result"></param>
             <returns>An appropriate error message<br/>
             or <c>null</c>if the buffer is valid</returns>
            
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.ErrorMessage">
            <summary>
            Gets the error message
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.ErrorLocation">
            <summary>
            Gets the error location
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.ErrorIndicator">
            <summary>
            Gets a geometry which indicates the location and nature of a validation failure.
            <para>
            If the failure is due to the buffer curve being too far or too close
            to the input, the indicator is a line segment showing the location and size
            of the discrepancy.
            </para>
            </summary>
            <returns>A geometric error indicator<br/>
            or <c>null</c>, if no error was found</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder">
            <summary>
            Computes the Euclidean distance (L2 metric) from a Point to a Geometry.
            Also computes two points which are separated by the distance.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.PointPairDistance">
            <summary>
            Contains a pair of points and the distance between them.
            Provides methods to update with a new point pair with
            either maximum or minimum distance.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.PointPairDistance.Initialize(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Initializes the points, avoiding recomputing the distance.
            </summary>
            <param name="p0">The first point</param>
            <param name="p1">The second point</param>
            <param name="distance">The distance between <paramref name="p0"/> and <paramref name="p1"/></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.VariableBuffer">
            <summary>
            Creates a buffer polygon with a varying buffer distance
            at each vertex along a line.
            <para/>
            Only single lines are supported as input, since buffer widths
            generally need to be specified individually for each line.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Buffer(NetTopologySuite.Geometries.Geometry,System.Double,System.Double)">
            <summary>
            Creates a buffer polygon along a line with the buffer distance interpolated
            between a start distance and an end distance.
            </summary>
            <param name="line">The line to buffer</param>
            <param name="startDistance">The buffer width at the start of the line</param>
            <param name="endDistance">The buffer width at the end of the line</param>
            <returns>The variable-distance buffer polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Buffer(NetTopologySuite.Geometries.Geometry,System.Double,System.Double,System.Double)">
            <summary>
            Creates a buffer polygon along a line with the buffer distance interpolated
            between a start distance, a middle distance and an end distance.
            The middle distance is attained at
            the vertex at or just past the half-length of the line.
            For smooth buffering of a <see cref="T:NetTopologySuite.Geometries.LinearRing"/> (or the rings of a <see cref="T:NetTopologySuite.Geometries.Polygon"/>)
            the start distance and end distance should be equal.
            </summary>
            <param name="line">The line to buffer</param>
            <param name="startDistance">The buffer width at the start of the line</param>
            <param name="midDistance">The buffer width at the middle vertex of the line</param>
            <param name="endDistance">The buffer width at the end of the line</param>
            <returns>The variable-distance buffer polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Buffer(NetTopologySuite.Geometries.Geometry,System.Double[])">
            <summary>
            Creates a buffer polygon along a line with the distance specified
            at each vertex.
            </summary>
            <param name="line">The line to buffer</param>
            <param name="distance">The buffer distance for each vertex of the line</param>
            <returns>The variable-width buffer polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Interpolate(NetTopologySuite.Geometries.LineString,System.Double,System.Double)">
            <summary>
            Computes a list of values for the points along a line by
            interpolating between values for the start and end point.
            The interpolation is
            based on the distance of each point along the line
            relative to the total line length.
            </summary>
            <param name="line">The line to interpolate along</param>
            <param name="startValue">The start value</param>
            <param name="endValue">The end value</param>
            <returns>The array of interpolated values</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Interpolate(NetTopologySuite.Geometries.LineString,System.Double,System.Double,System.Double)">
            <summary>
            Computes a list of values for the points along a line by
            interpolating between values for the start, middle and end points.
            The interpolation is
            based on the distance of each point along the line
            relative to the total line length.
            The middle distance is attained at
            the vertex at or just past the half-length of the line.
            </summary>
            <param name="line">The line to interpolate along</param>
            <param name="startValue">The start value</param>
            <param name="midValue">The mid value</param>
            <param name="endValue">The end value</param>
            <returns>The array of interpolated values</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.#ctor(NetTopologySuite.Geometries.Geometry,System.Double[])">
            <summary>
            Creates a generator for a variable-distance line buffer.
            </summary>
            <param name="line">The linestring to buffer</param>
            <param name="distance">The buffer distance for each vertex of the line</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.GetResult">
            <summary>
            Computes the buffer polygon.
            </summary>
            <returns>A buffer polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.SegmentBuffer(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double,System.Double)">
            <summary>
            Computes a variable buffer polygon for a single segment,
            with the given endpoints and buffer distances.
            The individual segment buffers are unioned
            to form the final buffer.
            </summary>
            <param name="p0">The segment start point</param>
            <param name="p1">The segment end point</param>
            <param name="dist0">The buffer distance at the start point</param>
            <param name="dist1">The buffer distance at the end point</param>
            <returns>The segment buffer</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.Circle(NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Returns a circular polygon.
            </summary>
            <param name="center">The circle center point</param>
            <param name="radius">The radius</param>
            <returns>A polygon, or null if the radius is 0</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.AddCap(NetTopologySuite.Geometries.Coordinate,System.Double,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateList)">
            <summary>
            Adds a semi-circular cap CCW around the point <paramref name="p"/>.
            </summary>
            <param name="p">The centre point of the cap</param>
            <param name="r">The cap radius</param>
            <param name="t1">the starting point of the cap</param>
            <param name="t2">The ending point of the cap</param>
            <param name="coords">The coordinate list to add to</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.CapAngle(System.Int32)">
            <summary>
            Computes the angle for the given cap point index.
            </summary>
            <param name="index">The fillet angle index</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.CapAngleIndex(System.Double)">
            <summary>
            Computes the canonical cap point index for a given angle.
            The angle is rounded down to the next lower
            index.
            <para/>
            In order to reduce the number of points created by overlapping end caps,
            cap points are generated at the same locations around a circle.
            The index is the index of the points around the circle, 
            with 0 being the point at (1,0).
            The total number of points around the circle is 
            <c>4 * <see cref="F:NetTopologySuite.Operation.Buffer.VariableBuffer._quadrantSegs"/></c>.
            </summary>
            <param name="ang">The angle</param>
            <returns>The index for the angle.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.OuterTangent(NetTopologySuite.Geometries.Coordinate,System.Double,NetTopologySuite.Geometries.Coordinate,System.Double)">
            <summary>
            Computes the two circumference points defining the outer tangent line
            between two circles.
            <para/>
            For the algorithm see <a href='https://en.wikipedia.org/wiki/Tangent_lines_to_circles#Outer_tangent'>Wikipedia</a>.
            </summary>
            <param name="c1">The centre of circle 1</param>
            <param name="r1">The radius of circle 1</param>
            <param name="c2">The centre of circle 2</param>
            <param name="r2">The radius of circle 2</param>
            <returns>The outer tangent line segment, or <c>null</c> if none exists</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.VariableBuffer.SnapTrig(System.Double)">
            <summary>
            Snap trig values to integer values for better consistency.
            </summary>
            <param name="x">The result of a trigonometric function</param>
            <returns><paramref name="x"/> snapped to the integer interval</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter">
            <summary>
            A ConnectedElementPointFilter extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list. The elements of the list are
            <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation"/>s.
            Empty geometries do not provide a location item.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.GetLocations(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns a list containing a point from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned. The elements of the list
            are <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.#ctor(System.Collections.Generic.IList{NetTopologySuite.Operation.Distance.GeometryLocation})">
             <summary>
            
             </summary>
             <param name="locations"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.ConnectedElementPointFilter">
            <summary>
            Extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.GetCoordinates(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Returns a list containing a Coordinate from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.#ctor(System.Collections.Generic.IList{NetTopologySuite.Geometries.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.DistanceOp">
            <summary>
            Computes the distance and
            closest points between two <c>Geometry</c>s.
            The distance computation finds a pair of points in the input geometries
            which have minimum distance between them.  These points may
            not be vertices of the geometries, but may lie in the interior of
            a line segment. In this case the coordinate computed is a close
            approximation to the exact point.
            <para/>
            Empty geometry collection components are ignored.
            <para/>
            The algorithms used are straightforward O(n^2)
            comparisons.  This worst-case performance could be improved on
            by using Voronoi techniques.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Compute the distance between the closest points of two geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.IsWithinDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Test whether two geometries lie within a given distance of each other.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.NearestPoints(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Compute the the closest points of two geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The closest points in the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Operation.Distance.DistanceOp" />  that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Operation.Distance.DistanceOp" /> that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
            <param name="terminateDistance">The distance on which to terminate the search.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.Distance">
            <summary>
            Report the distance between the closest points on the input geometries.
            </summary>
            <returns>The distance between the geometries<br/>
            or <c>0</c> if either input geometry is empty.</returns>
            <exception cref="T:System.ApplicationException"> if either input geometry is null</exception>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.NearestPoints">
            <summary>
            Report the coordinates of the nearest points in the input geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <c>Coordinate</c>s of the nearest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.NearestLocations">
            <summary>
            Report the locations of the nearest points in the input geometries.
            The locations are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation"/>s for the nearest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.UpdateMinDistance(System.Double)">
             <summary>
            
             </summary>
             <param name="dist"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.UpdateMinDistance(NetTopologySuite.Operation.Distance.GeometryLocation[],System.Boolean)">
             <summary>
            
             </summary>
             <param name="locGeom"></param>
             <param name="flip"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistance">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeContainmentDistance">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeFacetDistance">
            <summary>
            Computes distance between facets (lines and points) of input geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistanceLines(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="lines0"></param>
             <param name="lines1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistancePoints(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="points0"></param>
             <param name="points1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistanceLinesPoints(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="lines"></param>
             <param name="points"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistance(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.LineString,NetTopologySuite.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="line0"></param>
             <param name="line1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp.ComputeMinDistance(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Point,NetTopologySuite.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="line"></param>
             <param name="pt"></param>
             <param name="locGeom"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.FacetSequence">
            <summary>
            Represents a sequence of facets (points or line segments) of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            specified by a subsequence of a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Creates a new sequence of facets based on a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>
            contained in the given <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">The geometry containing the facets.</param>
            <param name="pts">The sequence containing the facet points.</param>
            <param name="start">The index of the start point.</param>
            <param name="end">The index of the end point.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.#ctor(NetTopologySuite.Geometries.CoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Creates a new sequence of facets based on a <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/>.
            </summary>
            <param name="pts">The sequence containing facet points.</param>
            <param name="start">The index of the start point</param>
            <param name="end">The index of the end point + 1</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.#ctor(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Creates a new sequence for a single point from a CoordinateSequence.
            </summary>
            <param name="pts">The sequence containing the facet point.</param>
            <param name="index">the index of the point</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.FacetSequence.Envelope">
            <summary>
            Gets the envelope of this facet sequence
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.FacetSequence.Count">
            <summary>
            Gets the number of coordinates in this facet sequence
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.GetCoordinate(System.Int32)">
            <summary>
            Gets the coordinate at the given index
            </summary>
            <param name="index">The index</param>
            <returns>The coordinate at the given index</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.FacetSequence.IsPoint">
            <summary>
            Tests if this facet sequence consists of only one point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.Distance(NetTopologySuite.Operation.Distance.FacetSequence)">
            <summary>
            Computes the distance between this and another
            <see cref="T:NetTopologySuite.Operation.Distance.FacetSequence"/>.
            </summary>
            <param name="facetSeq">The sequence to compute the distance to.</param>
            <returns>The minimum distance between the sequences.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.NearestLocations(NetTopologySuite.Operation.Distance.FacetSequence)">
            <summary>
            Computes the locations of the nearest points between this sequence
            and another sequence.
            The locations are presented in the same order as the input sequences.
            </summary>
            <returns>A pair of <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation"/>s for the nearest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequence.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder">
            <summary>
            Utility class to build facet sequencs STRtrees-
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder.BuildSTRtree(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder.ComputeFacetSequences(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates facet sequences from a given geometry
            </summary>
            <param name="g">The geometry</param>
            <returns>A list of <see cref="T:NetTopologySuite.Operation.Distance.FacetSequence"/>s</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.GeometryLocation">
            <summary>
            Represents the location of a point on a Geometry.
            Maintains both the actual point location
            (which may not be exact, if the point is not a vertex)
            as well as information about the component
            and segment index where the point occurs.
            Locations inside area Geometrys will not have an associated segment index,
            so in this case the segment index will have the sentinel value of <see cref="F:NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea"/>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea">
            <summary>
            A special value of segmentIndex used for locations inside area geometries.
            These locations are not located on a segment,
            and thus do not have an associated segment index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.GeometryLocation.#ctor(NetTopologySuite.Geometries.Geometry,System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a GeometryLocation specifying a point on a point, as well as the
            segment that the point is on (or <see cref="F:NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea"/> if the point is not on a segment).
            </summary>
            <param name="component">The component of the geometry containing the point</param>
            <param name="segIndex">The segment index of the location, or <see cref="F:NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea"/></param>
            <param name="pt">The coordinate of the location</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.GeometryLocation.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a GeometryLocation specifying a point inside an area point.
            </summary>
            <param name="component">The component of the geometry containing the point</param>
            <param name="pt">The coordinate of the location</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation.GeometryComponent">
            <summary>
            Returns the geometry component on (or in) which this location occurs.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation.SegmentIndex">
            <summary>
            Returns the segment index for this location. If the location is inside an
            area, the index will have the value <see cref="F:NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation.Coordinate">
            <summary>
            Returns the <see cref="P:NetTopologySuite.Operation.Distance.GeometryLocation.Coordinate"/> of this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation.IsInsideArea">
            <summary>
            Tests whether this location represents a point inside an area geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.GeometryLocation.ToString">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.IndexedFacetDistance">
            <summary>
            Computes the distance between the facets (segments and vertices)
            of two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s
            using a Branch-and-Bound algorithm.
            The Branch-and-Bound algorithm operates over a
            traversal of R-trees built
            on the target and the query geometries.
            <para>
            This approach provides the following benefits:
            <list type="bullet">
            <item><description>
            Performance is dramatically improved due to the use of the
            R-tree index
            and the pruning due to the Branch-and-Bound approach
            </description></item><item><description>
            The spatial index on the target geometry is cached
            which allow reuse in an repeated query situation.</description></item>
            </list>
            Using this technique is usually much more performant
            than using the brute-force <see cref="M:NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)"/>
            when one or both input geometries are large,
            or when evaluating many distance computations against
            a single geometry.
            </para>
            </summary>
            <remarks>This class is thread-safe.</remarks>
            <author>
            Martin Davis
            </author>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the distance between facets of two geometries.
            </summary>
            <remarks>
            For geometries with many segments or points,
            this can be faster than using a simple distance
            algorithm.
            </remarks>
            <param name="g1">A geometry</param>
            <param name="g2">A geometry</param>
            <returns>The distance between the two geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.IsWithinDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Tests whether the facets of two geometries lie within a given distance.
            </summary>
            <param name="g1">A geometry</param>
            <param name="g2">A geometry</param>
            <param name="distance">The distance limit</param>
            <returns><c>true</c> if two facets lie with the given distance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.NearestPoints(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the nearest points of the facets of two geometries.
            </summary>
            <param name="g1">A geometry</param>
            <param name="g2">A geometry</param>
            <returns>The nearest points on the facets of the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new distance-finding instance for a given target <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <remarks>
            <para>
            Distances will be computed to all facets of the input geometry.
            The facets of the geometry are the discrete segments and points
            contained in its components.  </para>
            <para>
            In the case of <see cref="T:NetTopologySuite.Geometries.ILineal"/> and <see cref="T:NetTopologySuite.Geometries.IPuntal"/> inputs,
            this is equivalent to computing the conventional distance.
            </para><para>
            In the case of <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> inputs, this is equivalent
            to computing the distance to the polygon boundaries.
            </para>
            </remarks>
            <param name="g1">A Geometry, which may be of any type.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.Distance(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the distance from the base geometry to the given geometry.
            </summary>
            <param name="g">The geometry to compute the distance to.</param>
            <returns>The computed distance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.NearestLocations(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the nearest locations on the base geometry
            and the given geometry.
            </summary>
            <param name="g">Ihe geometry to compute the nearest location to.</param>
            <returns>The nearest locations.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.NearestPoints(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the nearest locations on the target geometry
            and the given geometry.
            </summary>
            <param name="g">Ihe geometry to compute the nearest point to.</param>
            <returns>The nearest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.IndexedFacetDistance.IsWithinDistance(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Tests whether the base geometry lies within
            a specified distance of the given geometry.
            </summary>
            <param name="g">The geometry to test</param>
            <param name="maxDistance">The maximum distance to test</param>
            <returns><c>true</c> if the geometry lies with the specified distance</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence">
            <summary>
            A <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> wrapper which
            projects 3D coordinates into one of the
            three Cartesian axis planes,
            using the standard orthonormal projection
            (i.e. simply selecting the appropriate ordinates into the XY ordinates).
            The projected data is represented as 2D coordinates.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.ProjectToXY(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a wrapper projecting to the XY plane.
            </summary>
            <param name="seq">The sequence to be projected</param>
            <returns>A sequence which projects coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.ProjectToXZ(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a wrapper projecting to the XZ plane.
            </summary>
            <param name="seq">The sequence to be projected</param>
            <returns>A sequence which projects coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.ProjectToYZ(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Creates a wrapper projecting to the YZ plane.
            </summary>
            <param name="seq">The sequence to be projected</param>
            <returns>A sequence which projects coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.CreateCoordinate">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Operation.Distance3D.Distance3DOp">
            <summary>
            Find two points on two  3D <see cref="T:NetTopologySuite.Geometries.Geometry"/>s which lie within a given distance,
            or else are the nearest points on the geometries (in which case this also
            provides the distance between the geometries).
            <para/>
            3D geometries have vertex Z ordinates defined.
            3D <see cref="T:NetTopologySuite.Geometries.Polygon"/>s are assumed to lie in a single plane (which is enforced if not actually the case).
            3D <see cref="T:NetTopologySuite.Geometries.LineString"/>s and <see cref="T:NetTopologySuite.Geometries.Point"/>s may have any configuration.
            <para/>
            The distance computation also finds a pair of points in the input geometries
            which have the minimum distance between them. If a point lies in the interior
            of a line segment, the coordinate computed is a close approximation to the
            exact point.
            <para/>
            The algorithms used are straightforward O(n^2) comparisons. This worst-case
            performance could be improved on by using Voronoi techniques or spatial
            indexes.
            </summary>
            <version>1.13</version>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.Distance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Compute the distance between the nearest points of two geometries.
            </summary>
            <param name="g0">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <param name="g1">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <returns>The distance between the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.IsWithinDistance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Test whether two geometries lie within a given distance of each other.
            </summary>
            <param name="g0">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <param name="g1">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <param name="distance">The distance to test</param>
            <returns><c>true</c> if <c>g0.distance(g1) &lt;= <paramref name="distance"/></c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.NearestPoints(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Compute the the nearest points of two geometries. The points are
            presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <param name="g1">A <see cref="T:NetTopologySuite.Geometries.Geometry">geometry</see></param>
            <returns>The nearest points in the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs a DistanceOp that computes the distance and nearest points
            between the two specified geometries.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Constructs a DistanceOp that computes the distance and nearest points
            between the two specified geometries.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
            <param name="terminateDistance">The distance on which to terminate the search</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.Distance">
            <summary>
            Report the distance between the nearest points on the input geometries.
            </summary>
            <returns>The distance between the geometries<br/>
            or <c>0</c> if either input geometry is empty</returns>
            <exception cref="T:System.ArgumentException">Thrown if either input geometry is null.</exception>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.NearestPoints">
            <summary>
            Report the coordinates of the nearest points in the input geometries. The
            points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s of the nearest points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.NearestLocations">
            <summary>
            Gets the locations of the nearest points in the input geometries. The
            locations are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation"/>s for the nearest points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.MostPolygonalIndex">
            <summary>
            Finds the index of the "most polygonal" input geometry.
            This optimizes the computation of the best-fit plane,
            since it is cached only for the left-hand geometry.
            </summary>
            <returns>The index of the most polygonal geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.PolyPlane(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Convenience method to create a Plane3DPolygon
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.ComputeMinDistancePolygonPolygon(NetTopologySuite.Operation.Distance3D.PlanarPolygon3D,NetTopologySuite.Geometries.Polygon,System.Boolean)">
            <summary>
            Computes distance between two polygons.
            </summary>
            <remarks>
            To compute the distance, compute the distance
            between the rings of one polygon and the other polygon,
            and vice-versa.
            If the polygons intersect, then at least one ring must
            intersect the other polygon.
            Note that it is NOT sufficient to test only the shell rings.
            A counter-example is a "figure-8" polygon A
            and a simple polygon B at right angles to A, with the ring of B
            passing through the holes of A.
            The polygons intersect,
            but A's shell does not intersect B, and B's shell does not intersect A.</remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.ComputeMinDistancePolygonRings(NetTopologySuite.Operation.Distance3D.PlanarPolygon3D,NetTopologySuite.Geometries.Polygon,System.Boolean)">
            <summary>Compute distance between a polygon and the rings of another.</summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.Distance3DOp.SegmentPoint(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double,System.Double)">
            <summary>
            Computes a point at a distance along a segment
            specified by two relatively proportional values.
            The fractional distance along the segment is d0/(d0+d1).
            </summary>
            <param name="p0">Start point of the segment.</param>
            <param name="p1">End point of the segment</param>
            <param name="d0">Proportional distance from start point to computed point</param>
            <param name="d1">Proportional distance from computed point to end point</param>
            <returns>The computed point</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D">
            <summary>
            Models a polygon lying in a plane in 3-dimensional Cartesian space.
            The polygon representation is supplied
            by a <see cref="P:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Polygon"/>,
            containing coordinates with XYZ ordinates.
            3D polygons are assumed to lie in a single plane.
            The plane best fitting the polygon coordinates is
            computed and is represented by a <see cref="T:NetTopologySuite.Mathematics.Plane3D"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.#ctor(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Creates an instance of this class using the provided <see cref="P:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Polygon"/>.
            </summary>
            <param name="poly">The polygon</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.FindBestFitPlane(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Finds a best-fit plane for the polygon,
            by sampling a few points from the exterior ring.
            <para/>
            The algorithm used is Newell's algorithm:
            <list type="bullet">
            <item><description>a base point for the plane is determined from the average of all vertices</description></item>
            <item><description>the normal vector is determined by computing the area of the projections on each of the axis planes</description></item>
            </list>
            </summary>
            <param name="poly">The polygon to determine the plane for</param>
            <returns>The best-fit plane</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.AverageNormal(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes an average normal vector from a list of polygon coordinates.
            Uses Newell's method, which is based
            on the fact that the vector with components
            equal to the areas of the projection of the polygon onto
             the Cartesian axis planes is normal.
            </summary>
            <param name="seq">The sequence of coordinates for the polygon</param>
            <returns>A normal vector</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.AveragePoint(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Computes a point which is the average of all coordinates
            in a sequence.<br/>
            If the sequence lies in a single plane,
            the computed point also lies in the plane.
            </summary>
            <param name="seq">A coordinate sequence</param>
            <returns>A Coordinate with averaged ordinates </returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Plane">
            <summary>
            Gets a value indicating the plane
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Polygon">
            <summary>
            Gets a value indicating the polygon
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Intersects(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Checks if <paramref name="intPt"/> intersects with this <see cref="T:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D"/>.
            </summary>
            <param name="intPt">The point to check</param>
            <returns><c>true</c> if <c>intPt</c> intersects this <c>PlanarPolygon3d</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Intersects(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.LineString)">
            <summary>
            Checks if the point <paramref name="pt"/> intersects with <paramref name="ring"/> when projected to this instance's facing plane
            </summary>
            <param name="pt">A point</param>
            <param name="ring">A ring</param>
            <returns><c>true</c> if point and linestring intersect</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.GeometryGraphOperation">
            <summary>
            The base class for operations that require <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph"/>s.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.GeometryGraphOperation.lineIntersector">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.GeometryGraphOperation.resultPrecisionModel">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.GeometryGraphOperation.arg">
            <summary>
            The operation args into an array so they can be accessed by index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.GeometryGraphOperation.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.GeometryGraphOperation.#ctor(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.GeometryGraphOperation.GetArgGeometry(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Operation.GeometryGraphOperation.ComputationPrecision">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.IsSimpleOp">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Geometries.Geometry"/> is simple.
            In general, the SFS specification of simplicity
            follows the rule:
            <list type="bullet">
            <item><description>
            A Geometry is simple if and only if the only self-intersections are at boundary points.
            </description></item>
            </list>
            </summary>
            <remarks>
            Simplicity is defined for each <see cref="T:NetTopologySuite.Geometries.Geometry"/>} subclass as follows:
            <list type="bullet">
            <item><description>Valid <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometries are simple by definition, so
            <c>IsSimple</c> trivially returns true.<br/>
            (Note: this means that <tt>IsSimple</tt> cannot be used to test
            for (invalid) self-intersections in <tt>Polygon</tt>s.
            In order to check if a <tt>Polygonal</tt> geometry has self-intersections,
            use <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid" />).</description></item>
            <item><description><b><see cref="T:NetTopologySuite.Geometries.ILineal"/></b> geometries are simple if and only if they do <i>not</i> self-intersect at interior points
            (i.e. points other than boundary points).
            This is equivalent to saying that no two linear components satisfy the SFS <see cref="M:NetTopologySuite.Geometries.Geometry.Touches(NetTopologySuite.Geometries.Geometry)"/>
            predicate.</description></item>
            <item><description><b>Zero-dimensional (<see cref="T:NetTopologySuite.Geometries.IPuntal"/>)</b> geometries are simple if and only if they have no
            repeated points.</description></item>
            <item><description><b>Empty</b> <see cref="T:NetTopologySuite.Geometries.Geometry"/>s are <i>always</i> simple by definition.</description></item>
            </list>
            For <see cref="T:NetTopologySuite.Geometries.ILineal"/> geometries the evaluation of simplicity
            can be customized by supplying a <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            to define how boundary points are determined.
            The default is the SFS-standard <see cref="T:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule"/>.
            Note that under the <tt>Mod-2</tt> rule, closed <tt>LineString</tt>s (rings)
            will never satisfy the <tt>touches</tt> predicate at their endpoints, since these are
            interior points, not boundary points.
            If it is required to test whether a set of <c>LineString</c>s touch
            only at their endpoints, use <c>IsSimpleOp</c> with <see cref="F:NetTopologySuite.Algorithm.BoundaryNodeRules.EndpointBoundaryRule"/>.
            For example, this can be used to validate that a set of lines form a topologically valid
            linear network.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
            </summary>
            <param name="geom">The geometry to test</param>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Creates a simplicity checker using a given <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            </summary>
            <param name="geom">The geometry to test</param>
            <param name="boundaryNodeRule">The rule to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.IsSimple">
            <summary>
            Tests whether the geometry is simple.
            </summary>
            <returns>true if the geometry is simple</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.IsSimpleOp.NonSimpleLocation">
            <summary>
            Gets a coordinate for the location where the geometry fails to be simple.
            (i.e. where it has a non-boundary self-intersection).
            <see cref="M:NetTopologySuite.Operation.IsSimpleOp.IsSimple"/> must be called before this location is accessed
            </summary>
            <returns> a coordinate for the location of the non-boundary self-intersection
            or <c>null</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.IsSimplePolygonal(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes simplicity for polygonal geometries.
            Polygonal geometries are simple if and only if
            all of their component rings are simple.
            </summary>
            <param name="geom">A Polygonal geometry</param>
            <returns><c>true</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.IsSimpleGeometryCollection(NetTopologySuite.Geometries.Geometry)">
            <summary>Semantics for GeometryCollection is
            simple if all components are simple.</summary>
            <param name="geom">A GeometryCollection</param>
            <returns><c>true</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.HasNonEndpointIntersection(NetTopologySuite.GeometriesGraph.GeometryGraph)">
            <summary>
            For all edges, check if there are any intersections which are NOT at an endpoint.
            The Geometry is not simple if there are intersections not at endpoints.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.IsSimpleOp.EndpointInfo">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.EndpointInfo.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="pt">The endpoint</param>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.HasClosedEndpointIntersection(NetTopologySuite.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that no edge intersection is the endpoint of a closed line.
            This ensures that closed lines are not touched at their endpoint,
            which is an interior point according to the Mod-2 rule
            To check this we compute the degree of each endpoint.
            The degree of endpoints of closed lines
            must be exactly 2.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp.AddEndpoint(System.Collections.Generic.IDictionary{NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Operation.IsSimpleOp.EndpointInfo},NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Add an endpoint to the map, creating an entry for it if none exists.
            </summary>
            <param name="endPoints"></param>
            <param name="p"></param>
            <param name="isClosed"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.EdgeString">
            <summary>
            A sequence of <c>LineMergeDirectedEdge</c>s forming one of the lines that will
            be output by the line-merging process.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs an EdgeString with the given factory used to convert this EdgeString
            to a LineString.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString.Add(NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge)">
            <summary>
            Adds a directed edge which is known to form part of this line.
            </summary>
            <param name="directedEdge"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.EdgeString.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString.ToLineString">
            <summary>
            Converts this EdgeString into a LineString.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge">
            <summary>
            A <c>com.vividsolutions.jts.planargraph.DirectedEdge</c> of a <c>LineMergeGraph</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge.#ctor(NetTopologySuite.Planargraph.Node,NetTopologySuite.Planargraph.Node,NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Constructs a LineMergeDirectedEdge connecting the <c>from</c> node to the <c>to</c> node.
            </summary>
            <param name="from"/>
            <param name="to"/>
            <param name="directionPt">
            specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge.Next">
            <summary>
            Returns the directed edge that starts at this directed edge's end point, or null
            if there are zero or multiple directed edges starting there.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeEdge">
            <summary>
            An edge of a <c>LineMergeGraph</c>. The <c>marked</c> field indicates
            whether this Edge has been logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeEdge.#ctor(NetTopologySuite.Geometries.LineString)">
            <summary>
            Constructs a LineMergeEdge with vertices given by the specified LineString.
            </summary>
            <param name="line"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.LineMergeEdge.Line">
            <summary>
            Returns the LineString specifying the vertices of this edge.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeGraph">
            <summary>
            A planar graph of edges that is analyzed to sew the edges together. The
            <c>marked</c> flag on <see cref="T:NetTopologySuite.Planargraph.Edge"/>s
            and <see cref="T:NetTopologySuite.Planargraph.Node"/>s indicates whether they have been
            logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeGraph.AddEdge(NetTopologySuite.Geometries.LineString)">
            <summary>
            Adds an Edge, DirectedEdges, and Nodes for the given LineString representation
            of an edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeGraph.GetNode(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coordinate"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMerger">
            <summary>
            Sews together a set of fully noded LineStrings.
            </summary>
            <remarks>
            <para> Sewing stops at nodes of degree 1
            or 3 or more -- the exception is an isolated loop, which only has degree-2 nodes,
            in which case a node is simply chosen as a starting point. The direction of each
            merged LineString will be that of the majority of the LineStrings from which it
            was derived.</para>
            <para>
            Any dimension of Geometry is handled -- the constituent linework is extracted to
            form the edges. The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The LineMerger will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.</para>
            <para>
            <b>NOTE:</b>once merging has been performed, no more</para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.#ctor(NetTopologySuite.Operation.Linemerge.LineMerger)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.Filter(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="component"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds a Geometry to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Adds a collection of Geometries to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometries"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.Add(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.Merge">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringsForObviousStartNodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringsForIsolatedLoops">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringsForUnprocessedNodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringsForNonDegree2Nodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringsStartingAt(NetTopologySuite.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.BuildEdgeStringStartingWith(NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger.GetMergedLineStrings">
            <summary>
            Returns the LineStrings built by the merging process.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineSequencer">
            <summary>
            <para>
            Builds a sequence from a set of <see cref="T:NetTopologySuite.Geometries.LineString" />s,
            so that they are ordered end to end.
            A sequence is a complete non-repeating list of the linear
            components of the input.  Each linestring is oriented
            so that identical endpoints are adjacent in the list.
            </para>
            <para>
            The input linestrings may form one or more connected sets.
            The input linestrings should be correctly noded, or the results may
            not be what is expected.
            The output of this method is a single <see cref="T:NetTopologySuite.Geometries.MultiLineString" />,
            containing the ordered linestrings in the sequence.
            </para>
            <para>
            The sequencing employs the classic 'Eulerian path' graph algorithm.
            Since Eulerian paths are not uniquely determined, further rules are used to
            make the computed sequence preserve as much as possible of the input ordering.
            Within a connected subset of lines, the ordering rules are:
             - If there is degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If there is a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            </para>
            <para>
            Not all arrangements of lines can be sequenced.
            For a connected set of edges in a graph,
            Euler's Theorem states that there is a sequence containing each edge once
            if and only if there are no more than 2 nodes of odd degree.
            If it is not possible to find a sequence, the <see cref="M:NetTopologySuite.Operation.Linemerge.LineSequencer.IsSequenceable" />
            property will return <c>false</c>.
            </para>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.IsSequenced(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Geometries.Geometry" /> is sequenced correctly.
            <see cref="T:NetTopologySuite.Geometries.LineString" />s are trivially sequenced.
            <see cref="T:NetTopologySuite.Geometries.MultiLineString" />s are checked for correct sequencing.
            Otherwise, <c>IsSequenced</c> is defined
            to be <c>true</c> for geometries that are not lineal.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry" /> to test.</param>
            <returns>
            <c>true</c> if the <see cref="T:NetTopologySuite.Geometries.Geometry" /> is sequenced or is not lineal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Adds a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:NetTopologySuite.Geometries.Geometry" />s to be sequenced.
            May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be extracted.
            </summary>
            <param name="geometries">A <see cref="T:System.Collections.Generic.IEnumerable`1" /> of geometries to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds a <see cref="T:NetTopologySuite.Geometries.Geometry" /> to be sequenced.
            May be called multiple times.
            Any dimension of <see cref="T:NetTopologySuite.Geometries.Geometry" /> may be added;
            the constituent linework will be extracted.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl">
            <summary>
            A private implementation for <see cref="T:NetTopologySuite.Geometries.IGeometryComponentFilter" />
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl.#ctor(NetTopologySuite.Operation.Linemerge.LineSequencer)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl"/> class.
            </summary>
            <param name="sequencer">The sequencer.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Performs an operation with or on <paramref name="component" />
            </summary>
            <param name="component">
            A <see cref="T:NetTopologySuite.Geometries.Geometry" /> to which the filter is applied.
            </param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.IsSequenceable">
            <summary>
            Tests whether the arrangement of linestrings has a valid sequence.
            </summary>
            <returns><c>true</c> if a valid sequence exists.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.GetSequencedLineStrings">
            <summary>
            Returns the <see cref="T:NetTopologySuite.Geometries.LineString" /> or <see cref="T:NetTopologySuite.Geometries.MultiLineString" />
            built by the sequencing process, if one exists.
            </summary>
            <returns>The sequenced linestrings,
            or <c>null</c> if a valid sequence does not exist.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.HasSequence(NetTopologySuite.Planargraph.Subgraph)">
            <summary>
            Tests whether a complete unique path exists in a graph
            using Euler's Theorem.
            </summary>
            <param name="graph">The <see cref="T:NetTopologySuite.Planargraph.Subgraph" /> containing the edges.</param>
            <returns><c>true</c> if a sequence exists.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.FindUnvisitedBestOrientedDE(NetTopologySuite.Planargraph.Node)">
            <summary>
            Finds an <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" /> for an unvisited edge (if any),
            choosing the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" /> which preserves orientation, if possible.
            </summary>
            <param name="node">The <see cref="T:NetTopologySuite.Planargraph.Node" /> to examine.</param>
            <returns>
            The <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" /> found,
            or <c>null</c> if none were unvisited.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.Orient(System.Collections.Generic.LinkedList{NetTopologySuite.Planargraph.DirectedEdge})">
            <summary>
            Computes a version of the sequence which is optimally
            oriented relative to the underlying geometry.
            <para>
            Heuristics used are:
             - If the path has a degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If the path has a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            (NOTE: in this case could orient the sequence according to the majority of the
            linestring orientations).
            </para>
            </summary>
            <param name="seq">A <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s.</param>
            <returns>
            A <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s oriented appropriately.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.Reverse(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge})">
            <summary>
            Reverse the sequence.
            This requires reversing the order of the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s,
            and flipping each <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" /> as well.
            </summary>
            <param name="seq">
            A enumeration of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s,
            in sequential order.
            </param>
            <returns>The reversed sequence.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer.BuildSequencedGeometry(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge}})">
            <summary>
            Builds a geometry (<see cref="T:NetTopologySuite.Geometries.LineString" /> or <see cref="T:NetTopologySuite.Geometries.MultiLineString" />)
            representing the sequence.
            </summary>
            <param name="sequences">
            An enumeration of  <see cref="T:System.Collections.Generic.IList`1" />s of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s
            with <see cref="T:NetTopologySuite.Operation.Linemerge.LineMergeEdge" />s as their parent edges.
            </param>
            <returns>
            The sequenced geometry, or <c>null</c> if no sequence exists.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.EdgeSetNoder">
            <summary>
            Nodes a set of edges.
            Takes one or more sets of edges and constructs a
            new set of edges consisting of all the split edges created by
            noding the input edges together.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.EdgeSetNoder.#ctor(NetTopologySuite.Algorithm.LineIntersector)">
             <summary>
            
             </summary>
             <param name="li"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.EdgeSetNoder.AddEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Overlay.EdgeSetNoder.NodedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.LineBuilder">
            <summary>
            Forms NTS LineStrings out of a the graph of <c>DirectedEdge</c>s
            created by an <c>OverlayOp</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.#ctor(NetTopologySuite.Operation.Overlay.OverlayOp,NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Algorithm.PointLocator)">
             <summary>
            
             </summary>
             <param name="op"></param>
             <param name="geometryFactory"></param>
             <param name="ptLocator"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.Build(NetTopologySuite.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
             <returns>
             A list of the LineStrings in the result of the specified overlay operation.
             </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.FindCoveredLineEdges">
            <summary>
            Find and mark L edges which are "covered" by the result area (if any).
            L edges at nodes which also have A edges can be checked by checking
            their depth at that node.
            L edges at nodes which do not have A edges can be checked by doing a
            point-in-polygon test with the previously computed result areas.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.CollectLines(NetTopologySuite.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.CollectLineEdge(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.Operation.Overlay.SpatialFunction,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="opCode"></param>
             <param name="edges"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.CollectBoundaryTouchEdge(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.Operation.Overlay.SpatialFunction,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Edge})">
            <summary>
            Collect edges from Area inputs which should be in the result but
            which have not been included in a result area.
            This happens ONLY:
            during an intersection when the boundaries of two
            areas touch in a line segment
            OR as a result of a dimensional collapse.
            </summary>
            <param name="de"></param>
            <param name="opCode"></param>
            <param name="edges"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.BuildLines(NetTopologySuite.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.LabelIsolatedLines(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edgesList"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder.LabelIsolatedLine(NetTopologySuite.GeometriesGraph.Edge,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.MaximalEdgeRing">
            <summary>
            A ring of edges which may contain nodes of degree > 2.
            A MaximalEdgeRing may represent two different spatial entities:
            a single polygon possibly containing inversions (if the ring is oriented CW)
            a single hole possibly containing exversions (if the ring is oriented CCW)
            If the MaximalEdgeRing represents a polygon,
            the interior of the polygon is strongly connected.
            These are the form of rings used to define polygons under some spatial data models.
            However, under the OGC SFS model, MinimalEdgeRings are required.
            A MaximalEdgeRing can be converted to a list of MinimalEdgeRings using the
            <c>BuildMinimalRings()</c> method.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing.#ctor(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing.GetNext(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing.SetEdgeRing(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing.LinkDirectedEdgesForMinimalEdgeRings">
            <summary>
            For all nodes in this EdgeRing,
            link the DirectedEdges at the node to form minimalEdgeRings
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing.BuildMinimalRings">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.MinimalEdgeRing">
            <summary>
            A ring of edges with the property that no node
            has degree greater than 2.  These are the form of rings required
            to represent polygons under the OGC SFS spatial data model.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MinimalEdgeRing.#ctor(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MinimalEdgeRing.GetNext(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MinimalEdgeRing.SetEdgeRing(NetTopologySuite.GeometriesGraph.DirectedEdge,NetTopologySuite.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.OverlayNodeFactory">
            <summary>
            Creates nodes for use in the <c>PlanarGraph</c>s constructed during
            overlay operations.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayNodeFactory.CreateNode(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.SpatialFunction">
            <summary>
            The spatial functions supported by this class.
            These operations implement various bool combinations of the resultants of the overlay.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection">
            <summary>
            The code for the Intersection overlay operation
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union">
            <summary>
            The code for the Union overlay operation
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference">
            <summary>
            The code for the Difference overlay operation
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference">
            <summary>
            The code for the Symmetric Difference overlay operation
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.OverlayOp">
            <summary>
            Computes the geometric overlay of two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.  The overlay
            can be used to determine any bool combination of the geometries.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Overlay.OverlayOp.NodingValidatorDisabled">
            <summary>
            Disable <see cref="T:NetTopologySuite.GeometriesGraph.EdgeNodingValidator"/>
            when an intersection is made (<see cref="M:NetTopologySuite.Operation.Overlay.OverlayOp.ComputeOverlay(NetTopologySuite.Operation.Overlay.SpatialFunction)"/>),
            so performances are dramatically improved but failures are not managed.
            </summary>
            <remarks>
            Use ay your own risk!
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Computes an overlay operation
            for the given geometry arguments.
            </summary>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="opCode">The code for the desired overlay operation</param>
            <returns>The result of the overlay operation</returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown if a robustness problem is encountered.</exception>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.IsResultOfOp(NetTopologySuite.GeometriesGraph.Label,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Tests whether a point with a given topological <see cref="T:NetTopologySuite.GeometriesGraph.Label"/>
            relative to two geometries is contained in
            the result of overlaying the geometries using
            a given overlay operation.
            <para/>
            The method handles arguments of <see cref="F:NetTopologySuite.Geometries.Location.Null"/> correctly
            </summary>
            <param name="label">The topological label of the point</param>
            <param name="overlayOpCode">The code for the overlay operation to test</param>
            <returns><c>true</c> if the label locations correspond to the overlayOpCode</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.IsResultOfOp(NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Tests whether a point with given <see cref="T:NetTopologySuite.Geometries.Location"/>s
            relative to two geometries is contained in
            the result of overlaying the geometries using
            a given overlay operation.
            <para/>
            The method handles arguments of <see cref="F:NetTopologySuite.Geometries.Location.Null"/> correctly
            </summary>
            <param name="loc0">the code for the location in the first geometry </param>
            <param name="loc1">the code for the location in the second geometry</param>
            <param name="overlayOpCode">the code for the overlay operation to test</param>
            <returns><c>true</c> if the locations correspond to the overlayOpCode.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs an instance to compute a single overlay operation
            for the given geometries.
            </summary>
            <param name="g0">The first geometry argument</param>
            <param name="g1">The second geometry argument</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.GetResultGeometry(NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Gets the result of the overlay for a given overlay operation.
            <para/>
            Note: this method can be called once only.
            </summary>
            <param name="overlayOpCode">The code of the overlay operation to perform</param>
            <returns>The computed result geometry</returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown if a robustness problem is encountered</exception>
        </member>
        <member name="P:NetTopologySuite.Operation.Overlay.OverlayOp.Graph">
            <summary>
            Gets the graph constructed to compute the overlay.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.InsertUniqueEdge(NetTopologySuite.GeometriesGraph.Edge)">
            <summary>
            Insert an edge from one of the noded input graphs.
            Checks edges that are inserted to see if an
            identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
            <param name="e">The edge to insert</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.ComputeLabelsFromDepths">
            <summary>
            Update the labels for edges according to their depths.
            For each edge, the depths are first normalized.
            Then, if the depths for the edge are equal,
            this edge must have collapsed into a line edge.
            If the depths are not equal, update the label
            with the locations corresponding to the depths
            (i.e. a depth of 0 corresponds to a Location of Exterior,
            a depth of 1 corresponds to Interior)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.ReplaceCollapsedEdges">
            <summary>
            If edges which have undergone dimensional collapse are found,
            replace them with a new edge which is a L edge
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.CopyPoints(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a previously computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.ComputeLabelling">
            <summary>
            Compute initial labelling for all DirectedEdges at each node.
            In this step, DirectedEdges will acquire a complete labelling
            (i.e. one with labels for both Geometries)
            only if they
            are incident on a node which has edges for both Geometries
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.MergeSymLabels">
            <summary>
            For nodes which have edges from only one Geometry incident on them,
            the previous step will have left their dirEdges with no labelling for the other
            Geometry.  However, the sym dirEdge may have a labelling for the other
            Geometry, so merge the two labels.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.LabelIncompleteNodes">
            <summary>
            Incomplete nodes are nodes whose labels are incomplete.
            (e.g. the location for one Geometry is null).
            These are either isolated nodes,
            or nodes which have edges from only a single Geometry incident on them.
            Isolated nodes are found because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            When each node labelling is completed, the labelling of the incident
            edges is updated, to complete their labelling as well.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.LabelIncompleteNode(NetTopologySuite.GeometriesGraph.GraphComponent,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.FindResultAreaEdges(NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Find all edges whose label indicates that they are in the result area(s),
            according to the operation being performed.  Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.CancelDuplicateResultEdges">
            <summary>
            If both a dirEdge and its sym are marked as being in the result, cancel
            them out.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.IsCoveredByLA(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point node should be included in the result or not.
            </summary>
            <param name="coord">The point coordinate</param>
            <returns><c>true</c> if the coordinate point is covered by a result Line or Area geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.IsCoveredByA(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if an L edge should be included in the result or not.
            </summary>
            <param name="coord">The point coordinate</param>
            <returns><c>true</c> if the coordinate point is covered by a result Area geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.IsCovered(NetTopologySuite.Geometries.Coordinate,System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <returns>
            <c>true</c> if the coord is located in the interior or boundary of
            a point in the list.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp.CreateEmptyResult(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an empty result geometry of the appropriate dimension,
            based on the given overlay operation and the dimensions of the inputs.
            The created geometry is always an atomic geometry,
            not a collection.
            <para/>
            The empty result is constructed using the following rules:
            <list type="bullet">
            <item><description><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/> - result has the dimension of the lowest input dimension</description></item>
            <item><description><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/> - result has the dimension of the highest input dimension</description></item>
            <item><description><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/> - result has the dimension of the left-hand input</description></item>
            <item><description><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/> - result has the dimension of the highest input dimension
            (since symDifference is the union of the differences).</description></item>
            </list>
            </summary>
            <param name="overlayOpCode">The overlay operation being performed</param>
            <param name="a">An input geometry</param>
            <param name="b">An input geometry</param>
            <param name="geomFact">The geometry factory being used for the operation</param>
            <returns>An empty atomic geometry of the appropriate dimension</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.PointBuilder">
            <summary>
            Constructs <c>Point</c>s from the nodes of an overlay graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder.#ctor(NetTopologySuite.Operation.Overlay.OverlayOp,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="op">The operation</param>
            <param name="geometryFactory">The geometry factory</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder.Build(NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Computes the Point geometries which will appear in the result,
            given the specified overlay operation.
            </summary>
            <param name="opCode">The spatial function</param>
            <returns>
            A list of the Points in the result.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder.ExtractNonCoveredResultNodes(NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Determines nodes which are in the result, and creates <see cref="T:NetTopologySuite.Geometries.Point"/>s for them.
            </summary>
            <remarks>
            This method determines nodes which are candidates for the result via their
            labelling and their graph topology.
            </remarks>
            <param name="opCode">The overlay operation</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder.FilterCoveredNodeToPoint(NetTopologySuite.GeometriesGraph.Node)">
            <summary>
            Converts non-covered nodes to Point objects and adds them to the result.
            </summary>
            <remarks>
            A node is covered if it is contained in another element Geometry
            with higher dimension (e.g. a node point might be contained in a polygon,
            in which case the point can be eliminated from the result).
            </remarks>
            <param name="n">The node to test</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.PolygonBuilder">
            <summary>
            Forms <c>Polygon</c>s out of a graph of {DirectedEdge}s.
            The edges to use are marked as being in the result Area.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.Add(NetTopologySuite.GeometriesGraph.PlanarGraph)">
            <summary>
            Add a complete graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.Add(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeEnd},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.Node})">
            <summary>
            Add a set of edges and nodes, which form a graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="dirEdges"></param>
            <param name="nodes"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Overlay.PolygonBuilder.Polygons">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.BuildMaximalEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd})">
            <summary>
            For all DirectedEdges in result, form them into MaximalEdgeRings.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.BuildMinimalEdgeRings(System.Collections.Generic.List{NetTopologySuite.GeometriesGraph.EdgeRing},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing})">
             <summary>
            
             </summary>
             <param name="maxEdgeRings"></param>
             <param name="shellList"></param>
             <param name="freeHoleList"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.FindShell(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing,
            and tests whether they form a Polygon.  This is the case if there is a single shell
            in the list.  In this case the shell is returned.
            The other possibility is that they are a series of connected holes, in which case
            no shell is returned.
            </summary>
            <returns>The shell EdgeRing, if there is one<br/> or
            <c>null</c>, if all the rings are holes.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.PlacePolygonHoles(NetTopologySuite.GeometriesGraph.EdgeRing,System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            This method assigns the holes for a Polygon (formed from a list of
            MinimalEdgeRings) to its shell.
            Determining the holes for a MinimalEdgeRing polygon serves two purposes:
            it is faster than using a point-in-polygon check later on.
            it ensures correctness, since if the PIP test was used the point
            chosen might lie on the shell, which might return an incorrect result from the
            PIP test.
            </summary>
            <param name="shell"></param>
            <param name="minEdgeRings"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.SortShellsAndHoles(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing},System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            For all rings in the input list,
            determine whether the ring is a shell or a hole
            and add it to the appropriate list.
            Due to the way the DirectedEdges were linked,
            a ring is a shell if it is oriented CW, a hole otherwise.
            </summary>
            <param name="edgeRings"></param>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.PlaceFreeHoles(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing},System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            This method determines finds a containing shell for all holes
            which have not yet been assigned to a shell.
            These "free" holes should
            all be properly contained in their parent shells, so it is safe to use the
            <c>findEdgeRingContaining</c> method.
            (This is the case because any holes which are NOT
            properly contained (i.e. are connected to their
            parent shell) would have formed part of a MaximalEdgeRing
            and been handled in a previous step).
            </summary>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.FindEdgeRingContaining(NetTopologySuite.GeometriesGraph.EdgeRing,System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B if envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <param name="testEr"></param>
            <param name="shellList"></param>
            <returns>Containing EdgeRing, if there is one <br/> or
            <c>null</c> if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder.ComputePolygons(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing})">
             <summary>
            
             </summary>
             <param name="shellList"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper">
            <summary>
            Snaps the vertices and segments of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            to another Geometry's vertices.
            A snap distance tolerance is used to control where snapping is performed.
            Snapping one geometry to another can improve
            robustness for overlay operations by eliminating
            nearly-coincident edges
            (which cause problems during noding and intersection calculation).
            It can also be used to eliminate artifacts such as narrow slivers, spikes and gores.
            Too much snapping can result in invalid topology
            beging created, so the number and location of snapped vertices
            is decided using heuristics to determine when it
            is safe to snap.
            This can result in some potential snaps being omitted, however.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.ComputeOverlaySnapTolerance(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Estimates the snap tolerance for a Geometry, taking into account its precision model.
            </summary>
            <param name="g"></param>
            <returns>The estimated snap tolerance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.ComputeSizeBasedSnapTolerance(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.ComputeOverlaySnapTolerance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.Snap(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Snaps two geometries together with a given tolerance.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="snapTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.SnapToSelf(NetTopologySuite.Geometries.Geometry,System.Double,System.Boolean)">
            <summary>
            Snaps a geometry to itself.
            Allows optionally cleaning the result to ensure it is topologically valid
            (which fixes issues such as topology collapses in polygonal inputs).
            Snapping a geometry to itself can remove artifacts such as very narrow slivers, gores and spikes.
            </summary>
            <param name="geom">the geometry to snap</param>
            <param name="snapTolerance">the snapping tolerance</param>
            <param name="cleanResult">whether the result should be made valid</param>
            <returns>a new snapped <see cref="T:NetTopologySuite.Geometries.Geometry"/></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new snapper acting on the given geometry
            </summary>
            <param name="g">the geometry to snap</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.SnapTo(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
             Snaps the vertices in the component <see cref="T:NetTopologySuite.Geometries.LineString" />s
             of the source geometry to the vertices of the given snap geometry.
            </summary>
            <param name="g">a geometry to snap the source to</param>
            <param name="tolerance"></param>
            <returns>a new snapped Geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.SnapToSelf(System.Double,System.Boolean)">
            Snaps the vertices in the component <see cref="T:NetTopologySuite.Geometries.LineString" />s
            of the source geometry to the vertices of the same geometry.
            Allows optionally cleaning the result to ensure it is topologically valid
            (which fixes issues such as topology collapses in polygonal inputs).
            <param name="snapTolerance">The snapping tolerance</param>
            <param name="cleanResult">Whether the result should be made valid</param>
            <returns>The geometry snapped to itself</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.ExtractTargetCoordinates(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.ComputeSnapTolerance(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Computes the snap tolerance based on the input geometries.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.SnapTransformer">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapTransformer.#ctor(System.Double,NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="snapTolerance"></param>
             <param name="snapPts"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapTransformer.SnapLine(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="srcPts"></param>
             <param name="snapPts"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper">
            <summary>
            Snaps the vertices and segments of a <see cref="T:NetTopologySuite.Geometries.LineString"/>
             to a set of target snap vertices.
            A snap distance tolerance is used to control where snapping is performed.
            <para/>The implementation handles empty geometry and empty snap vertex sets.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.#ctor(NetTopologySuite.Geometries.LineString,System.Double)">
            <summary>
            Creates a new snapper using the points in the given <see cref="T:NetTopologySuite.Geometries.LineString"/>
            as target snap points.
            </summary>
            <param name="srcLine">A LineString to snap (may be empty)</param>
            <param name="snapTolerance">the snap tolerance to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.#ctor(NetTopologySuite.Geometries.Coordinate[],System.Double)">
            <summary>
            Creates a new snapper using the given points
            as source points to be snapped.
            </summary>
            <param name="srcPts"></param>
            <param name="snapTolerance"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.SnapTo(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Snaps the vertices and segments of the source LineString
            to the given set of snap points.
            </summary>
            <param name="snapPts">the vertices to snap to</param>
            <returns>list of the snapped points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.SnapVertices(NetTopologySuite.Geometries.CoordinateList,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Snap source vertices to vertices in the target.
            </summary>
            <param name="srcCoords">the points to snap</param>
            <param name="snapPts">the points to snap to</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.FindSnapForVertex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <param name="snapPts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.SnapSegments(NetTopologySuite.Geometries.CoordinateList,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Snap segments of the source to nearby snap vertices.<para/>
            Source segments are "cracked" at a snap vertex.
            A single input segment may be snapped several times
            to different snap vertices.<para/>
            For each distinct snap vertex, at most one source segment
            is snapped to.  This prevents "cracking" multiple segments
            at the same point, which would likely cause
            topology collapse when being used on polygonal linework.
            </summary>
            <param name="srcCoords">The coordinates of the source linestring to snap</param>
            <param name="snapPts">The target snap vertices</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.FindSegmentIndexToSnap(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.CoordinateList)">
            <summary>
            Finds a src segment which snaps to (is close to) the given snap point<para/>
            Only a single segment is selected for snapping.
            This prevents multiple segments snapping to the same snap vertex,
            which would almost certainly cause invalid geometry
            to be created.
            (The heuristic approach of snapping used here
            is really only appropriate when
            snap pts snap to a unique spot on the src geometry)<para/>
            Also, if the snap vertex occurs as a vertex in the src coordinate list,
            no snapping is performed.
            </summary>
            <param name="snapPt">The point to snap to</param>
            <param name="srcCoords">The source segment coordinates</param>
            <returns>The index of the snapped segment <br/>
            or -1 if no segment snaps to the snap point.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp">
            <summary>
            Performs an overlay operation using snapping and enhanced precision
            to improve the robustness of the result.
            This class only uses snapping
            if an error is detected when running the standard JTS overlay code.
            Errors detected include thrown exceptions
            (in particular, <see cref="T:NetTopologySuite.Geometries.TopologyException" />)
            and invalid overlay computations.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp">
            <summary>
            Performs an overlay operation using snapping and enhanced precision
            to improve the robustness of the result.
            This class always uses snapping.
            This is less performant than the standard JTS overlay code,
            and may even introduce errors which were not present in the original data.
            For this reason, this class should only be used
            if the standard overlay code fails to produce a correct result.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <param name="opCode"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.Intersection(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.Difference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.SymDifference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="g1"></param>
             <param name="g2"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.ComputeSnapTolerance">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.GetResultGeometry(NetTopologySuite.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.Snap(NetTopologySuite.Geometries.Geometry[])">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.PrepareResult(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.RemoveCommonBits(NetTopologySuite.Geometries.Geometry[])">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator">
            <summary>
            Finds the most likely <see cref="T:NetTopologySuite.Geometries.Location"/> of a point relative to
            the polygonal components of a geometry, using a tolerance value.
            </summary>
            <remarks>
            If a point is not clearly in the Interior or Exterior,
            it is considered to be on the Boundary.
            In other words, if the point is within the tolerance of the Boundary,
            it is considered to be on the Boundary; otherwise,
            whether it is Interior or Exterior is determined directly.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator.ExtractLinework(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts linework for polygonal components.
            </summary>
            <param name="g">The geometry from which to extract</param>
            <returns>A lineal geometry containing the extracted linework</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Validate.PolygonalLineworkExtracter">
            <summary>
            Extracts the LineStrings in the boundaries of all the polygonal elements in the target <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Validate.PolygonalLineworkExtracter.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Filters out all linework for polygonal elements
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Overlay.Validate.PolygonalLineworkExtracter.Linework">
            <summary>
            Gets the list of polygonal linework.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator">
            <summary>
            Generates points offset by a given distance from both sides of the midpoint of all segments in a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <remarks>
            <para>
            Can be used to generate probe points for determining whether a polygonal overlay result is incorrect.
            </para>
            <para>
            The input geometry may have any orientation for its rings,
            but <see cref="M:NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.SetSidesToGenerate(System.Boolean,System.Boolean)"/> is
            only meaningful if the orientation is known.
            </para>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.SetSidesToGenerate(System.Boolean,System.Boolean)">
            <summary>
            Set the sides on which to generate offset points.
            </summary>
            <param name="doLeft"></param>
            <param name="doRight"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.GetPoints(System.Double)">
            <summary>
            Gets the computed offset points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.ComputeOffsetPoints(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double,System.Collections.Generic.IList{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Generates the two points which are offset from the
            midpoint of the segment <c>(p0, p1)</c> by the <c>offsetDistance</c>
            </summary>
            <param name="p0">The first point of the segment to offset from.</param>
            <param name="p1">The second point of the segment to offset from</param>
            <param name="offsetDistance"></param>
            <param name="offsetPts"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator">
            <summary>
            Validates that the result of an overlay operation is geometrically correct within a determined tolerance.
            Uses fuzzy point location to find points which are
            definitely in either the interior or exterior of the result
            geometry, and compares these results with the expected ones.
            </summary>
            <remarks>
            This algorithm is only useful where the inputs are polygonal.
            This is a heuristic test, and may return false positive results
            (I.e. it may fail to detect an invalid result.)
            It should never return a false negative result, however
            (I.e. it should never report a valid result as invalid.)
            </remarks>
            <author>Martin Davis</author>
            <see cref="T:NetTopologySuite.Operation.Overlay.OverlayOp"/>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.CoverageUnion">
            <summary>
            Unions a valid coverage of polygons or lines
            in an efficient way.
            <para/>
            A <b>polygonal coverage</b> is a collection of <see cref="T:NetTopologySuite.Geometries.Polygon"/>s
            which satisfy the following conditions:
            <list type="number">
            <item><term>Vector-clean</term><description>Line segments within the collection
            must either be identical or intersect only at endpoints.</description></item>
            <item><term>Non-overlapping</term><description>No two polygons
            may overlap. Equivalently, polygons must be interior-disjoint.</description></item>
            </list>
            <para/>
            A <b>linear coverage</b> is a collection of <see cref="T:NetTopologySuite.Geometries.LineString"/>s
            which satisfies the <b>Vector-clean</b> condition.
            Note that this does not require the LineStrings to be fully noded
            - i.e. they may contain coincident linework.
            Coincident line segments are dissolved by the union.
            Currently linear output is not merged (this may be added in a future release.)
            <para/>
            No checking is done to determine whether the input is a valid coverage.
            This is because coverage validation involves segment intersection detection,
            which is much more expensive than the union phase.
            If the input is not a valid coverage
            then in some cases this will be detected during processing 
            and a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown.
            Otherwise, the computation will produce output, but it will be invalid.
            <para/>
            Unioning a valid coverage implies that no new vertices are created.
            This means that a precision model does not need to be specified.
            The precision of the vertices in the output geometry is not changed.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Noding.BoundaryChainNoder"/>
            <seealso cref="T:NetTopologySuite.Noding.SegmentExtractingNoder"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.CoverageUnion.Union(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Unions a valid polygonal coverage or linear network.
            </summary>
            <param name="coverage">A coverage of polygons or lines</param>
            <returns>The union of the coverage</returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown in some cases if the coverage is invalid</exception>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.Edge">
            <summary>
            Represents the linework for edges in a topology graph,
            derived from(up to) two parent geometries.
            An edge may be the result of the merging of
            two or more edges which have the same linework
            (although possibly different orientations).
            In this case the topology information is
            derived from the merging of the information in the
            source edges.<br/>
            Merged edges can occur in the following situations
            <list type="bullet">
            <item><description>Due to coincident edges of polygonal or linear geometries.</description></item>
            <item><description>Due to topology collapse caused by snapping or rounding
            of polygonal geometries.</description></item>
            </list>
            The source edges may have the same parent geometry,
            or different ones, or a mix of the two.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.Edge.IsCollapsed(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests if the given point sequence
            is a collapsed line.<para/>
            A collapsed edge has fewer than two distinct points.
            </summary>
            <param name="pts">The point sequence to check</param>
            <returns><c>true</c> if the points form a collapsed line</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.Edge.RelativeDirection(NetTopologySuite.Operation.OverlayNG.Edge)">
            <summary>
            Compares two coincident edges to determine
            whether they have the same or opposite direction.
            </summary>
            <param name="edge">An edge</param>
            <returns><c>true</c> if the edges have the same direction, <c>false</c> if not</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.Edge.InitLabel(NetTopologySuite.Operation.OverlayNG.OverlayLabel,System.Int32,NetTopologySuite.Geometries.Dimension,System.Int32,System.Boolean)">
            <summary>
            Populates the label for an edge resulting from an input geometry.
            <para/>
            <list type="bullet">
            <item><description>If the edge is not part of the input, the label is left as <see cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_NOT_PART"/></description></item>
            <item><description>If input is an Area and the edge is on the boundary (which may include some collapses), edge is marked as an <see cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_BOUNDARY"/> edge and side locations are assigned</description></item>
            <item><description>If input is an Area and the edge is collapsed (depth delta = 0), the label is set to <see cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_COLLAPSE"/>. The location will be determined later by evaluating the final graph topology.</description></item>
            <item><description>If input is a Line edge is set to a <see cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_LINE"/> edge. For line edges the line location is not significant (since there is no parent area for which to determine location).</description></item>
            </list>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.Edge.IsShell(System.Int32)">
            <summary>
            Tests whether the edge is part of a shell in the given geometry.
            This is only the case if the edge is a boundary.
            </summary>
            <param name="geomIndex">The index of the geometry</param>
            <returns><c>true</c> if this edge is a boundary and part of a shell</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.Edge.Merge(NetTopologySuite.Operation.OverlayNG.Edge)">
            <summary>
            Merges an edge into this edge,
            updating the topology info accordingly.
            </summary>
            <param name="edge">The edge to merge</param>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.EdgeKey">
            <summary>
            A key for sorting and comparing edges in a noded arrangement.
            Relies on the fact that in a correctly noded arrangement
            edges are identical (up to direction)
            if they have their first segment in common.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeKey.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeKey.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeKey.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.EdgeMerger">
            <summary>
            Performs merging on the noded edges of the input geometries.
            Merging takes place on edges which are coincident
            (i.e.have the same coordinate list, modulo direction).
            The following situations can occur:<para/>
            <list type="bullet">
            <item><description>Coincident edges from different input geometries have their labels combined</description></item>
            <item><description>Coincident edges from the same area geometry indicate a topology collapse.
            In this case the topology locations are "summed" to provide a final
            assignment of side location</description></item>
            <item><description>Coincident edges from the same linear geometry can simply be merged
            using the same ON location</description></item>
            </list>
            <para/>
            The merging attempts to preserve the direction of linear
            edges if possible(which is the case if there is 
            no other coincident edge, or if all coincident edges have the same direction).
            This ensures that the overlay output line direction will be as consistent
            as possible with input lines.
            <para/>
            The merger also preserves the order of the edges in the input.
            This means that for polygon-line overlay
            the result lines will be in the same order as in the input
            (possibly with multiple result lines for a single input line).
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder">
            <summary>
            Builds a set of noded, unique, labelled Edges from
            the edges of the two input geometries.
            <para/>
            It performs the following steps:
            <list type="bullet">
            <item><description>Extracts input edges, and attaches topological information</description></item>
            <item><description>if clipping is enabled, handles clipping or limiting input geometry</description></item>
            <item><description>chooses a <see cref="T:NetTopologySuite.Noding.INoder"/> based on provided precision model, unless a custom one is supplied</description></item>
            <item><description>calls the chosen Noder, with precision model</description></item>
            <item><description>removes any fully collapsed noded edges</description></item>
            <item><description>builds <see cref="T:NetTopologySuite.Operation.OverlayNG.Edge"/>s and merges them</description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.#ctor(NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Noding.INoder)">
            <summary>
            Creates a new builder, with an optional custom noder.
            If the noder is not provided, a suitable one will
            be used based on the supplied precision model.
            </summary>
            <param name="pm">The precision model to use</param>
            <param name="noder">An optional noder to use (may be null)</param>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.Noder">
            <summary>
            Gets or sets a noder appropriate for the precision model supplied.<br/>
            This is one of:
            <list type="bullet">
            <item><term>Fixed precision:</term><description>a snap-rounding noder (which should be fully robust)</description></item>
            <item><term>Floating precision:</term><description>a conventional noder (which may be non-robust).
            In this case, a validation step is applied to the output from the noder.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.HasEdgesFor(System.Int32)">
            <summary>
            Reports whether there are noded edges
            for the given input geometry.
            If there are none, this indicates that either
            the geometry was empty, or has completely collapsed
            (because it is smaller than the noding precision).
            </summary>
            <param name="geomIndex">index of the input geometry</param>
            <returns><c>true</c> if there are edges for the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.Build(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a set of labelled {Edge}s.
            representing the fully noded edges of the input geometries.
            Coincident edges (from the same or both geometries)
            are merged along with their labels
            into a single unique, fully labelled edge.
            </summary>
            <param name="geom0">The first geometry</param>
            <param name="geom1">The second geometry</param>
            <returns>The noded, merged, labelled edges</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.Node(System.Collections.Generic.IList{NetTopologySuite.Noding.ISegmentString})">
            <summary>
            Nodes a set of segment strings and creates <see cref="T:NetTopologySuite.Operation.OverlayNG.Edge"/>s from the result.
            The input segment strings each carry a <see cref="T:NetTopologySuite.Operation.OverlayNG.EdgeSourceInfo"/> object,
            which is used to provide source topology info to the constructed Edges
            (and is then discarded).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.AddPolygonRing(NetTopologySuite.Geometries.LinearRing,System.Boolean,System.Int32)">
            <summary>
            Adds a polygon ring to the graph.
            </summary>
            <remarks>Empty rings are ignored.</remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.IsClippedCompletely(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Tests whether a geometry (represented by its envelope)
            lies completely outside the clip extent(if any).
            </summary>
            <param name="env">The geometry envelope</param>
            <returns><c>true</c> if the geometry envelope is outside the clip extent.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.Clip(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            If clipper is present,
            clip the line to the clip extent.
            <para/>
            If clipping is enabled, then every ring MUST
            be clipped, to ensure that holes are clipped to
            be inside the shell.
            This means it is not possible to skip
            clipping for rings with few vertices.
            </summary>
            <param name="ring">The line to clip</param>
            <returns>The points in the clipped ring</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.RemoveRepeatedPoints(NetTopologySuite.Geometries.LineString)">
            <summary>
            Removes any repeated points from a linear component.
            This is required so that noding can be computed correctly.
            </summary>
            <param name="line">The line to process</param>
            <returns>The points of the line with repeated points removed</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.AddLine(NetTopologySuite.Geometries.LineString,System.Int32)">
            <summary>
            Adds a line geometry, limiting it if enabled,
            and otherwise removing repeated points.
            </summary>
            <param name="line">The line to add</param>
            <param name="geomIndex">The index of the parent geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.IsToBeLimited(NetTopologySuite.Geometries.LineString)">
            <summary>
            Tests whether it is worth limiting a line.
            Lines that have few vertices or are covered
            by the clip extent do not need to be limited.
            </summary>
            <param name="line">The line to test</param>
            <returns><c>true</c> if the line should be limited</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder.Limit(NetTopologySuite.Geometries.LineString)">
            <summary>
            If limiter is provided,
            limit the line to the clip envelope.
            </summary>
            <param name="line">The line to clip</param>
            <returns>the point sections in the clipped line</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.EdgeSourceInfo">
            <summary>
            Records topological information about an 
            edge representing a piece of linework (lineString or polygon ring)
            from a single source geometry.
            This information is carried through the noding process
            (which may result in many noded edges sharing the same information object).
            It is then used to populate the topology info fields
            in <see cref="T:NetTopologySuite.Operation.OverlayNG.Edge"/>s (possibly via merging).
            That information is used to construct the topology graph <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayLabel"/>s.
            </summary>
            <autor>Martin Davis</autor>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.ElevationModel">
            <summary>A simple elevation model used to populate missing Z values
            in overlay results.
            <para/>
            The model divides the extent of the input geometry(s)
            into an NxM grid.
            The default grid size is 3x3.
            If the input has no extent in the X or Y dimension,
            that dimension is given grid size 1.
            The elevation of each grid cell is computed as the average of the Z values
            of the input vertices in that cell (if any).
            If a cell has no input vertices within it, it is assigned
            the average elevation over all cells.
            <para/>
            If no input vertices have Z values, the model does not assign a Z value.
            <para/>
            The elevation of an arbitrary location is determined as the
            Z value of the nearest grid cell.
            <para/>
            An elevation model can be used to populate missing Z values
            in an overlay result geometry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.ElevationModel.Create(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an elevation model from two geometries (which may be null).
            </summary>
            <param name="geom1">An input geometry</param>
            <param name="geom2">An input geometry</param>
            <returns>The elevation model computed from the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.ElevationModel.#ctor(NetTopologySuite.Geometries.Envelope,System.Int32,System.Int32)">
            <summary>
            Creates a new elevation model covering an extent by a grid of given dimensions.
            </summary>
            <param name="extent">The XY extent to cover</param>
            <param name="numCellX">The number of grid cells in the X dimension</param>
            <param name="numCellY">The number of grid cells in the Y dimension</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.ElevationModel.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Updates the model using the Z values of a given geometry.
            </summary>
            <param name="geom">The geometry to scan for Z values.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.ElevationModel.GetZ(System.Double,System.Double)">
            <summary>
            Gets the model Z value at a given location.
            If the location lies outside the model grid extent,
            this returns the Z value of the nearest grid cell.
            If the model has no elevation computed (i.e. due
            to empty input), the value is returned as <see cref="F:System.Double.NaN"/>
            </summary>
            <param name="x">x-ordinate of the location</param>
            <param name="y">y-ordinate of the location</param>
            <returns>The computed Z value</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.ElevationModel.PopulateZ(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes Z values for any missing Z values in a geometry,
            using the computed model.
            If the model has no Z value, or the geometry coordinate dimension
            does not include Z, the geometry is not updated.
            </summary>
            <param name="geom">The geometry to populate Z values for</param>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.IndexedPointOnLineLocator">
            <summary>
            Locates points on a linear geometry,
            using a spatial index to provide good performance.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.InputGeometry">
            <summary>
            Manages the input geometries for an overlay operation.
            The second geometry is allowed to be null, 
            to support for instance precision reduction.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.InputGeometry.GetAreaIndex">
            <summary>
            Gets the index of an input which is an area,
            if one exists.
            Otherwise returns -1.
            </summary>
            <returns>The index of an area input, or -1</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.InputGeometry.HasEdges(System.Int32)">
            <summary>
            Tests if an input geometry has edges.
            This indicates that topology needs to be computed for them.
            </summary>
            <param name="geomIndex"></param>
            <returns><c>true</c> if the input geometry has edges</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.InputGeometry.LocatePointInArea(System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determines the location within an area geometry.
            This allows disconnected edges to be fully 
            located. 
            </summary>
            <param name="geomIndex">The index of the geometry</param>
            <param name="pt">The coordinate to locate</param>
            <returns>The location of the coordinate</returns>
            <seealso cref="T:NetTopologySuite.Geometries.Location"/>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.IntersectionPointBuilder">
            <summary>
            Extracts Point resultants from an overlay graph
            created by an Intersection operation
            between non-Point inputs.
            Points may be created during intersection
            if lines or areas touch one another at single points.
            Intersection is the only overlay operation which can
            result in Points from non-Point inputs.
            <para/>
            Overlay operations where one or more inputs
            are Points are handled via a different code path.
            </summary>
            <author>Martin Davis</author>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.OverlayPoints"/>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.IntersectionPointBuilder._isAllowCollapseLines">
            <summary>
            Controls whether lines created by area topology collapses
            to participate in the result computation. <br/>
            True provides the original JTS semantics.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.IntersectionPointBuilder.IsResultPoint(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Tests if a node is a result point.
            This is the case if the node is incident on edges from both
            inputs, and none of the edges are themselves in the result.
            </summary>
            <param name="nodeEdge">An edge originating at the node</param>
            <returns><c>true</c> if the node is a result point.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.LineBuilder">
            <summary>
            Finds and builds overlay result lines from the overlay graph.
            Output linework has the following semantics:
            <list type="number">
            <item><description>Linework is fully noded</description></item>
            <item><description>Lines are as long as possible between nodes</description></item>
            </list>
            Various strategies are possible for how to
            merge graph edges into lines.
            This implementation uses the approach
            of having output lines run contiguously from node to node.
            For rings a node point is chosen arbitrarily.
            <para/>
            Another possible strategy would be to preserve input linework
            as far as possible (i.e.any sections of input lines which are not
            coincident with other linework would be preserved).
            <para/>
            It would also be possible to output LinearRings,
            if the input is a LinearRing and is unchanged.
            This will require additional info from the input linework.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.LineBuilder._isAllowMixedResult">
            <summary>
            Indicates whether intersections are allowed to produce
            heterogeneous results including proper boundary touches.
            This does not control inclusion of touches along collapses.<br/>
            True provides the original JTS semantics.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.LineBuilder._isAllowCollapseLines">
            <summary>
            Allow lines created by area topology collapses
            to appear in the result.<br/>
            True provides the original JTS semantics.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.#ctor(NetTopologySuite.Operation.OverlayNG.InputGeometry,NetTopologySuite.Operation.OverlayNG.OverlayGraph,System.Boolean,NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a builder for linear elements which may be present
            in the overlay result.
            </summary>
            <param name="inputGeom">The input geometries</param>
            <param name="graph">The topology graph</param>
            <param name="hasResultArea"><c>true</c> if an area has been generated for the result</param>
            <param name="opCode">The overlay operation code</param>
            <param name="geomFact">The output geometry factory</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.IsResultLine(NetTopologySuite.Operation.OverlayNG.OverlayLabel)">
            <summary>
            Checks if the topology indicated by an edge label
            determines that this edge should be part of a result line.
            <para/>
            Note that the logic here relies on the semantic
            that for intersection lines are only returned if
            there is no result area components.
            </summary>
            <param name="lbl">The label for an edge</param>
            <returns><c>true</c> if the edge should be included in the result</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.EffectiveLocation(NetTopologySuite.Operation.OverlayNG.OverlayLabel,System.Int32)">
            <summary>
            Determines the effective location for a line,
            for the purpose of overlay operation evaluation.
            Line edges and Collapses are reported as INTERIOR
            so they may be included in the result
            if warranted by the effect of the operation on the two edges.
            (For instance, the intersection of a line edge and a collapsed boundary
            is included in the result).
            </summary>
            <param name="lbl">The label of line</param>
            <param name="geomIndex">The index of parent geometry</param>
            <returns>The effective location of the line</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.AddResultLinesRings">
            <summary>
            Adds lines which form rings (i.e. have only degree-2 vertices).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.BuildLine(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Traverses edges from edgeStart which
            lie in a single line (have degree = 2).
            <para/>
            The direction of the linework is preserved as far as possible.
            Specifically, the direction of the line is determined
            by the start edge direction. This implies
            that if all edges are reversed, the created line
            will be reversed to match.
            This ensures the orientation of linework is faithful to the input
            in the case of polygon-line overlay.
            However, this does not provide a consistent orientation 
            in the case of line-line intersection(where A and B might have different orientations).
            (Other more complex strategies would be possible.
            E.g. using the direction of the majority of segments,
            or preferring the direction of the A edges.)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.NextLineEdgeUnvisited(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Finds the next edge around a node which forms
            part of a result line.
            </summary>
            <param name="node">A line edge originating at the node to be scanned</param>
            <returns>The next line edge, or null if there is none
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineBuilder.DegreeOfLines(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Computes the degree of the line edges incident on a node
            </summary>
            <param name="node">Node to compute degree for</param>
            <returns>Degree of the node line edges</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.LineLimiter">
            <summary>
            Limits the segments in a list of segments
            to those which intersect an envelope.
            This creates zero or more sections of the input segment sequences,
            containing only line segments which intersect the limit envelope.
            Segments are not clipped, since that can move
            line segments enough to alter topology,
            and it happens in the overlay in any case.
            This can substantially reduce the number of vertices which need to be
            processed during overlay.
            <para/>
            This optimization is only applicable to Line geometries,
            since it does not maintain the closed topology of rings.
            Polygonal geometries are optimized using the <see cref="T:NetTopologySuite.Operation.OverlayNG.RingClipper"/>.
            </summary>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.RingClipper"/>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineLimiter.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates a new limiter for a given envelope.
            </summary>
            <param name="env">The envelope to limit to</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.LineLimiter.Limit(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Limits a list of segments.
            </summary>
            <param name="pts">The segment sequence to limit</param>
            <returns>The sections which intersect the limit envelope</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing.LinkResultAreaMaxRingAtNode(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Traverses the star of edges originating at a node
            and links consecutive result edges together
            into <b>maximal</b> edge rings.
            To link two edges the <c>resultNextMax</c> pointer
            for an <b>incoming</b> result edge
            is set to the next <b>outgoing</b> result edge.
            <para/>
            Edges are linked when:
            <list type="bullet">
            <item><description>they belong to an area (i.e.they have sides)</description></item>
            <item><description>they are marked as being in the result</description></item>
            </list>
            <para/>
            Edges are linked in CCW order 
            (which is the order they are linked in the underlying graph).
            This means that rings have their face on the Right
            (in other words,
            the topological location of the face is given by the RHS label of the DirectedEdge).
            This produces rings with CW orientation.
            <para/>
            PRECONDITIONS: <br/>
            - This edge is in the result<br/>
            - This edge is not yet linked<br/>
            - The edge and its sym are NOT both marked as being in the result
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing.LinkMinRingEdgesAtNode(NetTopologySuite.Operation.OverlayNG.OverlayEdge,NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing)">
            <summary>
            Links the edges of a <see cref="T:NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing"/> around this node
            into minimal edge rings (<see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing"/>s).
            Minimal ring edges are linked in the opposite orientation (CW)
            to the maximal ring.
            This changes self-touching rings into a two or more separate rings,
            as per the OGC SFS polygon topology semantics.
            This relinking must be done to each max ring separately,
            rather than all the node result edges, since there may be 
            more than one max ring incident at the node.
            </summary>
            <param name="maxRing">The maximal ring to link</param>
            <param name="nodeEdge">An edge originating at this node</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing.IsAlreadyLinked(NetTopologySuite.Operation.OverlayNG.OverlayEdge,NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing)">
            <summary>
            Tests if an edge of the maximal edge ring is already linked into
            a minimal <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing"/>. If so, this node has already been processed
            earlier in the maximal edgering linking scan.
            </summary>
            <param name="edge">An edge of a maximal edgering</param>
            <param name="maxRing">The maximal edgering</param>
            <returns><c>true</c> if the edge has already been linked into a minimal edgering.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayEdge.CreateEdge(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Operation.OverlayNG.OverlayLabel,System.Boolean)">
            <summary>
            Creates a single OverlayEdge.
            </summary>
            <param name="pts"></param>
            <param name="lbl"></param>
            <param name="direction"></param>
            <returns>A new edge based on the given coordinates and direction.</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdge.NodeComparator">
            <summary>
            Gets a <see cref="T:System.Collections.Generic.IComparer`1"/> which sorts by the origin Coordinates.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdge.IsForward">
            <summary>
            <c>true</c> indicates direction is forward along segString<br/>
            <c>false</c> is reverse direction<br/>
            The label must be interpreted accordingly.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayEdge.AddCoordinates(NetTopologySuite.Geometries.CoordinateList)">
            <summary>
            Adds the coordinates of this edge to the given list,
            in the direction of the edge.
            Duplicate coordinates are removed
            (which means that this is safe to use for a path 
            of connected edges in the topology graph).
            </summary>
            <param name="coords">The coordinate list to add to</param>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdge.SymOE">
            <summary>
            ets the symmetric pair edge of this edge.
            </summary>
            <returns>The symmetric pair edge</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdge.ONextOE">
            <summary>
            Gets the next edge CCW around the origin of this edge,
            with the same origin.<br/>
            If the origin vertex has degree 1 then this is the edge itself.
            </summary>
            <returns>
            The next edge around the origin
            </returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdge.NextResult">
            <summary>
            Gets or sets a link to next edge in the result ring.
            The origin of the edge is the dest of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.IsHole">
            <summary>
            Tests whether this ring is a hole.
            </summary>
            <value><c>true</c> if this ring is a hole</value>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.HasShell">
            <summary>
            Tests whether this ring has a shell assigned to it.
            </summary>
            <value><c>true</c> if the ring has a shell</value>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.Shell">
            <summary>
            Gets or sets a value indicating the shell for this ring.<br/>
            The shell is the ring itself if it is not a hole, otherwise its parent shell.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.Coordinates">
            <summary>
            Computes the list of coordinates which are contained in this ring.
            The coordinates are computed once only and cached.
            </summary>
            <value>An array of the <see cref="P:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.Coordinate"/>s in this ring</value>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.FindEdgeRingContaining(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing})">
            <summary>
            Finds the innermost enclosing shell OverlayEdgeRing
            containing this OverlayEdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            <br/>
            ring A contains ring B if envelope(ring A) contains envelope(ring B)
            <br/>
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell)
            <para/>
            To improve performance of this function the caller should 
            make the passed shellList as small as possible (e.g.
            by using a spatial index filter beforehand).
            </summary>
            <returns>The containing EdgeRing, if there is one
            or <c>null</c> if no containing EdgeRing is found
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing.ToPolygon(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.Geometries.Polygon"/> formed by this ring and any contained holes.
            </summary>
            <returns>The <see cref="T:NetTopologySuite.Geometries.Polygon"/> formed by this ring and its holes.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayGraph">
            <summary>
            A planar graph of edges, representing
            the topology resulting from an overlay operation.
            Each source edge is represented
            by a pair of <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayEdge"/>s,
            with opposite(symmetric) orientation.
            The pair of OverlayEdges share the edge coordinates
            and a single <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayLabel"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayGraph.Edges">
            <summary>
            Gets the set of edges in this graph.
            Only one of each symmetric pair of OverlayEdges is included. 
            The opposing edge can be found by using <see cref="P:NetTopologySuite.EdgeGraph.HalfEdge.Sym"/>.
            </summary>
            <returns>The collection of representative edges in this graph</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayGraph.NodeEdges">
            <summary>
            Gets the collection of edges representing the nodes in this graph.
            For each star of edges originating at a node
            a single representative edge is included.<br/>
            The other edges around the node can be found by following the next and prev links.
            </summary>
            <returns>The collection of representative node edges</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayGraph.GetNodeEdge(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets an edge originating at the given node point.
            </summary>
            <param name="nodePt">The node coordinate to query</param>
            <returns>An edge originating at the point, or <c>null</c> if none exists</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayGraph.GetResultAreaEdges">
            <summary>
            Gets the representative edges marked as being in the result area.
            </summary>
            <returns>The result area edges</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayGraph.AddEdge(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Operation.OverlayNG.OverlayLabel)">
            <summary>
            Adds an edge between the coordinates orig and dest
            to this graph.<br/>
            Only valid edges can be added (in particular, zero-length segments cannot be added)
            </summary>
            <param name="pts">The edge to add.</param>
            <param name="label">The edge topology information</param>
            <returns>The created graph edge with same orientation as the linework</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayGraph.Insert(NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Inserts a single half-edge into the graph.
            The sym edge must also be inserted.
            </summary>
            <param name="e">The half-edge to insert</param>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayLabel">
            <summary>
            A structure recording the topological situation
            for an edge in a topology graph
            used during overlay processing.
            </summary>
            <remarks>
            A label contains the topological <see cref="T:NetTopologySuite.Geometries.Location"/> for
            one or two input geometries to an overlay operation.
            An input geometry may be either a Line or an Area.
            The label locations for each input geometry are populated
            with the <see cref="T:NetTopologySuite.Geometries.Location"/>
            for the edge <see cref="T:NetTopologySuite.Geometries.Position"/>s
            when they are created or once they are computed by topological evaluation.
            A label also records the(effective) dimension of each input geometry.
            For area edges the role(shell or hole)
            of the originating ring is recorded, to allow
            determination of edge handling in collapse cases.
            <para/>
            In an <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayGraph"/>
            a single label is shared between
            the two oppositely-oriented <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayEdge"/>s
            of a symmetric pair. 
            Accessors for orientation-sensitive information
            are parameterized by the orientation of the containing edge.
            <para/>
            For each input geometry (0 and 1), the label records
            that an edge is in one of the following states
            (identified by the<c>dim</c> field).
            Each state has additional information about the edge topology.
            <list type="bullet">
            <item><description>A <b>Boundary</b> edge of an Area (polygon)
              <list type="bullet">
                <item><description><c>dim</c> = DIM_BOUNDARY</description></item>
                <item><description><c>locLeft, locRight</c> : the locations of the edge sides for the Area</description></item>
                    <item><description><c>locLine</c> : INTERIOR</description></item>
                <item><description><c>isHole</c> : whether the edge is in a shell or a hole (the ring role)</description></item>
              </list>
              </description>
            </item>
            <item><description>A <b>Collapsed</b> edge of an input Area
            (formed by merging two or more parent edges)
              <list type="bullet">
                <item><description><c>dim</c> = DIM_COLLAPSE</description></item>
                <item><description><c>locLine</c> : the location of the edge relative to the effective input Area
                                       (a collapsed spike is EXTERIOR, a collapsed gore or hole is INTERIOR)</description></item>
                <item><description><c>isHole</c> : <c>true</c> if all parent edges are in holes;
                                                   <c>false</c> if some parent edge is in a shell</description></item>
                
              </list></description>
            </item>
            <item><description>A <b>Line</b> edge from an input line
              <list type="bullet">
              <item><description><c>dim</c> = DIM_LINE</description></item>
              <item><description><c>locLine </c> : the location of the edge relative to the Line.
              Initialized to LOC_UNKNOWN to simplify logic.</description></item>
              </list></description>
            </item>
            <item><description>An edge which is <b>Not Part</b> of an input geometry
            (and thus must be part of the other geometry).
              <list type="bullet">
              <item><description><c>dim</c> = NOT_PART</description></item>
              </list></description>
            </item>
            </list>
            Note that:
            <list type="bullet">
            <item><description>an edge cannot be both a Collapse edge and a Line edge in the same input geometry,
            because each input geometry must be homogeneous.</description></item>
            <item><description>an edge may be an Boundary edge in one input geometry
            and a Line or Collapse edge in the other input.</description></item>
            </list>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_UNKNOWN">
            <summary>
            The dimension of an input geometry which is not known.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_NOT_PART">
            <summary>
            The dimension of an edge which is not part of a specified input geometry.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_LINE">
            <summary>
            The dimension of an edge which is a line.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_BOUNDARY">
            <summary>
            The dimension for an edge which is part of an input Area geometry boundary.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_COLLAPSE">
            <summary>
            The dimension for an edge which is a collapsed part of an input Area geometry boundary.
            A collapsed edge represents two or more line segments which have the same endpoints.
            They usually are caused by edges in valid polygonal geometries
            having their endpoints become identical due to precision reduction.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.LOC_UNKNOWN">
            <summary>
            Indicates that the location is currently unknown
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.#ctor(System.Int32,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,System.Boolean)">
            <summary>
            Creates a label for an Area edge
            </summary>
            <param name="index">The input index of the parent geometry</param>
            <param name="locLeft">The location of the left side of the edge</param>
            <param name="locRight">The location of the right side of the edge</param>
            <param name="isHole">Whether the edge role is a hole or a shell</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.#ctor(System.Int32)">
            <summary>
            Creates a label for a Line edge
            </summary>
            <param name="index">The input index of the parent geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.#ctor">
            <summary>
            Creates an uninitialized label
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.#ctor(NetTopologySuite.Operation.OverlayNG.OverlayLabel)">
            <summary>
            Creates a label which is a copy of another label.
            </summary>
            <param name="lbl">The template label</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.Dimension(System.Int32)">
            <summary>
            Gets the effective dimension of the given input geometry.
            </summary>
            <param name="index">The input index of the parent geometry</param>
            <returns>The dimension</returns>
            <seealso cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_UNKNOWN"/>
            <seealso cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_NOT_PART"/>
            <seealso cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_LINE"/>
            <seealso cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_BOUNDARY"/>
            <seealso cref="F:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DIM_COLLAPSE"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.InitBoundary(System.Int32,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location,System.Boolean)">
            <summary>
            Initializes the label for an input geometry which is an Area boundary.
            </summary>
            <param name="index">The input index of the parent geometry</param>
            <param name="locLeft">The location of the left side of the edge</param>
            <param name="locRight">The location of the right side of the edge</param>
            <param name="isHole">Whether the edge role is a hole or a shell</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.InitCollapse(System.Int32,System.Boolean)">
            <summary>
            Initializes the label for an edge which is the collapse of
            part of the boundary of an Area input geometry.
            <para/>
            The location of the collapsed edge relative to the
            parent area geometry is initially unknown.
            It must be determined from the topology of the overlay graph
            </summary>
            <param name="index">The index of the parent input geometry</param>
            <param name="isHole">Whether the dominant edge role is a hole or a shell</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.InitLine(System.Int32)">
            <summary>
            Initializes the label for an input geometry which is a Line.
            </summary>
            <param name="index">The index of the parent input geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.InitNotPart(System.Int32)">
            <summary>
            Initializes the label for an edge which is not part of an input geometry.
            </summary>
            <param name="index">The index of the parent input geometry</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.SetLocationLine(System.Int32,NetTopologySuite.Geometries.Location)">
            <summary>
            Sets the line location.
            <br/>
            This is used to set the locations for linear edges 
            encountered during area label propagation.
            </summary>
            <param name="index">The index of the input geometry</param>
            <param name="loc">Location to set</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.SetLocationAll(System.Int32,NetTopologySuite.Geometries.Location)">
            <summary>
            Sets the location of all postions for a given input.
            </summary>
            <param name="index">The index of the input geometry</param>
            <param name="loc">The location to set</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.SetLocationCollapse(System.Int32)">
            <summary>
            Sets the location for a collapsed edge (the Line position)
            for an input geometry,
            depending on the ring role recorded in the label.
            If the input geometry edge is from a shell,
            the location is <see cref="F:NetTopologySuite.Geometries.Location.Exterior"/>, if it is a hole
            it is <see cref="F:NetTopologySuite.Geometries.Location.Interior"/>.
            </summary>
            <param name="index">The index of the input geometry</param>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLine">
            <summary>
            Tests whether at least one of the sources is a Line.
            </summary>
            <value><c>true</c> if at least one source is a line</value>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLineAt(System.Int32)">
            <summary>
            Tests whether a source is a Line.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the input is a Line</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLinear(System.Int32)">
            <summary>
            Tests whether an edge is linear (a Line or a Collapse) in an input geometry.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the edge is linear</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsKnown(System.Int32)">
            <summary>
            Tests whether the source of a label is known.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the source is known</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsNotPart(System.Int32)">
            <summary>
            Tests whether a label is for an edge which is not part
            of a given input geometry.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the edge is not part of the geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundaryEither">
            <summary>
            Gets a value indicating if a label is for an edge which is in the boundary of either source geometry.
            </summary>
            <returns><c>true</c> if the label is a boundary for either source</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundaryBoth">
            <summary>
            Gets a value indicating if a label is for an edge which is in the boundary of both source geometries.
            </summary>
            <returns><c>true</c> if the label is a boundary for both sources</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundaryCollapse">
            <summary>
            Tests if the label is a collapsed edge of one area  
            and is a(non-collapsed) boundary edge of the other area.
            </summary>
            <value><c>true</c> if the label is for a collapse coincident with a boundary</value>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundaryTouch">
            <summary>
            Tests if a label is for an edge where two
            area touch along their boundary.
            </summary>
            <returns><c>true</c> if the edge is a boundary touch</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundary(System.Int32)">
            <summary>
            Tests if a label is for an edge which is in the boundary of a source geometry.
            Collapses are not reported as being in the boundary.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the label is a boundary for the source</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsBoundarySingleton">
            <summary>
            Tests whether a label is for an edge which is a boundary of one geometry
            and not part of the other.
            </summary>
            <returns><c>true</c> if the edge is a boundary singleton</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLineLocationUnknown(System.Int32)">
            <summary>
            Tests if the line location for a source is unknown.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the line location is unknown</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLineInArea(System.Int32)">
            <summary>
            Tests if a line edge is inside a source geometry
            (i.e.it has location <see cref="F:NetTopologySuite.Geometries.Location.Interior"/>).
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the line is inside the source geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsHole(System.Int32)">
            <summary>
            Tests if the ring role of an edge is a hole.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the ring role is a hole</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsCollapse(System.Int32)">
            <summary>
            Tests if an edge is a Collapse for a source geometry.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if the label indicates the edge is a collapse for the source</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsInteriorCollapse">
            <summary>
            Tests if a label is a Collapse has location {@link Location#INTERIOR},
            to at least one source geometry.
            </summary>
            <returns><c>true</c> if the label is an Interior Collapse to a source geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsCollapseAndNotPartInterior">
            <summary>
            Tests if a label is a Collapse
            and NotPart with location {@link Location#INTERIOR} for the other geometry.
            </summary>
            <returns><c>true</c> if the label is a Collapse and a NotPart with Location Interior</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.GetLineLocation(System.Int32)">
            <summary>
            Gets the line location for a source geometry.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns>The line location for the source</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.IsLineInterior(System.Int32)">
            <summary>
            Tests if a line is in the interior of a source geometry.
            </summary>
            <param name="index">The index of the source geometry</param>
            <returns><c>true</c> if the label is a line and is interior</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.GetLocation(System.Int32,NetTopologySuite.Geometries.Position,System.Boolean)">
            <summary>
            Gets the location for a <see cref="T:NetTopologySuite.Geometries.Position"/> of an edge of a source
            for an edge with given orientation.
            </summary>
            <param name="index">The index of the input geometry</param>
            <param name="position">The position to get the location for</param>
            <param name="isForward"><c>true</c> if the orientation of the containing edge is forward</param>
            <returns>The location of the oriented position in the source</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.GetLocationBoundaryOrLine(System.Int32,NetTopologySuite.Geometries.Position,System.Boolean)">
            <summary>
            Gets the location for this label for either
            a Boundary or a Line edge.
            This supports a simple determination of
            whether the edge should be included as a result edge.
            </summary>
            <param name="index">The source index</param>
            <param name="position">The position for a boundary label</param>
            <param name="isForward">The direction for a boundary label</param>
            <returns>The location for the specified position</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.GetLocation(System.Int32)">
            <summary>
            Gets the linear location for the given source.
            </summary>
            <param name="index">The source geometry index</param>
            <returns>The linear location for the source</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.HasSides(System.Int32)">
            <summary>
            Tests whether this label has side position information
            for a source geometry.
            </summary>
            <param name="index">The index of the input geometry</param>
            <returns><c>true</c> if at least one side position is known</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.Copy">
            <summary>
            Creates a copy of this label
            </summary>
            <returns>A copy of this label</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.RingRoleSymbol(System.Boolean)">
            <summary>
            Gets a symbol for the a ring role (Shell or Hole).
            </summary>
            <param name="isHole"><c>true</c> for a hole, <c>false</c> for a shell</param>
            <returns>The ring role symbol character</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabel.DimensionSymbol(NetTopologySuite.Geometries.Dimension)">
            <summary>
            Gets the symbol for the dimension code of an edge.
            </summary>
            <param name="dim">The dimension code</param>
            <returns>The dimension symbol character</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayLabeller">
            <summary>
            Implements the logic to compute the full labeling
            for the edges in an <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayGraph"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.ComputeLabelling">
            <summary>
            Computes the topological labeling for the edges in the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LabelAreaNodeEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdge})">
            <summary>
            Labels edges around nodes based on the arrangement
            of incident area boundary edges.
            Also propagates the labeling to connected linear edges.
            </summary>
            <param name="nodes">The nodes to label</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.PropagateAreaLocations(NetTopologySuite.Operation.OverlayNG.OverlayEdge,System.Int32)">
            <summary>
            Scans around a node CCW, propagating the side labels
            for a given area geometry to all edges (and their sym)
            with unknown locations for that geometry.
            </summary>
            <param name="nodeEdge"></param>
            <param name="geomIndex">The geometry to propagate locations for</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.FindPropagationStartEdge(NetTopologySuite.Operation.OverlayNG.OverlayEdge,System.Int32)">
            <summary>
            Finds a boundary edge for this geom originating at the given
            node, if one exists.
            A boundary edge should exist if this is a node on the boundary
            of the parent area geometry.
            </summary>
            <param name="nodeEdge">An edge for this node</param>
            <param name="geomIndex">The parent geometry index</param>
            <returns>A boundary edge, or <c>null</c> if no boundary edge exists</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LabelCollapsedEdges">
            <summary>
            At this point collapsed edges with unknown location
            must be disconnected from the boundary edges of the parent
            (because otherwise the location would have
            been propagated from them).<br/>
            They can be now located based on their parent ring role(shell or hole).
            (This cannot be done earlier, because the location
            based on the boundary edges must take precedence.<br/>
            There are situations where a collapsed edge has a location 
            which is different to its ring role - 
            e.g.a narrow gore in a polygon, which is in
            the interior of the reduced polygon, but whose
            ring role would imply the location EXTERIOR.)
            <para/> 
            Note that collapsed edges can NOT have location determined via a PIP location check,
            because that is done against the unreduced input geometry,
            which may give an invalid result due to topology collapse.
            <para/>
            The labeling is propagated to other connected linear edges,
            since there may be NOT_PART edges which are connected,
            and they can be labeled in the same way.
            (These would get labeled anyway during subsequent disconnected labeling pass,
            but may be more efficient and accurate to do it here.)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LabelConnectedLinearEdges">
            <summary>
            There can be edges which have unknown location
            but are connected to a linear edge with known location.
            In this case linear location is propagated to the connected edges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.PropagateLinearLocations(System.Int32)">
            <summary>
            Performs a breadth-first graph traversal to find and label
            connected linear edges.
            </summary>
            <param name="geomIndex">The index of the input geometry to label.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.FindLinearEdgesWithLocation(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdge},System.Int32)">
            <summary>
            Finds all OverlayEdges which are linear
            (i.e.line or collapsed) and have a known location
            for the given input geometry.
            </summary>
            <param name="geomIndex">The index of the input geometry</param>
            <returns>A list of linear edges with known location</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LabelDisconnectedEdges">
            <summary>
            At this point there may still be edges which have unknown location
            relative to an input geometry.<br/>
            This must be because they are NOT_PART edges for that geometry,
            and are disconnected from any edges of that geometry.
            An example of this is rings of one geometry wholly contained
            in another geometry.<br/>
            The location must be fully determined to compute a
            correct result for all overlay operations.
            <para/>
            If the input geometry is an Area the edge location can
            be determined via a PIP test.
            If the input is not an Area the location is EXTERIOR.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LabelDisconnectedEdge(NetTopologySuite.Operation.OverlayNG.OverlayEdge,System.Int32)">
            <summary>
            Determines the location of an edge relative to a target input geometry.
            The edge has no location information
            because it is disconnected from other
            edges that would provide that information.
            The location is determined by checking
            if the edge lies inside the target geometry area(if any).
            </summary>
            <param name="edge">The edge to label</param>
            <param name="geomIndex">The input geometry to label against</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LocateEdge(System.Int32,NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Determines the <see cref="T:NetTopologySuite.Geometries.Location"/> for an edge within an Area geometry
            via point-in-polygon location.
            <para/>
            NOTE this is only safe to use for disconnected edges,
            since the test is carried out against the original input geometry,
            and precision reduction may cause incorrect results for edges
            which are close enough to a boundary to become connected.
            </summary>
            <param name="geomIndex">The parent geometry index</param>
            <param name="edge">The edge to locate</param>
            <returns>The location of the edge.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.LocateEdgeBothEnds(System.Int32,NetTopologySuite.Operation.OverlayNG.OverlayEdge)">
            <summary>
            Determines the {@link Location} for an edge within an Area geometry
            via point-in-polygon location,
            by checking that both endpoints are interior to the target geometry.
            Checking both endpoints ensures correct results in the presence of topology collapse.
            <para/>
            NOTE this is only safe to use for disconnected edges,
            since the test is carried out against the original input geometry,
            and precision reduction may cause incorrect results for edges
            which are close enough to a boundary to become connected. 
            </summary>
            <param name="geomIndex">The parent geometry index</param>
            <param name="edge">The edge to locate</param>
            <returns>The location of the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.MarkInResultArea(NetTopologySuite.Operation.OverlayNG.OverlayEdge,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Marks an edge which forms part of the boundary of the result area.
            This is determined by the overlay operation being executed,
            and the location of the edge.
            The relevant location is either the right side of a boundary edge,
            or the line location of a non-boundary edge.
            </summary>
            <param name="e">The edge to mark</param>
            <param name="overlayOpCode">The overlay operation</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayLabeller.UnmarkDuplicateEdgesFromResultArea">
            <summary>
            Unmarks result area edges where the sym edge 
            is also marked as in the result.
            This has the effect of merging edge-adjacent result areas,
            as required by polygon validity rules.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayMixedPoints">
            <summary>
            Computes an overlay where one input is Point(s) and one is not.
            This class supports overlay being used as an efficient way
            to find points within or outside a polygon.
            <para/>
            Input semantics are:
            <list type="bullet">
            <item><description>Duplicates are removed from Point output</description></item>
            <item><description>Non-point output is rounded and noded using the given precision model</description></item>
            </list>
            Output semantics are:
            <list type="bullet">
            <item><description>An empty result is an empty atomic geometry
            with dimension determined by the inputs and the operation as per overlay semantics
            </description></item>
            </list>
            For efficiency the following optimizations are used:
            <list type="bullet">
            <item><description>Input points are not included in the noding of the non-point input geometry
            (in particular, they do not participate in snap-rounding if that is used).</description></item>
            <item><description>If the non-point input geometry is not included in the output
            it is not rounded and noded.This means that points
            are compared to the non-rounded geometry.
            This will be apparent in the result.</description></item>
            </list>
            This means that overlay is efficient to use for finding points
            within or outside a polygon.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayMixedPoints.CopyNonPoint">
            <summary>
            Copy the non-point input geometry if not
            already done by precision reduction process.
            </summary>
            <returns>A copy of the non-point geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayNG">
            <summary>
            Computes the geometric overlay of two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s,
            using an explicit precision model to allow robust computation.
            <para/>
            The overlay can be used to determine any of the
            following set-theoretic operations (boolean combinations) of the geometries:
            <list type="bullet">
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/></term><description>all points which lie in both geometries</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/></term><description>all points which lie in at least one geometry</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/></term><description>all points which lie in the first geometry but not the second</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/></term><description>all points which lie in one geometry but not both</description></item>
            </list>
            Input geometries may have different dimension.
            Input collections must be homogeneous (all elements must have the same dimension).
            <para/>
            The precision model used for the computation can be supplied
            independent of the precision model of the input geometry.
            The main use for this is to allow using a fixed precision
            for geometry with a floating precision model.
            This does two things: ensures robust computation;
            and forces the output to be validly rounded to the precision model.
            <para/>
            For fixed precision models noding is performed using a <see cref="T:NetTopologySuite.Noding.Snapround.SnapRoundingNoder"/>.
            This provides robust computation(as long as precision is limited to
            around 13 decimal digits).
            <para/>
            For floating precision an <see cref="T:NetTopologySuite.Noding.MCIndexNoder"/> is used.
            This is not fully robust, so can sometimes result in 
            <see cref="T:NetTopologySuite.Geometries.TopologyException"/>s being thrown.
            For robust full-precision overlay see <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust"/>.
            <para/>
            A custom <see cref="T:NetTopologySuite.Noding.INoder"/> can be supplied.
            This allows using a more performant noding strategy in specific cases,
            for instance in <see cref="T:NetTopologySuite.Operation.OverlayNG.CoverageUnion"/>.
            <para/>
            <b>Note:</b> If a <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/> is used
            it is best to specify a fairly small snap tolerance,
            since the intersection clipping optimization can
            interact with the snapping to alter the result.
            <para/>
            Optionally the overlay computation can process using strict mode
            (via <see cref="P:NetTopologySuite.Operation.OverlayNG.OverlayNG.StrictMode"/> = <c>true</c>).
            In strict mode result semantics are:
            <list type="bullet">
            <item><description>Lines and Points resulting from topology collapses are not included in the result</description></item>
            <item><description>Result geometry is homogeneous
            for the <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/> and <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/> operations.</description></item>
            <item><description>Result geometry is homogeneous
            for the <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/> and <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/> operations
            if the inputs have the same dimension</description></item>
            </list>
            Strict mode has the following benefits:
            <list type="bullet">
            <item><description>Results are simpler</description></item>
            <item><description>Overlay operations are easily chainable
            without needing to remove lower-dimension elements</description></item>
            </list>
            The original JTS overlay semantics corresponds to non-strict mode.
            <para/>
            If a robustness error occurs, a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown.
            These are usually caused by numerical rounding causing the noding output
            to not be fully noded.
            For robust computation with full-precision <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust"/>
            can be used.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNG.INTERSECTION">
            <summary>
            The code for the Intersection overlay operation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNG.UNION">
            <summary>
            The code for the Union overlay operation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNG.DIFFERENCE">
            <summary>
            The code for the Difference overlay operation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNG.SYMDIFFERENCE">
            <summary>
            The code for the Symmetric Difference overlay operation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNG.STRICT_MODE_DEFAULT">
            <summary>
            The default setting for Strict Mode.
            <para/>
            The original JTS overlay semantics used non-strict result
            semantics, including;<br/>
            - An Intersection result can be mixed-dimension,
              due to inclusion of intersection components of all dimensions <br/>
            - Results can include lines caused by Area topology collapse
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.IsResultOfOpPoint(NetTopologySuite.Operation.OverlayNG.OverlayLabel,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Tests whether a point with a given topological <see cref="T:NetTopologySuite.GeometriesGraph.Label"/>
            relative to two geometries is contained in 
            the result of overlaying the geometries using
            a given overlay operation.
            <para/>
            The method handles arguments of <see cref="F:NetTopologySuite.Geometries.Location.Null"/> correctly
            </summary>
            <param name="label">The topological label of the point</param>
            <param name="opCode">The code for the overlay operation to test</param>
            <returns><c>true</c> if the label locations correspond to the overlay <paramref name="opCode"/></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.IsResultOfOp(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Location,NetTopologySuite.Geometries.Location)">
            <summary>
            Tests whether a point with given <see cref="T:NetTopologySuite.Geometries.Location"/>s
            relative to two geometries would be contained in 
            the result of overlaying the geometries using
            a given overlay operation.
            This is used to determine whether components
            computed during the overlay process should be
            included in the result geometry.
            <para/>
            The method handles arguments of <see cref="F:NetTopologySuite.Geometries.Location.Null"/> correctly.
            </summary>
            <param name="overlayOpCode">The code for the overlay operation to test</param>
            <param name="loc0">The code for the location in the first geometry</param>
            <param name="loc1">The code for the location in the second geometry</param>
            <returns><c>true</c> if a point with given locations is in the result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Computes an overlay operation for 
            the given geometry operands, with the
            noding strategy determined by the precision model.
            </summary>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="opCode">The code for the desired overlay operation</param>
            <param name="pm">The precision model to use</param>
            <returns>The result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Noding.INoder)">
            <summary>
            Computes an overlay operation for 
            the given geometry operands, using a supplied <see cref="T:NetTopologySuite.Noding.INoder"/>.
            </summary>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="opCode">The code for the desired overlay operation</param>
            <param name="pm">The precision model to use (which may be null if the noder does not use one)</param>
            <param name="noder">The noder to use</param>
            <returns>The result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Noding.INoder)">
            <summary>
            Computes an overlay operation on the given geometry operands,
            using a supplied <see cref="T:NetTopologySuite.Noding.INoder"/>.
            </summary>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="opCode">The code for the desired overlay operation</param>
            <param name="noder">The noder to use</param>
            <returns>The result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Computes an overlay operation on 
            the given geometry operands,
            using the precision model of the geometry.
            and an appropriate noder.
            <para/>
            The noder is chosen according to the precision model specified.
            <list type="bullet">
            <item><description>For <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Fixed"/>
            a snap-rounding noder is used, and the computation is robust.</description></item>
            <item><description>For <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/>
            a non-snapping noder is used,
            and this computation may not be robust.
            If errors occur a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown.</description></item>
            </list>
            </summary>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="opCode">The code for the desired overlay operation</param>
            <returns>The result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Computes a union operation on 
            the given geometry, with the supplied precision model.
            <para/>
            The input must be a valid geometry.
            Collections must be homogeneous.
            <para/>
            To union an overlapping set of polygons in a more performant way use <see cref="T:NetTopologySuite.Operation.OverlayNG.UnaryUnionNG"/>.
            To union a polygonal coverage or linear network in a more performant way, 
            use <see cref="T:NetTopologySuite.Operation.OverlayNG.CoverageUnion"/>.
            </summary>
            <param name="geom">The geometry</param>
            <param name="pm">The precision model to use</param>
            <returns>The result of the union operation</returns>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.OverlayMixedPoints"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Noding.INoder)">
            <summary>
            Computes a union of a single geometry using a custom noder.
            <para/>
            The primary use of this is to support coverage union.
            Because of this the overlay is performed using strict mode.
            </summary>
            <param name="geom">The geometry to union</param>
            <param name="pm">The precision model to use (maybe be <c>null</c>)</param>
            <param name="noder">The noder to use</param>
            <returns>the result geometry</returns>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.CoverageUnion"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Creates an overlay operation on the given geometries,
            with a defined precision model.
            </summary>
            <param name="geom0">The A operand geometry</param>
            <param name="geom1">The B operand geometry (may be <c>null</c>)</param>
            <param name="pm">The precision model to use</param>
            <param name="opCode">The overlay opcode</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Creates an overlay operation on the given geometries
            using the precision model of the geometries.
            <para/>
            The noder is chosen according to the precision model specified.
            <list type="bullet">
            <item><description>For <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Fixed"/>
            a snap - rounding noder is used, and the computation is robust.</description></item>
            <item><description>For <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> a non - snapping noder is used,
            and this computation may not be robust.</description></item>
            If errors occur a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown.
            </list>
            </summary>
            <param name="geom0">The A operand geometry</param>
            <param name="geom1">The B operand geometry (may be <c>null</c>)</param>
            <param name="opCode">The overlay opcode</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates a union of a single geometry with a given precision model.
            </summary>
            <param name="geom">The geometry</param>
            <param name="pm">The precision model to use</param>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayNG.StrictMode">
            <summary>
            Gets or sets whether the overlay results are computed according to strict mode
            semantics.
            <list type="bullet">
            <item><description>Lines resulting from topology collapse are not included</description></item>
            <item><description>Result geometry is homogeneous for the
            <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/> and
            <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/> operations.</description></item>
            <item><description>Result geometry is homogeneous for the
            <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/> and
            <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/> operations if the inputs have the same dimension</description></item>
            </list>
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayNG.Optimized">
            <summary>
            Gets or sets a value indicating whether overlay processing optimizations are enabled.
            <para/>
            It may be useful to disable optimizations
            for testing purposes.
            <para/>
            Default is <c>true</c> (optimization enabled).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.OverlayNG.OverlayNG.AreaResultOnly">
            <summary>
            Gets or sets whether the result can contain only <see cref="T:NetTopologySuite.Geometries.Polygon"/> components.
            This is used if it is known that the result must be an (possibly empty) area.
            </summary>
            <returns><c>true</c> if the result should contain only area components</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.GetResult">
            <summary>
            Gets the result of the overlay operation.
            e</summary>
            <returns>The result of the overlay operation.</returns>
            <exception cref="T:System.ArgumentException">Thrown, if the input is not supported (e.g. a mixed-dimension geometry)</exception>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">Thrown, if a robustness error occurs</exception>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNG.ExtractResult(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Operation.OverlayNG.OverlayGraph)">
            <summary>
            Extracts the result geometry components from the fully labelled topology graph.
            <para/>
            This method implements the semantic that the result of an 
            intersection operation is homogeneous with highest dimension.  
            In other words, 
            if an intersection has components of a given dimension
            no lower-dimension components are output.
            For example, if two polygons intersect in an area, 
            no linestrings or points are included in the result, 
            even if portions of the input do meet in lines or points.
            This semantic choice makes more sense for typical usage, 
            in which only the highest dimension components are of interest.
            </summary>
            <param name="opCode">The overlay operation</param>
            <param name="graph">The topology graph</param>
            <returns>The result geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust">
            <summary>
            Performs an overlay operation using <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNG"/>,
            increasing robustness by using a series of
            increasingly robust (but slower) noding strategies.
            <para/>
            The noding strategies used are:
            <list type="number">
            <item><description>A simple fast noder using <see cref="F:NetTopologySuite.Geometries.PrecisionModels.Floating"/> precision</description></item>
            <item><description>A <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/> using an automatically-determined snap tolerance</description></item>
            <item><description>First snapping each geometry to itself, and then overlaying them wih a <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/></description></item>
            <item><description>The above two strategies are repeated with increasing snap tolerance, up to a limit</description></item>
            <item><description>Finally a <see cref="T:NetTopologySuite.Noding.Snapround.SnapRoundingNoder"/> is used with a automatically-determined scale factor.</description></item>
            </list>
            If all of the above heuristics fail to compute a valid overlay,
            the original <see cref="T:NetTopologySuite.Geometries.TopologyException"/> is thrown.
            In practice this should be extremely unlikely to occur.
            <para/>
            This algorithm relies on each overlay operation execution
            throwing a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> if it is unable
            to compute the overlay correctly.
            Generally this occurs because the noding phase does
            not produce a valid noding.
            This requires the use of a <see cref="T:NetTopologySuite.Noding.ValidatingNoder"/>
            in order to check the results of using a floating noder.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Union(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the unary union of a geometry using robust computation.
            </summary>
            <param name="geom">The geometry to union</param>
            <returns>The union result</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Computes the unary union of a collection of geometries using robust computation.
            </summary>
            <param name="geoms">An enumeration of geometries to union</param>
            <returns>The union result</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Computes the unary union of a collection of geometries using robust computation.
            </summary>
            <param name="geoms">An enumeration of geometries to union</param>
            <param name="geomFact">The geometry factory to use</param>
            <returns>The union of the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Overlay(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Overlay two geometries, using heuristics to ensure
            computation completes correctly.
            In practice the heuristics are observed to be fully correct.
            </summary>
            <param name="geom0">A geometry</param>
            <param name="geom1">A geometry</param>
            <param name="opCode">The overlay operation code</param>
            <returns>The overlay result geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.OverlaySnapTries(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Attempt overlay using snapping with repeated tries with increasing snap tolerances.
            </summary>
            <param name ="geom0"></param>
            <param name ="geom1"></param>
            <param name ="opCode"></param>
            <returns>The computed overlay result, or null if the overlay fails</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.OverlaySnapping(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,System.Double)">
            <summary>
            Attempt overlay using a <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/>.
            </summary>
            <param name="geom0"></param>
            <param name="geom1"></param>
            <param name="opCode"></param>
            <param name="snapTol"></param>
            <returns>The computed overlay result, or null if the overlay fails</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.OverlaySnapBoth(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,System.Double)">
            <summary>
            Attempt overlay with first snapping each geometry individually.
            </summary>
            <param name="geom0"></param>
            <param name="geom1"></param>
            <param name="opCode"></param>
            <param name="snapTol"></param>
            <returns>The computed overlay result, or null if the overlay fails</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.SnapSelf(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Self-snaps a geometry by running a union operation with it as the only input.
            This helps to remove narrow spike/gore artifacts to simplify the geometry,
            which improves robustness.
            Collapsed artifacts are removed from the result to allow using
            it in further overlay operations.
            </summary>
            <param name="geom">Geometry to self-snap</param>
            <param name="snapTol">Snap tolerance</param>
            <returns>The snapped geometry (homogenous)</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.SnapTolFactor">
            <summary>
            A factor for a snapping tolerance distance which
            should allow noding to be computed robustly.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.SnapTolerance(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a heuristic snap tolerance distance
            for overlaying a pair of geometries using a <see cref="T:NetTopologySuite.Noding.Snap.SnappingNoder"/>.
            </summary>
            <param name="geom0"></param>
            <param name="geom1"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.OrdinateMagnitude(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the largest magnitude of the ordinates of a geometry,
            based on the geometry envelope.
            </summary>
            <param name="geom"></param>
            <returns>The magnitude of the largest ordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.OverlaySR(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction)">
            <summary>
            Attempt Overlay using Snap-Rounding with an automatically-determined
            scale factor.
            </summary>
            <param name="geom0"></param>
            <param name="geom1"></param>
            <param name="opCode"></param>
            <returns>the computed overlay result, or null if the overlay fails</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayPoints">
            <summary>
            Performs an overlay operation on inputs which are both point geometries.
            <para/>
            Semantics are:
            <list type="bullet">
            <item><description>Points are rounded to the precision model if provided</description></item>
            <item><description>Points with identical XY values are merged to a single point</description></item>
            <item><description>Extended ordinate values are preserved in the output, apart from merging</description></item>
            <item><description>An empty result is returned as <c>POINT EMPTY</c></description></item>
            </list>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayPoints.Overlay(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Performs an overlay operation on inputs which are both point geometries.
            </summary>
            <param name="opCode">The code for the desired overlay operation</param>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="pm">The precision model to use</param>
            <returns>The result of the overlay operation</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayPoints.#ctor(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates an instance of an overlay operation on inputs which are both point geometries.
            </summary>
            <param name="opCode">The code for the desired overlay operation</param>
            <param name="geom0">The first geometry argument</param>
            <param name="geom1">The second geometry argument</param>
            <param name="pm">The precision model to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayPoints.GetResult">
            <summary>
            Gets the result of the overlay.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayPoints.RoundCoord(NetTopologySuite.Geometries.Point,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Round the key point if precision model is fixed.
            Note: return value is only copied if rounding is performed.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.OverlayUtility">
            <summary>
            Utility methods for overlay processing.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.IsFloating(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            A null-handling wrapper for <see cref="P:NetTopologySuite.Geometries.PrecisionModel.IsFloating"/>
            </summary>
            <param name="pm">A precision model</param>
            <returns><c>true</c> if the provided precision model is floating</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.ClippingEnvelope(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Operation.OverlayNG.InputGeometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Computes a clipping envelope for overlay input geometries.
            The clipping envelope encloses all geometry line segments which
            might participate in the overlay, with a buffer to
            account for numerical precision
            (in particular, rounding due to a precision model.
            The clipping envelope is used in both the <see cref="T:NetTopologySuite.Operation.OverlayNG.RingClipper"/>
            and in the <see cref="T:NetTopologySuite.Operation.OverlayNG.LineLimiter"/>.
            <para/>
            Some overlay operations (i.e. <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/> and <see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/>)
            cannot use clipping as an optimization,
            since the result envelope is the full extent of the two input geometries.
            In this case the returned
            envelope is <c>null</c> to indicate this.
            </summary>
            <param name="opCode">The overlay op code</param>
            <param name="inputGeom">The input geometries</param>
            <param name="pm">The precision model being used</param>
            <returns>An envelope for clipping and line limiting, or null if no clipping is performed</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.ResultEnvelope(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Operation.OverlayNG.InputGeometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Computes an envelope which covers the extent of the result of
            a given overlay operation for given inputs.
            The operations which have a result envelope smaller than the extent of the inputs
            are:
            <list type="bullet">
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/></term>
            <description>result envelope is the intersection of the input envelopes</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/></term>
            <description>result envelope is the envelope of the A input geometry</description></item>
            </list>
            Otherwise, <c>null</c> is returned to indicate full extent.
            </summary>
            <param name="opCode">The overlay op code</param>
            <param name="inputGeom">The input geometries</param>
            <param name="pm">The precision model being used</param>
            <returns>The result envelope, or null if the full extent</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.SafeEnv(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Determines a safe geometry envelope for clipping,
            taking into account the precision model being used.
            </summary>
            <param name="env">A safe geometry envelope for clipping</param>
            <param name="pm">The precision model</param>
            <returns>A safe envelope to use for clipping</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.IsEmptyResult(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Tests if the result can be determined to be empty
            based on simple properties of the input geometries
            (such as whether one or both are empty, 
            or their envelopes are disjoint).
            </summary>
            <param name="opCode">The overlay operation</param>
            <param name="a">The A operand geometry</param>
            <param name="b">The B operand geometry</param>
            <param name="pm">The precision model to use</param>
            <returns><c>true</c> if the overlay result is determined to be empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.IsEnvDisjoint(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Tests if the geometry envelopes are disjoint, or empty.
            The disjoint test must take into account the precision model
            being used, since geometry coordinates may shift under rounding.
            </summary>
            <param name="a">The A operand geometry</param>
            <param name="b">The B operand geometry</param>
            <param name="pm">The precision model to use</param>
            <returns><c>true</c> if the geometry envelopes are disjoint or empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.IsDisjoint(NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.Envelope,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Tests for disjoint envelopes adjusting for rounding
            caused by a fixed precision model.
            Assumes envelopes are non-empty.
            </summary>
            <param name="envA">The A operand envelope</param>
            <param name="envB">The B operand envelope</param>
            <param name="pm">The precision model to use</param>
            <returns><c>true</c> if the envelopes are disjoint</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.CreateEmptyResult(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an empty result geometry of the appropriate dimension,
            based on the given overlay operation and the dimensions of the inputs.
            The created geometry is an atomic geometry,
            not a collection(unless the dimension is <see cref="F:NetTopologySuite.Geometries.Dimension.Unknown"/>,
            in which case a <c>GEOMETRYCOLLECTION EMPTY</c> is created.
            </summary>
            <param name="dim">The dimension of the empty geometry</param>
            <param name="geomFact">The geometry factory being used for the operation</param>
            <returns>An empty atomic geometry of the appropriate dimension</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.ResultDimension(NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)">
            <summary>
            Computes the dimension of the result of
            applying the given operation to inputs
            with the given dimensions.
            This assumes that complete collapse does not occur.
            <para/>
            The result dimension is computed using the following rules:
            <list type="bullet">
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection"/></term><description>result has the dimension of the lowest input dimension</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Union"/></term><description>result has the dimension of the highest input dimension</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.Difference"/></term><description>result has the dimension of the left-hand input</description></item>
            <item><term><see cref="F:NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference"/></term><description>result has the dimension of the highest input dimension
            (since the Symmetric Difference is the Union of the Differences).</description></item>
            </list>
            </summary>
            <param name="opCode">The overlay operation</param>
            <param name="dim0">Dimension of the LH input</param>
            <param name="dim1">Dimension of the RH input</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.CreateResultGeometry(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Polygon},System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.LineString},System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Point},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates an overlay result geometry for homogeneous or mixed components.
            </summary>
            <param name="resultPolyList">An enumeration of result polygons (may be empty or <c>null</c>)</param>
            <param name="resultLineList">An enumeration of result lines (may be empty or <c>null</c>)</param>
            <param name="resultPointList">An enumeration of result points (may be empty or <c>null</c>)</param>
            <param name="geometryFactory">The geometry factory to use.</param>
            <returns>A geometry structured according to the overlay result semantics</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.Round(NetTopologySuite.Geometries.Point,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Round the key point if precision model is fixed.
            Note: return value is only copied if rounding is performed.
            </summary>
            <param name="pt">The point to round</param>
            <param name="pm">The precision model to use</param>
            <returns>The rounded point coordinate, or null if empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.OverlayUtility.IsResultAreaConsistent(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Overlay.SpatialFunction,NetTopologySuite.Geometries.Geometry)">
            <summary>
            A heuristic check for overlay result correctness
            comparing the areas of the input and result.
            The heuristic is necessarily coarse, but it detects some obvious issues.<br/>
            (e.g. <a href="https://github.com/locationtech/jts/issues/798"/>)
            <para/>
            <b>Note:</b> - this check is only safe if the precision model is floating.
            It should also be safe for snapping noding if the distance tolerance is reasonably small.
            (Fixed precision models can lead to collapse causing result area to expand.)
            </summary>
            <param name="geom0">Input geometry 0</param>
            <param name="geom1">Input geometry 1</param>
            <param name="opCode">The overlay opcode</param>
            <param name="result">The overlay result</param>
            <returns><c>true</c> if the result area is consistent</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PolygonBuilder.BuildMaximalRings(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdge})">
            <summary>
            For all OverlayEdges in result, form them into MaximalEdgeRings
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PolygonBuilder.FindSingleShell(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing})">
            <summary>
            Finds the single shell, if any, out of 
            a list of minimal rings derived from a maximal ring.
            The other possibility is that they are a set of (connected) holes, 
            in which case no shell will be found.
            </summary>
            <returns>The shell ring, if there is one
            or <c>null</c>, if all rings are holes
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PolygonBuilder.AssignHoles(NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing,System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing})">
            <summary>
            For the set of minimal rings comprising a maximal ring, 
            assigns the holes to the shell known to contain them.
            Assigning the holes directly to the shell serves two purposes:
            <list type="bullet">
            <item><description>it is faster than using a point-in-polygon check later on.</description></item>
            <item><description>it ensures correctness, since if the PIP test was used the point
            chosen might lie on the shell, which might return an incorrect result from the
            PIP test</description></item>
            </list>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PolygonBuilder.PlaceFreeHoles(System.Collections.Generic.IReadOnlyCollection{NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing},System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing})">
            <summary>
            Place holes have not yet been assigned to a shell.
            These "free" holes should
            all be <b>properly</b> contained in their parent shells, so it is safe to use the
            <c>findEdgeRingContaining</c> method.
            (This is the case because any holes which are NOT
            properly contained (i.e. are connected to their
            parent shell) would have formed part of a MaximalEdgeRing
            and been handled in a previous step).
            </summary>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If a hole cannot be assigned to a shell</exception>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.PrecisionReducer">
            <summary>
            Functions to reduce the precision of a geometry
            by rounding it to a given precision model.
            <para/>
            This class handles only polygonal and linear inputs.
            For full functionality <see cref="T:NetTopologySuite.Precision.GeometryPrecisionReducer"/>.
            </summary>
            <seealso cref="T:NetTopologySuite.Precision.GeometryPrecisionReducer"/>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionReducer.ReducePrecision(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Reduces the precision of a geometry by rounding and snapping it to the
            supplied <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.<br/>
            The input geometry must be polygonal or linear.
            <para/> 
            The output is always a valid geometry.  This implies that input components
            may be merged if they are closer than the grid precision.
            if merging is not desired, then the individual geometry components
            should be processed separately.
            <para/>
            The output is fully noded (i.e. coincident lines are merged and noded).  
            This provides an effective way to node / snap-round a collection of <see cref="T:NetTopologySuite.Geometries.LineString"/>s.
            </summary>
            <param name="geom">The geometry to reduce</param>
            <param name="pm">The precision model to use</param>
            <returns>The precision-reduced geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.PrecisionUtility">
            <summary>
            Functions for computing precision model scale factors
            that ensure robust geometry operations.
            In particular, these can be used to
            automatically determine appropriate scale factors for operations 
            using limited-precision noding (such as <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNG"/>).
            <para/>
            WARNING: the <c>inherentScale</c> and <c>robustScale</c> 
            functions can be very slow, due to the method used to determine
            number of decimal places of a number.
            These are not recommended for production use.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="F:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.MAX_ROBUST_DP_DIGITS">
            <summary>
            A number of digits of precision which leaves some computational "headroom"
            to ensure robust evaluation of certain double-precision floating point geometric operations.
            <para/>
            This value should be less than the maximum decimal precision of double-precision values (16).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.SafeScale(System.Double)">
            <summary>
            Computes a safe scale factor for a numeric value.
            A safe scale factor ensures that rounded 
            number has no more than <see cref="F:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.MAX_ROBUST_DP_DIGITS"/> 
            digits of precision.
            </summary>
            <param name="value">A numeric value.</param>
            <returns>A safe scale factor for the value</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.SafeScale(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a safe scale factor for a geometry.
            A safe scale factor ensures that rounded 
            number has no more than <see cref="F:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.MAX_ROBUST_DP_DIGITS"/> 
            digits of precision.
            </summary>
            <param name="geom">A geometry.</param>
            <returns>A safe scale factor for the geometry ordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.SafeScale(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a safe scale factor for two geometry.
            A safe scale factor ensures that rounded 
            number has no more than <see cref="F:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.MAX_ROBUST_DP_DIGITS"/> 
            digits of precision.
            </summary>
            <param name="a">A geometry.</param>
            <param name="b">A geometry (which may be <c>null</c>).</param>
            <returns>A safe scale factor for the geometry ordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.MaxBoundMagnitude(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Determines the maximum magnitude (absolute value) of the bounds of an
            of an envelope.
            This is equal to the largest ordinate value
            which must be accommodated by a scale factor.
            </summary>
            <param name="env">An envelope</param>
            <returns>The value of the maximum bound magnitude</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.PrecisionScale(System.Double,System.Int32)">
            <summary>
            Computes the scale factor which will
            produce a given number of digits of precision(significant digits)
            when used to round the given number.
            <para/>
            For example: to provide 5 decimal digits of precision
            for the number 123.456 the precision scale factor is 100;
            for 3 digits of precision the scale factor is 1;
            for 2 digits of precision the scale factor is 0.1. 
            <para/>
            Rounding to the scale factor can be performed with <see cref="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(System.Double)"/>
            </summary>
            <param name="value">A number to be rounded</param>
            <param name="precisionDigits">The number of digits of precision required</param>
            <returns>The scale factor which provides the required number of digits of precision</returns>
            <seealso cref="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.InherentScale(System.Double)">
            <summary>
            Computes the inherent scale of a number.
            The inherent scale is the scale factor for rounding
            which preserves <b>all</b> digits of precision 
            (significant digits)
            present in the numeric value.
            In other words, it is the scale factor which does not
            change the numeric value when rounded:
            <code>
              num = round( num, inherentScale(num) )
            </code>
            </summary>
            <param name="value">A number</param>
            <returns>The inherent scale factor of the number</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.InherentScale(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the inherent scale of a geometry.
            The inherent scale is the scale factor for rounding
            which preserves <b>all</b> digits of precision 
            (significant digits)
            present in the geometry ordinates.
            <para/>
            This is the maximum inherent scale
            of all ordinate values in the geometry.
            <para/>
            WARNING: this is <b>very</b> slow.
            </summary>
            <param name="geom">A geometry</param>
            <returns>The inherent scale factor in the geometry's ordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.InherentScale(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the inherent scale of two geometries.
            The inherent scale is the scale factor for rounding
            which preserves <b>all</b> digits of precision 
            (significant digits)
            present in the geometry ordinates.
            <para/>
            This is the maximum inherent scale
            of all ordinate values in the geometries.
            </summary>
            <param name="a">A geometry</param>
            <param name="b">A geomety (which may be <c>null</c>)</param>
            <returns>The inherent scale factor in the geometries' ordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.NumberOfDecimals(System.Double)">
            <summary>
            Determines the 
            number of decimal places represented in a double-precision
            number (as determined by .NET).
            This uses the .NET double-precision print routine 
            to determine the number of decimal places,
            This is likely not optimal for performance, 
            but should be accurate and portable. 
            </summary>
            <param name="value">A numeric value</param>
            <returns>The number of decimal places in the value</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.InherentScaleFilter">
            <summary>
            Applies the inherent scale calculation 
            to every ordinate in a geometry.
            <para/>
            WARNING: this is <b>very</b> slow.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.RobustPM(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines a precision model to
            use for robust overlay operations for one geometry.
            The precision scale factor is chosen to maximize
            output precision while avoiding round-off issues.
            <para/>
            NOTE: this is a heuristic determination, so is not guaranteed to
            eliminate precision issues.
            <para/>
            WARNING: this is <b>very</b> slow.
            </summary>
            <param name="a">A geometry</param>
            <returns>A suitable precision model for overlay</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.RobustScale(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines a scale factor which maximizes
            the digits of precision and is
            safe to use for overlay operations.
            The robust scale is the minimum of the
            inherent scale and the safe scale factors.
            <para/>
            WARNING: this is <b>very</b> slow.
            </summary>
            <param name="a">A geometry</param>
            <param name="b">A geometry</param>
            <returns>A scale factor for use in overlay operations</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.PrecisionUtility.RobustScale(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Determines a scale factor which maximizes
            the digits of precision and is
            safe to use for overlay operations.
            The robust scale is the minimum of the
            inherent scale and the safe scale factors.
            </summary>
            <param name="a">A geometry</param>
            <returns>A scale factor for use in overlay operations</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.RingClipper">
            <summary>
            Clips a ring of points to an rectangle.
            Uses a variant of Cohen-Sutherland clipping.
            <para/>
            In general the output is not topologically valid.
            In particular, the output may contain coincident non-noded line segments
            along the clip rectangle sides.
            However, the output is sufficiently well-structured
            that it can be used as input to the <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNG"/> algorithm
            (which is able to process coincident linework due
            to the need to handle topology collapse under precision reduction).
            <para/>
            Because of the likelihood of creating
            extraneous line segments along the clipping rectangle sides,
            this class is not suitable for clipping linestrings.
            <para/>
            The clipping envelope should be generated using <see cref="T:NetTopologySuite.Operation.OverlayNG.RobustClipEnvelopeComputer"/>,
            to ensure that intersecting line segments are not perturbed
            by clipping.
            This is required to ensure that the overlay of the
            clipped geometry is robust and correct (i.e. the same as
            if clipping was not used).
            </summary>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.LineLimiter"/>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.RingClipper.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates a new clipper for the given envelope.
            </summary>
            <param name="clipEnv">The clipping envelope</param>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.RingClipper.Clip(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Clips a list of points to the clipping rectangle box.
            </summary>
            <param name="pts">The points of the ring</param>
            <returns>The points of the clipped ring</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.RingClipper.ClipToBoxEdge(NetTopologySuite.Geometries.Coordinate[],System.Int32,System.Boolean)">
            <summary>
            Clips line to the axis-parallel line defined by a single box edge.
            </summary>
            <param name="pts">The coordinates</param>
            <param name="edgeIndex">An edge index</param>
            <param name="closeRing">A flag indicating whether to close the ring.</param>
            <returns>The clipped coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.RingClipper.Intersection(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Int32)">
            <summary>
            Computes the intersection point of a segment
            with an edge of the clip box.
            The segment must be known to intersect the edge.
            </summary>
            <param name="a">First endpoint of the segment</param>
            <param name="b">Second endpoint of the segment</param>
            <param name="edgeIndex">Index of box edge</param>
            <returns>
            The intersection point with the box edge
            </returns>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.RobustClipEnvelopeComputer">
            <summary>
            Computes a robust clipping envelope for a pair of polygonal geometries.
            The envelope is computed to be large enough to include the full
            length of all geometry line segments which intersect
            a given target envelope.
            This ensures that line segments which might intersect are
            not perturbed when clipped using <see cref="T:NetTopologySuite.Operation.OverlayNG.RingClipper"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.RobustClipEnvelopeComputer.AddPolygonRing(NetTopologySuite.Geometries.LineString)">
            <summary>
            Adds a polygon ring to the graph. Empty rings are ignored.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.OverlayNG.UnaryUnionNG">
            <summary>
            Unions a collection of geometries in an
            efficient way, using <see cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNG"/>
            to ensure robust computation.
            <para/>
            This class is most useful for performing UnaryUnion using
            a fixed-precision model.<br/>
            For unary union using floating precision,
            <see cref="M:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Union(NetTopologySuite.Geometries.Geometry)"/> should be used.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Unions a geometry (which is often a collection)
            using a given precision model.
            </summary>
            <param name="geom">The geometry to union</param>
            <param name="pm">The precision model to use</param>
            <returns>The union of the geometry</returns>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Unions a geometry (which is often a collection)
            using a given precision model.
            </summary>
            <param name="geoms">The geometries to union</param>
            <param name="pm">The precision model to use</param>
            <returns>The union of the geometries</returns>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust"/>
        </member>
        <member name="M:NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.GeometryFactory,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Unions a geometry (which is often a collection)
            using a given precision model.
            </summary>
            <param name="geoms">The geometries to union</param>
            <param name="geomFact">The geometry factory to use</param>
            <param name="pm">The precision model to use</param>
            <returns>The union of the geometries</returns>
            <seealso cref="T:NetTopologySuite.Operation.OverlayNG.OverlayNGRobust"/>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.EdgeRing">
            <summary>
            Represents a ring of <see cref="T:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge"/>s which form
            a ring of a polygon.  The ring may be either an outer shell or a hole.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.FindEdgeRingContaining(NetTopologySuite.Operation.Polygonize.EdgeRing,System.Collections.Generic.IList{NetTopologySuite.Operation.Polygonize.EdgeRing})">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B if envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            <para/>
            To improve performance of this function the caller should
            make the passed shellList as small as possible(e.g.
            by using a spatial index filter beforehand).
            </summary>
            <param name="erList"></param>
            <param name="testEr"></param>
            <returns>Containing EdgeRing, if there is one <br/>
            or <c>null</c> if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.FindDirEdgesInRing(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge)">
            <summary>
            Traverses a ring of DirectedEdges, accumulating them into a list.
            This assumes that all dangling directed edges have been removed
            from the graph, so that there is always a next dirEdge.
            </summary>
            <param name="startDE">The DirectedEdge to start traversing at</param>
            <returns>A list of DirectedEdges that form a ring</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
             <summary>
            
             </summary>
             <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.Add(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Adds a DirectedEdge which is known to form part of this ring.
            </summary>
            <param name="de">The DirectedEdge to add.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.IsHole">
            <summary>
            Tests whether this ring is a hole.
            Due to the way the edges in the polygonization graph are linked,
            a ring is a hole if it is oriented counter-clockwise.
            </summary>
            <returns><c>true</c> if this ring is a hole.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.ComputeHole">
            <summary>
            Computes whether this ring is a hole.
            Due to the way the edges in the polygonization graph are linked,
            a ring is a hole if it is oriented counter-clockwise.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.AddHole(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Adds a hole to the polygon formed by this ring.
            </summary>
            <param name="hole">The LinearRing forming the hole.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.AddHole(NetTopologySuite.Operation.Polygonize.EdgeRing)">
            <summary>
            Adds a hole to the polygon formed by this ring.
            </summary>
            <param name="holeER">the <see cref="T:NetTopologySuite.Geometries.LinearRing"/> forming the hole.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.Polygon">
            <summary>
            Computes and returns the Polygon formed by this ring and any contained holes.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.IsValid">
            <summary>
            Tests if the <see cref="T:NetTopologySuite.Geometries.LinearRing" /> ring formed by this edge ring is topologically valid.
            </summary>
            <return>true if the ring is valid.</return>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.Coordinates">
            <summary>
            Computes and returns the list of coordinates which are contained in this ring.
            The coordinates are computed once only and cached.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.LineString">
            <summary>
            Gets the coordinates for this ring as a <c>LineString</c>.
            Used to return the coordinates in this ring
            as a valid point, when it has been detected that the ring is topologically
            invalid.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.Ring">
            <summary>
            Returns this ring as a LinearRing, or null if an Exception occurs while
            creating it (such as a topology problem).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.AddEdge(NetTopologySuite.Geometries.Coordinate[],System.Boolean,NetTopologySuite.Geometries.CoordinateList)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="isForward"></param>
             <param name="coordList"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.Shell">
            <summary>
            Gets or sets a value indicating the containing shell ring of a ring that has been determined to be a hole.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.HasShell">
            <summary>
            Gets a value indicating whether this ring has a shell assigned to it.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.IsOuterHole">
            <summary>
            Tests whether this ring is an outer hole.
            A hole is an outer hole if it is not contained by a shell.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.IsOuterShell">
            <summary>
            Tests whether this ring is an outer shell.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.OuterHole">
            <summary>
            Gets the outer hole of a shell, if it has one.
            An outer hole is one that is not contained
            in any other shell.
            Each disjoint connected group of shells
            is surrounded by an outer hole.
            </summary>
            <returns>The outer hole edge ring, or <c>null</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.UpdateIncluded">
            <summary>
            Updates the included status for currently non-included shells
            based on whether they are adjacent to an included shell.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing.ToString">
            <summary>
            Gets a string representation of this object.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing.IsProcessed">
            <summary>
            Gets or sets a value indicating whether this ring has been processed.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeComparator">
            <summary>
            Compares EdgeRings based on their envelope,
            using the standard lexicographic ordering.
            This ordering is sufficient to make edge ring sorting deterministic.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.HoleAssigner">
            <summary>
            Assigns hole rings to shell rings
            during polygonization.
            Uses spatial indexing to improve performance
            of shell lookup.
            </summary>
            <author>mdavis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.HoleAssigner.AssignHolesToShells(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.EdgeRing},System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.EdgeRing})">
            <summary>
            Assigns hole rings to shell rings.
            </summary>
            <param name="holes">An enumeration of hole rings to assign</param>
            <param name="shells">An enumeration of shell rings</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.HoleAssigner.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.EdgeRing})">
            <summary>
            Creates a new hole assigner.
            </summary>
            <param name="shells">An enumeration of shell rings to assign holes to</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.HoleAssigner.AssignHolesToShells(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.EdgeRing})">
            <summary>
            Assigns holes to the shells.
            </summary>
            <param name="holes">An enumeration of holes to assign to shells</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.HoleAssigner.FindShellContaining(NetTopologySuite.Operation.Polygonize.EdgeRing)">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            <list type="Bullet">
            <item><term>ring A contains ring B if envelope(ring A) contains envelope(ring B)</term></item>
            </list>
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell)
            </summary>
            <param name="testER">An edge ring to test</param>
            <returns>
            The containing shell EdgeRing, if there is one
            or <c>null</c> if no containing EdgeRing is found
            </returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge">
            <summary>
            A <c>DirectedEdge</c> of a <c>PolygonizeGraph</c>, which represents
            an edge of a polygon formed by the graph.
            May be logically deleted from the graph by setting the <c>marked</c> flag.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.#ctor(NetTopologySuite.Planargraph.Node,NetTopologySuite.Planargraph.Node,NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Constructs a directed edge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.Label">
            <summary>
            Returns the identifier attached to this directed edge.
            Attaches an identifier to this directed edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.Next">
            <summary>
            Returns the next directed edge in the EdgeRing that this directed edge is a member of.
            Sets the next directed edge in the EdgeRing that this directed edge is a member of.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.IsInRing">
            <summary>
            Returns the ring of directed edges that this directed edge is
            a member of, or null if the ring has not been set.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.Ring">
            <summary>
            Gets/Sets the ring of directed edges that this directed edge is
            a member of.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeEdge">
            <summary>
            An edge of a polygonization graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeEdge.#ctor(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeEdge.Line">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeGraph">
            <summary>
            Represents a planar graph of edges that can be used to compute a
            polygonization, and implements the algorithms to compute the
            <see cref="T:NetTopologySuite.Operation.Polygonize.EdgeRing"/>s formed by the graph.
            The marked flag on DirectedEdges is used to indicate that a directed edge
            has be logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.GetDegreeNonDeleted(NetTopologySuite.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.GetDegree(NetTopologySuite.Planargraph.Node,System.Int64)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="label"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.DeleteAllEdges(NetTopologySuite.Planargraph.Node)">
            <summary>
            Deletes all edges at a node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create a new polygonization graph.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.AddEdge(NetTopologySuite.Geometries.LineString)">
            <summary>
            Add a <c>LineString</c> forming an edge of the polygon graph.
            </summary>
            <param name="line">The line to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.GetNode(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ComputeNextCWEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ConvertMaximalToMinimalEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge})">
            <summary>
            Convert the maximal edge rings found by the initial graph traversal
            into the minimal edge rings required by NTS polygon topology rules.
            </summary>
            <param name="ringEdges">The list of start edges for the edgeRings to convert.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.FindIntersectionNodes(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge,System.Int64)">
            <summary>
            Finds all nodes in a maximal edgering which are self-intersection nodes
            </summary>
            <param name="startDE"></param>
            <param name="label"></param>
            <returns>
            The list of intersection nodes found,
            or null if no intersection nodes were found.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.GetEdgeRings">
            <summary>
            Computes the minimal EdgeRings formed by the edges in this graph.
            </summary>
            <returns>A list of the{EdgeRings found by the polygonization process.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.FindLabeledEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge})">
            <summary>
            Finds and labels all edgerings in the graph.
            The edge rings are labeling with unique integers.
            The labeling allows detecting cut edges.
            </summary>
            <param name="dirEdges">A List of the DirectedEdges in the graph.</param>
            <returns>A List of DirectedEdges, one for each edge ring found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.DeleteCutEdges">
            <summary>
            Finds and removes all cut edges from the graph.
            </summary>
            <returns>A list of the <c>LineString</c>s forming the removed cut edges.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.Label(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge},System.Int64)">
             <summary>
            
             </summary>
             <param name="dirEdges"></param>
             <param name="label"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ComputeNextCWEdges(NetTopologySuite.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ComputeNextCCWEdges(NetTopologySuite.Planargraph.Node,System.Int64)">
            <summary>
            Computes the next edge pointers going CCW around the given node, for the
            given edgering label.
            This algorithm has the effect of converting maximal edgerings into minimal edgerings
            </summary>
            <param name="node"></param>
            <param name="label"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.FindEdgeRing(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge)">
             <summary>
            
             </summary>
             <param name="startDE"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.DeleteDangles">
            <summary>
            Marks all edges from the graph which are "dangles".
            Dangles are which are incident on a node with degree 1.
            This process is recursive, since removing a dangling edge
            may result in another edge becoming a dangle.
            In order to handle large recursion depths efficiently,
            an explicit recursion stack is used.
            </summary>
            <returns>A List containing the <see cref="T:NetTopologySuite.Geometries.LineString"/>s that formed dangles.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ComputeDepthParity">
             <summary>
             Traverses the polygonized edge rings in the graph
             and computes the depth parity (odd or even)
             relative to the exterior of the graph.
            
             If the client has requested that the output
             be polygonally valid, only odd polygons will be constructed.
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph.ComputeDepthParity(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge)">
            <summary>
            Traverses all connected edges, computing the depth parity of the associated polygons.
            </summary>
            <param name="de"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.Polygonizer">
             <summary>
             Polygonizes a set of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s which contain linework that
             represents the edges of a planar graph.
             </summary>
             <remarks>
             <para>All types of Geometry are accepted as input;
             the constituent linework is extracted as the edges to be polygonized.
             The processed edges must be correctly noded; that is, they must only meet
             at their endpoints. Polygonization will accept incorrectly noded input
             but will not form polygons from non-noded edges,
             and reports them as errors.
             </para><para>
             The Polygonizer reports the follow kinds of errors:
             <list type="Table">
             <item><term><see cref="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetDangles"/>Dangles</term><description>edges which have one or both ends which are not incident on another edge endpoint</description></item>
             <item><term><see cref="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetCutEdges"/></term><description>edges which are connected at both ends but which do not form part of polygon</description></item>
             <item><term><see cref="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetInvalidRingLines"/></term><description>edges which form rings which are invalid
             (e.g. the component lines contain a self-intersection)</description>
             </item></list>
             </para>
             <para>
             The <see cref="M:NetTopologySuite.Operation.Polygonize.Polygonizer.#ctor(System.Boolean)"/> constructor allows
             extracting only polygons which form a valid polygonal result.
             The set of extracted polygons is guaranteed to be edge-disjoint.
             This is useful for situations where it is known that the input lines form a
             valid polygonal geometry (which may include holes or nested polygons).</para>
             </remarks>
            
        </member>
        <member name="F:NetTopologySuite.Operation.Polygonize.Polygonizer.AllPolys">
            <summary>
            The default polygonizer output behavior
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.Polygonizer.LineStringAdder">
            <summary>
            Adds every linear element in a <see cref="T:NetTopologySuite.Geometries.Geometry"/> into the polygonizer graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.LineStringAdder.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Filters all <see cref="T:NetTopologySuite.Geometries.LineString"/> geometry instances
            </summary>
            <param name="g">The geometry instance</param>
        </member>
        <member name="F:NetTopologySuite.Operation.Polygonize.Polygonizer._lineStringAdder">
            <summary>
            Default linestring adder.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.Polygonizer.IsCheckingRingsValid">
            <summary>
            Allows disabling the valid ring checking,
            to optimize situations where invalid rings are not expected.
            </summary>
            <remarks>The default is <c>true</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.#ctor">
            <summary>
            Creates a polygonizer that extracts all polygons.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.#ctor(System.Boolean)">
            <summary>
            Creates a polygonizer, specifying whether a valid polygonal geometry must be created.
            If the argument is <c>true</c>
            then areas may be discarded in order to 
            ensure that the extracted geometry is a valid polygonal geometry.
            </summary>
            <param name="extractOnlyPolygonal"><c>true</c> if a valid polygonal geometry should be extracted</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.Add(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Adds a collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used.
            </summary>
            <param name="geomList">A list of <c>Geometry</c>s with linework to be polygonized.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds a <see cref="T:NetTopologySuite.Geometries.Geometry"/> to the linework to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used
            </summary>
            <param name="g">A <c>Geometry</c> with linework to be polygonized.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.Add(NetTopologySuite.Geometries.LineString)">
            <summary>
            Adds a  to the graph of polygon edges.
            </summary>
            <param name="line">The <see cref="T:NetTopologySuite.Geometries.LineString"/> to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetPolygons">
            <summary>
            Gets the list of polygons formed by the polygonization.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetGeometry">
            <summary>
            Gets a geometry representing the polygons formed by the polygonization.
            If a valid polygonal geometry was extracted the result is a <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometry.
            </summary>
            <returns>A geometry containing the polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetDangles">
            <summary>
            Gets the list of dangling lines found during polygonization.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetCutEdges">
            <summary>
            Gets the list of cut edges found during polygonization.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.GetInvalidRingLines">
            <summary>
            Gets the list of lines forming invalid rings found during polygonization.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.Polygonize">
            <summary>
            Performs the polygonization, if it has not already been carried out.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer.FindOuterShells(System.Collections.Generic.List{NetTopologySuite.Operation.Polygonize.EdgeRing})">
            <summary>
            For each outer hole finds and includes a single outer shell.
            This seeds the traversal algorithm for finding only polygonal shells.
            </summary>
            <param name="shellList">The list of shell EdgeRings</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.RectangleContains">
            <summary>
            Optimized implementation of spatial predicate "contains"
            for cases where the first <c>Geometry</c> is a rectangle.
            As a further optimization,
            this class can be used directly to test many geometries against a single rectangle.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.Contains(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.#ctor(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Create a new contains computer for two geometries.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.Contains(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.IsContainedInBoundary(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.IsPointContainedInBoundary(NetTopologySuite.Geometries.Point)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.IsPointContainedInBoundary(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point is contained in the boundary of the target rectangle.
            </summary>
            <param name="pt">the point to test</param>
            <returns>true if the point is contained in the boundary</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.IsLineStringContainedInBoundary(NetTopologySuite.Geometries.LineString)">
            <summary>
            Tests if a linestring is completely contained in the boundary of the target rectangle.
            </summary>
            <param name="line">the linestring to test</param>
            <returns>true if the linestring is contained in the boundary</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains.IsLineSegmentContainedInBoundary(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a line segment is contained in the boundary of the target rectangle.
            </summary>
            <param name="p0">an endpoint of the segment</param>
            <param name="p1">an endpoint of the segment</param>
            <returns>true if the line segment is contained in the boundary</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.RectangleIntersects">
            <summary>I
            Implementation of the <tt>Intersects</tt> spatial predicate
            optimized for the case where one <see cref="T:NetTopologySuite.Geometries.Geometry"/> is a rectangle.
            </summary>
            <remarks>
            This class works for all input geometries, including <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s.
            <para/>
            As a further optimization, this class can be used in batch style
            to test many geometries against a single rectangle.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Operation.Predicate.RectangleIntersects.MaximumScanSegmentCount">
            <summary>
            Crossover size at which brute-force intersection scanning
            is slower than indexed intersection detection.
            Must be determined empirically.  Should err on the
            safe side by making value smaller rather than larger.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleIntersects.Intersects(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether a rectangle intersects a given geometry.
            </summary>
            <param name="rectangle">A rectangular polygon</param>
            <param name="b">A geometry of any kind</param>
            <returns><c>true</c> if the geometries intersect.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleIntersects.#ctor(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Create a new intersects computer for a rectangle.
            </summary>
            <param name="rectangle">A rectangular polygon.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleIntersects.Intersects(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether the given Geometry intersects the query rectangle.
            </summary>
            <param name="geom">The Geometry to test (may be of any type)</param>
            <returns><c>true</c> if an intersection must occur
            or <c>false</c> if no conclusion about intersection can be made</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor">
            <summary>
            Tests whether it can be concluded that a rectangle intersects a geometry,
            based on the relationship of the envelope(s) of the geometry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor.#ctor(NetTopologySuite.Geometries.Envelope)">
            <summary>
            Creates an instance of this class using the provided <c>Envelope</c>
            </summary>
            <param name="rectEnv">The query envelope</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor.Intersects">
            <summary>
            Reports whether it can be concluded that an intersection occurs,
            or whether further testing is required.
            </summary>
            <returns><c>true</c> if an intersection must occur <br/>
            or <c>false</c> if no conclusion about intersection can be made</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor.Visit(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="element"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor">
            <summary>
            A visitor which tests whether it can be
            concluded that a geometry contains a vertex of
            a query geometry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor.#ctor(NetTopologySuite.Geometries.Polygon)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor.ContainsPoint">
            <summary>
            Gets a value indicating whether it can be concluded that a corner point of the rectangle is
            contained in the geometry, or whether further testing is required.
            </summary>
            <returns><c>true</c> if a corner point is contained
            or <c>false</c> if no conclusion about intersection can be made
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor.Visit(NetTopologySuite.Geometries.Geometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.RectangleIntersectsSegmentVisitor">
            <summary>
            A visitor to test for intersection between the query rectangle and the line segments of the geometry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleIntersectsSegmentVisitor.#ctor(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Creates a visitor for checking rectangle intersection with segments
            </summary>
            <param name="rectangle">the query rectangle </param>
        </member>
        <member name="P:NetTopologySuite.Operation.Predicate.RectangleIntersectsSegmentVisitor.Intersects">
            <summary>Reports whether any segment intersection exists.</summary>
            <returns>true if a segment intersection exists or
            false if no segment intersection exists</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.SegmentIntersectionTester">
            <summary>
            Tests if any line segments in two sets of <see cref="T:NetTopologySuite.Geometries.CoordinateSequences"/> intersect.
            Optimized for use when at least one input is of small size.
            Short-circuited to return as soon an intersection is found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.SegmentIntersectionTester.HasIntersectionWithLineStrings(NetTopologySuite.Geometries.CoordinateSequence,System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
             <summary>
            
             </summary>
             <param name="seq"></param>
             <param name="lines"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.SegmentIntersectionTester.HasIntersection(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.CoordinateSequence)">
             <summary>
            
             </summary>
             <param name="seq0"></param>
             <param name="seq1"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBuilder">
            <summary>
            An EdgeEndBuilder creates EdgeEnds for all the "split edges"
            created by the intersections determined for an Edge.
            Computes the <c>EdgeEnd</c>s which arise from a noded <c>Edge</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge})">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(NetTopologySuite.GeometriesGraph.Edge,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeEnd})">
            <summary>
            Creates stub edges for all the intersections in this
            Edge (if any) and inserts them into the graph.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForPrev(NetTopologySuite.GeometriesGraph.Edge,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeEnd},NetTopologySuite.GeometriesGraph.EdgeIntersection,NetTopologySuite.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a EdgeStub for the edge before the intersection eiCurr.
            The previous intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the previous point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiPrev may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiPrev"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForNext(NetTopologySuite.GeometriesGraph.Edge,System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeEnd},NetTopologySuite.GeometriesGraph.EdgeIntersection,NetTopologySuite.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a StubEdge for the edge after the intersection eiCurr.
            The next intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the next point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiNext may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiNext"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBundle">
            <summary>
            A collection of EdgeStubs which obey the following invariant:
            They originate at the same node and have the same direction.
            Contains all <c>EdgeEnd</c>s which start at the same point and are parallel.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.#ctor(NetTopologySuite.Algorithm.IBoundaryNodeRule,NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="boundaryNodeRule"></param>
             <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Relate.EdgeEndBundle.EdgeEnds">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.ComputeLabel(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            This computes the overall edge label for the set of
            edges in this EdgeStubBundle.  It essentially merges
            the ON and side labels for each edge.
            These labels must be compatible
            </summary>
            <param name="boundaryNodeRule"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.ComputeLabelOn(System.Int32,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Compute the overall ON location for the list of EdgeStubs.
            (This is essentially equivalent to computing the self-overlay of a single Geometry)
            edgeStubs can be either on the boundary (e.g. Polygon edge)
            OR in the interior (e.g. segment of a LineString)
            of their parent Geometry.
            In addition, GeometryCollections use the <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> to determine
            whether a segment is on the boundary or not.
            Finally, in GeometryCollections it can occur that an edge is both
            on the boundary and in the interior (e.g. a LineString segment lying on
            top of a Polygon edge.) In this case the Boundary is given precedence.
            These observations result in the following rules for computing the ON location:
             if there are an odd number of Bdy edges, the attribute is Bdy
             if there are an even number >= 2 of Bdy edges, the attribute is Int
             if there are any Int edges, the attribute is Int
             otherwise, the attribute is Null.
            </summary>
            <param name="geomIndex"></param>
            <param name="boundaryNodeRule"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.ComputeLabelSides(System.Int32)">
            <summary>
            Compute the labelling for each side
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.ComputeLabelSide(System.Int32,NetTopologySuite.Geometries.Position)">
            <summary>
            To compute the summary label for a side, the algorithm is:
            FOR all edges
            IF any edge's location is Interior for the side, side location = Interior
            ELSE IF there is at least one Exterior attribute, side location = Exterior
            ELSE  side location = Null
            Note that it is possible for two sides to have apparently contradictory information
            i.e. one edge side may indicate that it is in the interior of a point, while
            another edge side may indicate the exterior of the same point.  This is
            not an incompatibility - GeometryCollections may contain two Polygons that touch
            along an edge.  This is the reason for Interior-primacy rule above - it
            results in the summary label having the Geometry interior on both sides.
            </summary>
            <param name="geomIndex"></param>
            <param name="side"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.UpdateIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the computed label for the EdgeStubs.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBundleStar">
            <summary>
            An ordered list of <c>EdgeEndBundle</c>s around a <c>RelateNode</c>.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundleStar.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a EdgeEnd in order in the list.
            If there is an existing EdgeStubBundle which is parallel, the EdgeEnd is
            added to the bundle.  Otherwise, a new EdgeEndBundle is created
            to contain the EdgeEnd.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundleStar.UpdateIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeStubs around the node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateComputer">
            <summary>
            Computes the topological relationship between two Geometries.
            RelateComputer does not need to build a complete graph structure to compute
            the IntersectionMatrix.  The relationship between the geometries can
            be computed by simply examining the labelling of edges incident on each node.
            RelateComputer does not currently support arbitrary GeometryCollections.
            This is because GeometryCollections can contain overlapping Polygons.
            In order to correct compute relate on overlapping Polygons, they
            would first need to be noded and merged (if not explicitly, at least
            implicitly).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.#ctor(NetTopologySuite.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="arg"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.ComputeIM">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.InsertEdgeEnds(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd})">
             <summary>
            
             </summary>
             <param name="ee"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.ComputeProperIntersectionIM(NetTopologySuite.GeometriesGraph.Index.SegmentIntersector,NetTopologySuite.Geometries.IntersectionMatrix)">
             <summary>
            
             </summary>
             <param name="intersector"></param>
             <param name="im"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.CopyNodesAndLabels(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.ComputeIntersectionNodes(System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelIntersectionNodes(System.Int32)">
            <summary>
            For all intersections on the edges of a Geometry,
            label the corresponding node IF it doesn't already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.ComputeDisjointIM(NetTopologySuite.Geometries.IntersectionMatrix,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            If the Geometries are disjoint, we need to enter their dimension and
            boundary dimension in the Ext rows in the IM
            </summary>
            <param name="im">An intersection matrix</param>
            <param name="boundaryNodeRule">The Boundary Node Rule to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.GetBoundaryDim(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Compute the IM entry for the intersection of the boundary
            of a geometry with the Exterior.
            This is the nominal dimension of the boundary
            unless the boundary is empty, in which case it is <see cref="F:NetTopologySuite.Geometries.Dimension.False"/>.
            For linear geometries the Boundary Node Rule determines
            whether the boundary is empty.
            </summary>
            <param name="geom">The geometry providing the boundary</param>
            <param name="boundaryNodeRule">The Boundary Node Rule to use</param>
            <returns>The IM dimension entry</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelNodeEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.UpdateIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the sum of the IMs for each component.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelIsolatedEdges(System.Int32,System.Int32)">
            <summary>
            Processes isolated edges by computing their labelling and adding them
            to the isolated edges list.
            Isolated edges are guaranteed not to touch the boundary of the target (since if they
            did, they would have caused an intersection to be computed and hence would
            not be isolated).
            </summary>
            <param name="thisIndex"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelIsolatedEdge(NetTopologySuite.GeometriesGraph.Edge,System.Int32,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Label an isolated edge of a graph with its relationship to the target point.
            If the target has dim 2 or 1, the edge can either be in the interior or the exterior.
            If the target has dim 0, the edge must be in the exterior.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
            <param name="target"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelIsolatedNodes">
            <summary>
            Isolated nodes are nodes whose labels are incomplete
            (e.g. the location for one Geometry is null).
            This is the case because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer.LabelIsolatedNode(NetTopologySuite.GeometriesGraph.Node,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="n"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNode">
            <summary>
            A RelateNode is a Node that maintains a list of EdgeStubs
            for the edges that are incident on it.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNode.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.GeometriesGraph.EdgeEndStar)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="edges"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNode.ComputeIM(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNode.UpdateIMFromEdges(NetTopologySuite.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeEnds incident on this node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNodeFactory">
            <summary>
            Used by the <c>NodeMap</c> in a <c>RelateNodeGraph</c> to create <c>RelateNode</c>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeFactory.CreateNode(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNodeGraph">
            <summary>
            Implements the simple graph of Nodes and EdgeEnd which is all that is
            required to determine topological relationships between Geometries.
            Also supports building a topological graph of a single Geometry, to
            allow verification of valid topology.
            It is not necessary to create a fully linked
            PlanarGraph to determine relationships, since it is sufficient
            to know how the Geometries interact locally around the nodes.
            In fact, this is not even feasible, since it is not possible to compute
            exact intersection points, and hence the topology around those nodes
            cannot be computed robustly.
            The only Nodes that are created are for improper intersections;
            that is, nodes which occur at existing vertices of the Geometries.
            Proper intersections (e.g. ones which occur between the interior of line segments)
            have their topology determined implicitly, without creating a Node object
            to represent them.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph.GetNodeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph.Build(NetTopologySuite.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph.ComputeIntersectionNodes(NetTopologySuite.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            Precondition: edge intersections have been computed.
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph.CopyNodesAndLabels(NetTopologySuite.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule).
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph.InsertEdgeEnds(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeEnd})">
             <summary>
            
             </summary>
             <param name="ee"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateOp">
            <summary>
            Implements the SFS <c>relate()</c>  generalized spatial predicate on two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            <br/>
            The class supports specifying a custom <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            to be used during the relate computation.
            </summary>
            <remarks>
            If named spatial predicates are used on the result <see cref="P:NetTopologySuite.Operation.Relate.RelateOp.IntersectionMatrix"/>
            of the RelateOp, the result may or not be affected by the
            choice of <tt>BoundaryNodeRule</tt>, depending on the exact nature of the pattern.
            For instance, <see cref="M:NetTopologySuite.Geometries.IntersectionMatrix.IsIntersects"/> is insensitive
            to the choice of <tt>BoundaryNodeRule</tt>,
            whereas <see cref="M:NetTopologySuite.Geometries.IntersectionMatrix.IsTouches(NetTopologySuite.Geometries.Dimension,NetTopologySuite.Geometries.Dimension)"/> is affected by the rule chosen.
            <para/>
            <b>Note:</b> custom Boundary Node Rules do not (currently)
            affect the results of other <see cref="T:NetTopologySuite.Geometries.Geometry"/> methods (such
            as <see cref="P:NetTopologySuite.Geometries.Geometry.Boundary"/>.  The results of
            these methods may not be consistent with the relationship computed by
            a custom Boundary Node Rule.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp.Relate(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the <see cref="P:NetTopologySuite.Operation.Relate.RelateOp.IntersectionMatrix"/> for the spatial relationship
             between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s, using the default (OGC SFS) Boundary Node Rule
            </summary>
            <param name="a">A geometry to test</param>
            <param name="b">A geometry to test</param>
            <returns>The <c>IntersectionMatrix</c> for the spatial relationship between the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp.Relate(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Computes the <see cref="P:NetTopologySuite.Operation.Relate.RelateOp.IntersectionMatrix"/> for the spatial relationship
             between two <see cref="T:NetTopologySuite.Geometries.Geometry"/>s, using the specified Boundary Node Rule
            </summary>
            <param name="a">A geometry to test</param>
            <param name="b">A geometry to test</param>
            <param name="boundaryNodeRule">The Boundary Node Rule to use</param>
            <returns>The <c>IntersectionMatrix</c> for the spatial relationship between the geometries</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new Relate operation, using the default (OGC SFS) Boundary Node Rule.
            </summary>
            <param name="g0">a Geometry to relate</param>
            <param name="g1">another Geometry to relate</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Creates a new Relate operation, using the default (OGC SFS) Boundary Node Rule.
            </summary>
            <param name="g0">a Geometry to relate</param>
            <param name="g1">another Geometry to relate</param>
            <param name="boundaryNodeRule">The Boundary Node Rule to use</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Relate.RelateOp.IntersectionMatrix">
            <summary>
            Gets the IntersectionMatrix for the spatial relationship
            between the input geometries.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.CascadedPolygonUnion">
            <summary>
            Provides an efficient method of unioning a collection of
            <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometries.
            The geometries are indexed using a spatial index,
            and unioned recursively in index order.
            For geometries with a high degree of overlap,
            this has the effect of reducing the number of vertices
            early in the process, which increases speed
            and robustness.
            <para/>
            This algorithm is faster and more robust than
            the simple iterated approach of
            repeatedly unioning each polygon to a result geometry.
            </summary>
            <author>Martin Davis</author>
            <seealso href="http://code.google.com/p/nettopologysuite/issues/detail?id=44"/>
        </member>
        <member name="F:NetTopologySuite.Operation.Union.CascadedPolygonUnion.ClassicUnion">
            <summary>
            A union strategy that uses the classic NTS <see cref="T:NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp"/>,
            with a robustness fallback to OverlayNG.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.Union(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Computes the union of
            a collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="polys">A collection of <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.</param>
            <returns>The union of the <paramref name="polys"/></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.Union(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Operation.Union.UnionStrategy)">
            <summary>
            Computes the union of
            a collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="polys">A collection of <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.</param>
            <param name="unionStrategy">A strategy to perform the unioning.</param>
            <returns>The union of the <paramref name="polys"/></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Creates a new instance to union
            the given collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="polys">A collection of <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> <see cref="T:NetTopologySuite.Geometries.Geometry"/>s</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.#ctor(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Operation.Union.UnionStrategy)">
            <summary>
            Creates a new instance to union
            the given collection of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            </summary>
            <param name="polys">A collection of <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> <see cref="T:NetTopologySuite.Geometries.Geometry"/>s</param>
            <param name="unionStrategy"></param>
        </member>
        <member name="F:NetTopologySuite.Operation.Union.CascadedPolygonUnion.STRtreeNodeCapacity">
            <summary>
            The effectiveness of the index is somewhat sensitive
            to the node capacity.
            Testing indicates that a smaller capacity is better.
            For an STRtree, 4 is probably a good number (since
            this produces 2x2 "squares").
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.Union">
            <summary>
            Computes the union of the input geometries.
            </summary>
            <returns>
            <remarks>
            This method discards the input geometries as they are processed.
            In many input cases this reduces the memory retained
            as the operation proceeds.
            Optimal memory usage is achieved
            by disposing of the original input collection
            before calling this method.
            </remarks>
            The union of the input geometries,
            or <c>null</c> if no input geometries were provided
            </returns>
            <exception cref="T:System.InvalidOperationException">if this method is called more than once</exception>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.BinaryUnion(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Unions a list of geometries
            by treating the list as a flattened binary tree,
            and performing a cascaded union on the tree.
            </summary>
            <param name="geoms">The list of geometries to union</param>
            <returns>The union of the list</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.BinaryUnion(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry},System.Int32,System.Int32)">
            <summary>
            Unions a section of a list using a recursive binary union on each half
            of the section.
            </summary>
            <param name="geoms">The list of geometries containing the section to union</param>
            <param name="start">The start index of the section</param>
            <param name="end">The index after the end of the section</param>
            <returns>The union of the list section</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.GetGeometry(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry},System.Int32)">
            <summary>
            Gets the element at a given list index, or
            null if the index is out of range.
            </summary>
            <param name="list">The list of geometries</param>
            <param name="index">The index</param>
            <returns>The geometry at the given index or
            <c>null</c> if the index is out of range</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.ReduceToGeometries(System.Collections.Generic.IList{System.Object})">
            <summary>
            Reduces a tree of geometries to a list of geometries
            by recursively unioning the subtrees in the list.
            </summary>
            <param name="geomTree">A tree-structured list of geometries</param>
            <returns>A list of Geometrys</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.UnionSafe(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the union of two geometries,
            either or both of which may be null.
            </summary>
            <param name="g0">A Geometry</param>
            <param name="g1">A Geometry</param>
            <returns>The union of the input(s) or
            <c>null</c> if both inputs are null</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.UnionActual(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Union.UnionStrategy)">
            <summary>
            Encapsulates the actual unioning of two polygonal geometries.
            </summary>
            <param name="g0">A geometry to union</param>
            <param name="g1">A geometry to union</param>
            <param name="unionStrategy">A </param>
            <returns>The union of the inputs</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion.RestrictToPolygons(NetTopologySuite.Geometries.Geometry)">
            <summary> Computes a <see cref="T:NetTopologySuite.Geometries.Geometry"/> containing only <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> components.
            Extracts the <see cref="T:NetTopologySuite.Geometries.Polygon"/>s from the input
            and returns them as an appropriate <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometry.
            <para/>
            If the input is already <tt>Polygonal</tt>, it is returned unchanged.
            <para/>
            A particular use case is to filter out non-polygonal components
            returned from an overlay operation.
            </summary>
            <param name="g">The geometry to filter</param>
            <returns>A polygonal geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.InputExtracter">
            <summary>
            Extracts atomic elements from
            input geometries or collections,
            recording the dimension found.
            Empty geometries are discarded since they
            do not contribute to the result of <see cref="T:NetTopologySuite.Operation.Union.UnaryUnionOp"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.InputExtracter.Extract(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Extracts elements from an enumeration of geometries.
            </summary>
            <param name="geoms">An enumeration of geometries</param>
            <returns>An extracter over the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.InputExtracter.Extract(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts elements from a geometry.
            </summary>
            <param name="geom">An geometry to extract from</param>
            <returns>An extracter over the geometry.</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.Union.InputExtracter._dimension">
            <summary>The default dimension for an empty GeometryCollection</summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.InputExtracter.IsEmpty">
            <summary>
            Gets a value indicating if there were any non-empty geometries extracted
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.InputExtracter.Dimension">
            <summary>
            Gets a value indicating the maximum <see cref="T:NetTopologySuite.Geometries.Dimension"/> extracted.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.InputExtracter.Factory">
            <summary>
            Gets a value indicating the geometry factory from the extracted geometry,
            if there is one. <para/>
            If an empty collection was extracted, will return <c>null</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.InputExtracter.GetExtract(NetTopologySuite.Geometries.Dimension)">
            <summary>
            Gets the extracted atomic geometries of the given dimension <c>dim</c>.
            </summary>
            <param name="dim">The dimension of geometry to return</param>
            <returns>A list of the extracted geometries of dimension dim.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.OverlapUnion">
            <summary>
            Unions MultiPolygons efficiently by
            using full topological union only for polygons which may overlap,
            and combining with the remaining polygons.
            Polygons which may overlap are those which intersect the common extent of the inputs.
            Polygons wholly outside this extent must be disjoint to the computed union.
            They can thus be simply combined with the union result,
            which is much more performant.
            (There is one caveat to this, which is discussed below).
            <para/>
            This situation is likely to occur during cascaded polygon union,
            since the partitioning of polygons is done heuristically
            and thus may group disjoint polygons which can lie far apart.
            It may also occur in real world data which contains many disjoint polygons
            (e.g. polygons representing parcels on different street blocks).
            </summary>
            <remarks>
            <h2>Algorithm</h2>
            The overlap region is determined as the common envelope of intersection.
            The input polygons are partitioned into two sets:
            <list type="bullet">
            <item><term>Overlapping</term><description>Polygons which intersect the overlap region, and thus potentially overlap each other</description></item>
            <item><term>Disjoint</term><description>Polygons which are disjoint from (lie wholly outside) the overlap region</description></item>
            </list>
            The Overlapping set is fully unioned, and then combined with the Disjoint set.
            Performing a simple combine works because
            the disjoint polygons do not interact with each
            other(since the inputs are valid MultiPolygons).
            They also do not interact with the Overlapping polygons,
            since they are outside their envelope.
            <h2>Discussion</h2>
            In general the Overlapping set of polygons will
            extend beyond the overlap envelope.  This means that the union result
            will extend beyond the overlap region.
            There is a small chance that the topological
            union of the overlap region will shift the result linework enough
            that the result geometry intersects one of the Disjoint geometries.
            This situation is detected and if it occurs
            is remedied by falling back to performing a full union of the original inputs.
            Detection is done by a fairly efficient comparison of edge segments which
            extend beyond the overlap region.  If any segments have changed
            then there is a risk of introduced intersections, and full union is performed.
            <para/>
            This situation has not been observed in JTS using floating precision,
            but it could happen due to snapping.  It has been observed
            in other APIs(e.g.GEOS) due to more aggressive snapping.
            It is more likely to happen if a Snap - Rounding overlay is used.
            <para/>
            <b>NOTE: Test has shown that using this heuristic impairs performance.</b>
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.OverlapUnion.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Union a pair of geometries,
            using the more performant overlap union algorithm if possible.
            </summary>
            <param name="g0">A geometry to union</param>
            <param name="g1">A geometry to union</param>
            <returns>The union of the inputs</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.OverlapUnion.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Union.UnionStrategy)">
            <summary>
            Union a pair of geometries,
            using the more performant overlap union algorithm if possible.
            </summary>
            <param name="g0">A geometry to union</param>
            <param name="g1">A geometry to union</param>
            <param name="unionFun">Function to union two geometries</param>
            <returns>The union of the inputs</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.OverlapUnion.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new instance for unioning the given geometries.
            </summary>
            <param name="g0">A geometry to union</param>
            <param name="g1">A geometry to union</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.OverlapUnion.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry,NetTopologySuite.Operation.Union.UnionStrategy)">
            <summary>
            Creates a new instance for unioning the given geometries.
            </summary>
            <param name="g0">A geometry to union</param>
            <param name="g1">A geometry to union</param>
            <param name="unionFun">Function to union two geometries</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.OverlapUnion.Union">
            <summary>
            Union a pair of geometries,
            using the more performant overlap union algorithm if possible.
            </summary>
            <returns>The union of the inputs</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.OverlapUnion.IsUnionOptimized">
            <summary>
            Gets a value indicating whether the optimized
            or full union was performed.
            </summary>
            <remarks>Used for unit testing.</remarks>>
            <returns><c>true</c> if the optimized union was performed</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.PointGeometryUnion.Union(NetTopologySuite.Geometries.IPuntal,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the union of a <see cref="T:NetTopologySuite.Geometries.Point"/> geometry with
            another arbitrary <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            Does not copy any component geometries.
            </summary>
            <param name="pointGeom"></param>
            <param name="otherGeom"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.UnaryUnionOp">
            <summary>
            Unions a <c>Collection</c> of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s or a single Geometry (which may be a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>) together.
            </summary>
            <remarks>
            <para>
            By using this special-purpose operation over a collection of geometries
            it is possible to take advantage of various optimizations to improve performance.
            </para>
            <para>
            Heterogeneous <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>s are fully supported.
            </para>
            <para>
            The result obeys the following contract:
            <list type="bullet">
            <item><description>Unioning a set of <see cref="T:NetTopologySuite.Geometries.Polygon"/>s has the effect of merging the areas (i.e. the same effect as iteratively unioning all individual polygons together).</description></item>
            <item><description>Unioning a set of <see cref="T:NetTopologySuite.Geometries.LineString"/>s has the effect of <b>fully noding</b>
            and <b>dissolving</b> the input linework.
            In this context "fully noded" means that there will be
            an endpoint or node in the result
            for every endpoint or line segment crossing in the input.
            "Dissolved" means that any duplicate (e.g. coincident) line segments or portions
            of line segments will be reduced to a single line segment in the output.
            This is consistent with the semantics of the
            <see cref="M:NetTopologySuite.Geometries.Geometry.Union(NetTopologySuite.Geometries.Geometry)"/> operation.
            If <b>merged</b> linework is required, the <see cref="T:NetTopologySuite.Operation.Linemerge.LineMerger"/> class can be used.</description></item>
            <item><description>Unioning a set of <see cref="T:NetTopologySuite.Geometries.Point"/>s has the effect of merging all identical points (producing a set with no duplicates).</description></item> </list>
            </para>
            <para>
            <c>UnaryUnion</c> always operates on the individual components of MultiGeometries.
            So it is possible to use it to "clean" invalid self-intersecting MultiPolygons
            (although the polygon components must all still be individually valid.)
            </para>
            </remarks>
            <author>
            mbdavis
            </author>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Computes the geometric union of a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="geoms">A collection of geometries</param>
            <returns>The union of the geometries,
            or <c>null</c> if the input is empty</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.Union(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Computes the geometric union of a <see cref="T:System.Collections.Generic.IEnumerable`1"/><para/>
            If no input geometries were provided but a <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> was provided,
            an empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> is returned.
            </summary>
            <param name="geoms">A collection of geometries</param>
            <param name="geomFact">The geometry factory to use if the collection is empty</param>
            <returns>The union of the geometries
            or an empty GEOMETRYCOLLECTION</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.Union(NetTopologySuite.Geometries.Geometry)">
            <summary>Constructs a unary union operation for a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            (which may be a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>).
            </summary>
            <param name="geom">A geometry to union</param>
            <returns>The union of the elements of the geometry
            or an empty GEOMETRYCOLLECTION</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Constructs a unary union operation for an enumeration
            of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s, using the <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            of the input geometries.
            </summary>
            <param name="geoms">An enumeration of geometries</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Constructs a unary union operation for an enumeration
            of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s. <para/>
            If no input geometries were provided but a <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> was provided,
            </summary>
            <param name="geoms">An enumeration of geometries</param>
            <param name="geomFact">The geometry factory to use if the enumeration is empty</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs a unary union operation for a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            (which may be a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>).
            </summary>
            <param name="geom">A geometry to union</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.UnaryUnionOp.UnionStrategy">
            <remarks>
            Named setter named setUnionFun[ction] in JTS
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.Union">
            <summary>
            Gets the union of the input geometries.
            <para/>
            The result of empty input is determined as follows:
            <list type="Bullet">
            <item><description>If the input is empty and a dimension can be
            determined (i.e. an empty geometry is present),
            an empty atomic geometry of that dimension is returned.</description></item>
            <item><description>If no input geometries were provided but a <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/> was provided,
            an empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> is returned.</description></item>
            <item><description>Otherwise, the return value is <c>null</c>.</description></item>
            </list>
            </summary>
            <returns>
            A Geometry containing the union,
            or an empty atomic geometry, or an empty <c>GEOMETRYCOLLECTION</c>,
            or<c>null</c> if no GeometryFactory was provided
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.UnionWithNull(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the union of two geometries, either of both of which may be null.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <returns>
            The union of the input(s)
            or <c>null</c> if both inputs are <c>null</c>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp.UnionNoOpt(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a unary union with no extra optimization, and no short-circuiting.
            </summary>
            <remarks>
            Due to the way the overlay operations are implemented, this is still efficient in the case of linear and puntal geometries.
            </remarks>
            <param name="g0">A geometry</param>
            <returns>The union of the input geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.UnionInteracting">
            <summary>
            Experimental code to union MultiPolygons with processing limited to the elements which actually interact.
            </summary>
            <remarks>Not currently used, since it doesn't seem to offer much of a performance advantage.</remarks>
            <author>mbdavis</author>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.UnionStrategy">
            <summary>
            An strategy class that allows UnaryUnion to adapt to different
            kinds of overlay algorithms.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnionStrategy.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the union of two geometries.
            This method may throw a <see cref="T:NetTopologySuite.Geometries.TopologyException"/>
            if one is encountered.
            </summary>
            <param name="g0">A geometry</param>
            <param name="g1">A geometry</param>
            <returns>The union of the input</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Union.UnionStrategy.IsFloatingPrecision">
            <summary>
            Indicates whether the union function operates using
            a floating(full) precision model.
            If this is the case, then the unary union code
            can make use of the { @link OverlapUnion}
            performance optimization,
            and perhaps other optimizations as well.
            Otherwise, the union result extent may not be the same as the extent of the inputs,
            which prevents using some optimizations.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.ConnectedInteriorTester">
            <summary>
            This class tests that the interior of an area <see cref="T:NetTopologySuite.Geometries.Geometry" />
            (<see cref="T:NetTopologySuite.Geometries.Polygon" /> or <see cref="T:NetTopologySuite.Geometries.MultiPolygon" />)
            is connected.  An area Geometry is invalid if the interior is disconnected.
            This can happen if:
            - a shell self-intersects,
            - one or more holes form a connected chain touching a shell at two different points,
            - one or more holes form a ring around a subset of the interior.
            If a disconnected situation is found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.FindDifferentPoint(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.#ctor(NetTopologySuite.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.IsInteriorsConnected">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.SetInteriorEdgesInResult(NetTopologySuite.GeometriesGraph.PlanarGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.BuildEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd})">
            <summary>
            Form <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge" />s in graph into Minimal EdgeRings.
            (Minimal Edgerings must be used, because only they are guaranteed to provide
            a correct isHole computation).
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.VisitShellInteriors(NetTopologySuite.Geometries.Geometry,NetTopologySuite.GeometriesGraph.PlanarGraph)">
            <summary>
            Mark all the edges for the edgeRings corresponding to the shells of the input polygons.
            Only ONE ring gets marked for each shell - if there are others which remain unmarked
            this indicates a disconnected interior.
            </summary>
            <param name="g"></param>
            <param name="graph"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.VisitInteriorRing(NetTopologySuite.Geometries.LineString,NetTopologySuite.GeometriesGraph.PlanarGraph)">
             <summary>
            
             </summary>
             <param name="ring"></param>
             <param name="graph"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.VisitLinkedDirectedEdges(NetTopologySuite.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="start"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester.HasUnvisitedShellEdge(System.Collections.Generic.IList{NetTopologySuite.GeometriesGraph.EdgeRing})">
            <summary>
            Check if any shell ring has an unvisited edge.
            A shell ring is a ring which is not a hole and which has the interior
            of the parent area on the RHS.
            (Note that there may be non-hole rings with the interior on the LHS,
            since the interior of holes will also be polygonized into CW rings
            by the <c>LinkAllDirectedEdges()</c> step).
            </summary>
            <param name="edgeRings"></param>
            <returns><c>true</c> if there is an unvisited edge in a non-hole ring.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.ConsistentAreaTester">
            <summary>
            Checks that a <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph"/> representing an area
            (a <c>Polygon</c> or <c>MultiPolygon</c> )
            is consistent with the SFS semantics for area geometries.
            Checks include:
            Testing for rings which self-intersect (both properly and at nodes).
            Testing for duplicate rings.
            If an inconsistency if found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConsistentAreaTester.#ctor(NetTopologySuite.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester.InvalidPoint">
            <summary>
            Returns the intersection point, or <c>null</c> if none was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester.IsNodeConsistentArea">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester.IsNodeEdgeAreaLabelsConsistent">
            <summary>
            Check all nodes to see if their labels are consistent.
            If any are not, return false.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester.HasDuplicateRings">
            <summary>
            Checks for two duplicate rings in an area.
            Duplicate rings are rings that are topologically equal
            (that is, which have the same sequence of points up to point order).
            If the area is topologically consistent (determined by calling the
            <c>isNodeConsistentArea</c>,
            duplicate rings can be found by checking for EdgeBundles which contain more than one EdgeEnd.
            (This is because topologically consistent areas cannot have two rings sharing
            the same line segment, unless the rings are equal).
            The start point of one of the equal rings will be placed in invalidPoint.
            Returns <c>true</c> if this area Geometry is topologically consistent but has two duplicate rings.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IndexedNestedHoleTester">
            <summary>
            Tests whether any holes of a Polygon are
            nested inside another hole, using a spatial
            index to speed up the comparisons.
            <para/>
            The logic assumes that the holes do not overlap and have no collinear segments
            (so they are properly nested, and there are no duplicate holes).
            <para/>
            The situation where every vertex of a hole touches another hole
            is invalid because either the hole is nested,
            or else it disconnects the polygon interior.
            This class detects the nested situation.
            The disconnected interior situation must be checked elsewhere.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IndexedNestedHoleTester.NestedPoint">
            <summary>
            Gets a value indicating a point on a nested hole, if one exists.
            </summary>
            <returns>A point on a nested hole, or <c>null</c> if none are nested</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IndexedNestedHoleTester.IsNested">
            <summary>
            Tests if any hole is nested (contained) within another hole.
            <b>This is invalid</b>.
            The <see cref="P:NetTopologySuite.Operation.Valid.IndexedNestedHoleTester.NestedPoint"/> will be set to reflect this.
            </summary>
            <returns><c>true</c> if some hole is nested.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester">
            <summary>
            Tests whether a MultiPolygon has any element polygon
            improperly nested inside another polygon, using a spatial
            index to speed up the comparisons.
            <para/>
            The logic assumes that the polygons do not overlap and have no collinear segments.
            So the polygon rings may touch at discrete points,
            but they are properly nested, and there are no duplicate rings.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester.NestedPoint">
            <summary>
            Gets a point on a nested polygon, if one exists.
            </summary>
            <returns>A point on a nested polygon, or null if none are nested</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester.IsNested">
            <summary>
            Tests if any polygon is improperly nested (contained) within another polygon.
            <b>This is invalid.</b>
            The nested point will be set to reflect this.
            </summary>
            <returns><c>true</c> if some polygon is nested</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester.FindNestedPoint(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Polygon,NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator)">
            <summary>
            Finds an improperly nested point, if one exists.
            </summary>
            <param name="shell">The test polygon shell</param>
            <param name="possibleOuterPoly">A polygon which may contain it</param>
            <param name="locator">The locator for the outer polygon</param>
            <returns>A nested point, if one exists, or <c>null</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester.FindIncidentSegmentNestedPoint(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.Polygon)">
            <summary>
            Finds a point of a shell segment which lies inside a polygon, if any.
            The shell is assumed to touch the polygon only at shell vertices,
            and does not cross the polygon.
            </summary>
            <param name="shell">The shell to test</param>
            <param name="poly">The polygon to test against</param>
            <returns>An interior segment point, or <c>null</c> if the shell is nested correctly</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IndexedNestedRingTester">
            <summary>
            Tests whether any of a set of <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s are
            nested inside another ring in the set, using a spatial
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IsSimpleOp">
            <summary>
            Tests whether a <c>Geometry</c> is simple as defined by the OGC SFS specification.
            <para/>
            Simplicity is defined for each <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            type as follows:
            <list type="bullet">
            <item><term>Point</term><description>geometries are simple.</description></item>
            <item><term>MultiPoint</term><description>geometries are simple if every point is unique</description></item>
            <item><term>LineString</term><description>geometries are simple if they do not self-intersect at interior points
            (i.e.points other than the endpoints).
            Closed linestrings which intersect only at their endpoints are simple
            (i.e. valid <b>LinearRings</b>s.
            </description></item>
            <item><term>MultiLineString</term><description>geometries are simple if 
            their elements are simple and they intersect only at points 
            which are boundary points of both elements. 
            (The notion of boundary points can be user-specified - see below).</description></item>
            <item><term>Polygonal</term><description>geometries have no definition of simplicity.
            The <c>IsSimple</c> code checks if all polygon rings are simple.
            (Note: this means that<tt>IsSimple</tt> cannot be used to test 
            for <i>all</i> self-intersections in <tt>Polygon</tt> s.  
            In order to check if a <tt>IPolygonal</tt> geometry has self-intersections,
            use <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/>.</description></item>
            <item><term>GeometryCollection</term><description>geometries are simple if all their elements are simple.</description></item>
            <item><description>Empty geometries are simple</description></item>
            </list>
            For <see cref="T:NetTopologySuite.Geometries.ILineal"/> geometries the evaluation of simplicity
            can be customized by supplying a <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            to define how boundary points are determined.
            The default is the SFS-standard <see cref="F:NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryRule"/>.
            <para/>
            Note that under the <tt>Mod-2</tt> rule, closed <tt>LineString</tt>s (rings)
            have no boundary.
            This means that an intersection at the endpoints of
            two closed LineStrings makes the geometry non-simple.
            This means that an intersection at their endpoints makes the geometry non-simple.
            If it is required to test whether a set of <c>LineString</c>s touch
            only at their endpoints, use <see cref="F:NetTopologySuite.Algorithm.BoundaryNodeRules.EndpointBoundaryRule"/>.
            For example, this can be used to validate that a collection of lines
            form a topologically valid linear network.
            <para/>
            By default this class finds a single non-simple location.
            To find all non-simple locations, set <see cref="P:NetTopologySuite.Operation.Valid.IsSimpleOp.FindAllLocations"/>
            before calling <see cref="M:NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimple"/>, and retrieve the locations
            via <see cref="P:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleLocations"/>.
            This can be used to find all intersection points in a linear network.
            </summary>
            <seealso cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            <seealso cref="P:NetTopologySuite.Geometries.Geometry.IsEmpty"/>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimple(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether a geometry is simple.
            </summary>
            <param name="geom">The input geometry</param>
            <returns><c>true</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.GetNonSimpleLocation(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets a non-simple location in a geometry, if any.
            </summary>
            <param name="geom">The input geometry</param>
            <returns>A non-simple location, or <c>null</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
            </summary>
            <param name="geom">The geometry to test</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Creates a simplicity checker using a given <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            </summary>
            <param name="geom">The geometry to test</param>
            <param name="boundaryNodeRule">The boundary node rule to use</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsSimpleOp.FindAllLocations">
            <summary>Gets or sets a value indicating if all non-simple points should be reported.</summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimple">
            <summary>
            Tests whether the geometry is simple.
            </summary>
            <returns><c>true</c> if the geometry is simple.</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleLocation">
            <summary>
            Gets the coordinate for an location where the geometry
            fails to be simple (i.e. where it has a non-boundary
            self-intersection).
            </summary>
            <returns>A <c>Coordinate</c> for the location of the non-boundary self-intersection
            or <c>null</c> if the geometry is simple</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleLocations">
            <summary>
            Gets all non-simple intersection locations.
            </summary>
            <returns>A list of the <c>Coordinate</c>s of non-simple locations.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimplePolygonal(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes simplicity for polygonal geometries.
            Polygonal geometries are simple if and only if
            all of their component rings are simple.
            </summary>
            <param name="geom">A <see cref="T:NetTopologySuite.Geometries.IPolygonal"/> geometry</param>
            <returns><c>true</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimpleGeometryCollection(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Semantics for GeometryCollection is
            simple if all components are simple.
            </summary>
            <param name="geom">A geometry collection</param>
            <returns><c>true</c> if the geometry is simple</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.#ctor(System.Boolean,System.Boolean,System.Collections.Generic.List{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="isClosedEndpointsInInterior">A flag indicating if closed endpoints belong to the interior</param>
            <param name="isFindAll">A flag indicating that all non-simple intersection points should be found</param>
            <param name="intersectionPts">A list to add the non-simple intersection points to.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.HasIntersection">
            <summary>
            Tests whether an intersection was found.
            </summary>
            <returns><c>true</c> if an intersection was found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <inheritdoc cref="M:NetTopologySuite.Noding.ISegmentIntersector.ProcessIntersections(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Noding.ISegmentString,System.Int32)"/>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.IsIntersectionEndpoint(NetTopologySuite.Noding.ISegmentString,System.Int32,NetTopologySuite.Algorithm.LineIntersector,System.Int32)">
            <summary>
            Tests whether an intersection vertex is an endpoint of a segment string.
            </summary>
            <param name="ss">The segment string</param>
            <param name="ssIndex">The index of the segment in <paramref name="ss"/></param>
            <param name="li">The line intersector</param>
            <param name="liSegmentIndex">The index of the segment in intersector</param>
            <returns><c>true</c> if the intersection vertex is an endpoint</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.IntersectionVertexIndex(NetTopologySuite.Algorithm.LineIntersector,System.Int32)">
            <summary>
            Finds the vertex index in a segment of an intersection
            which is known to be a vertex.
            </summary>
            <param name="li">The line intersector</param>
            <param name="segmentIndex">The intersection segment index</param>
            <returns>
            The vertex index (0 or 1) in the segment vertex of the intersection point
            </returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleIntersectionFinder.IsDone">
            <inheritdoc cref="P:NetTopologySuite.Noding.ISegmentIntersector.IsDone"/>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IsValidOp">
            <summary>
            Implements the algorithms required to compute the <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid" />
            method for <see cref="T:NetTopologySuite.Geometries.Geometry" />s.
            See the documentation for the various geometry types for a specification of validity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckValid(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Geometries.Geometry"/> is valid.
            </summary>
            <param name="geom">The geometry to test</param>
            <returns><c>true</c> if the geometry is valid</returns>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidCoordinate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Checks whether a coordinate is valid for processing.
            Coordinates are valid if their x and y ordinates are in the
            range of the floating point representation.
            </summary>
            <param name="coord">The coordinate to validate</param>
            <returns><c>true</c> if the coordinate is valid</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.IsValidOp._inputGeometry">
            <summary>
            The geometry being validated
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.IsValidOp._isInvertedRingValid">
            <summary>
            If the following condition is TRUE JTS will validate inverted shells and exverted holes
            (the ESRI SDE model)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new validator for a geometry
            </summary>
            <param name="inputGeometry">The geometry to validate</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsValidOp.SelfTouchingRingFormingHoleValid">
            <summary>
            Gets or sets a value indicating whether polygons using <b>Self-Touching Rings</b> to form
            holes are reported as valid.
            If this flag is set, the following Self-Touching conditions
            are treated as being valid:
            <list type="bullet">
            <item><description>the shell ring self-touches to create a hole touching the shell</description></item>
            <item><description>a hole ring self-touches to create two holes touching at a point</description></item>
            </list>
            <para/>
            The default (following the OGC SFS standard)
            is that this condition is <b>not</b> valid (<c>false</c>).
            <para/>
            Self-Touching Rings which disconnect the
            the polygon interior are still considered to be invalid
            (these are <b>invalid</b> under the SFS, and many other
            spatial models as well).
            This includes:
            <list type="bullet">
            <item><description>exverted ("bow-tie") shells which self-touch at a single point</description></item>
            <item><description>inverted shells with the inversion touching the shell at another point</description></item>
            <item><description>exverted holes with exversion touching the hole at another point</description></item>
            <item><description>inverted ("C-shaped") holes which self-touch at a single point causing an island to be formed</description></item>
            <item><description>inverted shells or exverted holes which form part of a chain of touching rings
            (which disconnect the interior)</description></item>
            </list>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsValidOp.IsSelfTouchingRingFormingHoleValid">
            <summary>
            <para>
            Gets/Sets whether polygons using Self-Touching Rings to form
            holes are reported as valid.
            If this flag is set, the following Self-Touching conditions
            are treated as being valid:<br/>
            - The shell ring self-touches to create a hole touching the shell.<br/>
            - A hole ring self-touches to create two holes touching at a point.<br/>
            </para>
            <para>
            The default (following the OGC SFS standard)
            is that this condition is not valid (<c>false</c>).
            </para>
            <para>
            This does not affect whether Self-Touching Rings
            disconnecting the polygon interior are considered valid
            (these are considered to be invalid under the SFS, and many other
            spatial models as well).
            This includes "bow-tie" shells,
            which self-touch at a single point causing the interior to be disconnected,
            and "C-shaped" holes which self-touch at a single point causing an island to be formed.
            </para>
            </summary>
            <value>States whether geometry with this condition is valid.</value>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsValidOp.IsValid">
            <summary>
            Tests the validity of the input geometry.
            </summary>
            <returns><c>true</c> if the geometry is valid.</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsValidOp.ValidationError">
            <summary>
            Gets a value indicating the validity of the geometry
            If not valid, returns the validation error for the geometry,
            or <c>null</c> if the geometry is valid.
            </summary>
            <returns>The validation error, if the geometry is invalid
            or null if the geometry is valid</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.Point)">
            <summary>
            Tests validity of a <c>Point</c>.
            </summary>
            <param name="g">The <c>Point</c> to test</param>
            <returns><c>true</c> if the <c>Point</c> is valid</returns>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.MultiPoint)">
            <summary>
            Tests validity of a <c>MultiPoint</c>.
            </summary>
            <param name="g">The <c>MultiPoint</c> to test</param>
            <returns><c>true</c> if the <c>MultiPoint</c> is valid</returns>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.LineString)">
            <summary>
            Tests validity of a <c>LineString</c>.<br/>
            Almost anything goes for <c>LineString</c>s!
            </summary>
            <param name="g">The <c>LineString</c> to test</param>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Tests validity of a <c>LinearRing</c>.<br/>
            </summary>
            <param name="g">The <c>LinearRing</c> to test</param>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Tests validity of a <c>Polygon</c>.<br/>
            </summary>
            <param name="g">The <c>Polygon</c> to test</param>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.MultiPolygon)">
            <summary>
            Tests validity of a <c>MultiPolygon</c>.<br/>
            </summary>
            <param name="g">The <c>MultiPolygon</c> to test</param>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsValidGeometry(NetTopologySuite.Geometries.GeometryCollection)">
            <summary>
            Tests validity of a <c>GeometryCollection</c>.<br/>
            </summary>
            <param name="gc">The <c>GeometryCollection</c> to test</param>
            <remarks>In JTS this function is called <c>IsValid</c></remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckPointSize(NetTopologySuite.Geometries.LineString,System.Int32)">
            <summary>
            Check the number of non-repeated points is at least a given size.
            </summary>
            <param name="line">The line to test</param>
            <param name="minSize">The minimum number of points in <paramref name="line"/></param>
            <returns><c>true</c> if the line has the required number of points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.IsNonRepeatedSizeAtLeast(NetTopologySuite.Geometries.LineString,System.Int32)">
            <summary>
            Test if the number of non-repeated points in a line
            is at least a given minimum size.
            </summary>
            <param name="line">The line to test</param>
            <param name="minSize">The minimum number of points in <paramref name="line"/></param>
            <returns><c>true</c> if the line has the required number of non-repeated points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckRingSimple(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Check whether a ring self-intersects (except at its endpoints).
            </summary>
            <param name="ring">The linear ring to check</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckHolesInShell(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Tests that each hole is inside the polygon shell.
            This routine assumes that the holes have previously been tested
            to ensure that all vertices lie on the shell or on the same side of it
            (i.e. that the hole rings do not cross the shell ring).
            Given this, a simple point-in-polygon test of a single point in the hole can be used,
            provided the point is chosen such that it does not lie on the shell.
            </summary>
            <param name="poly">The polygon to be tested for hole inclusion</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.FindHoleOutsideShellPoint(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.LineString)">
            <summary>
            Checks if a polygon hole lies inside its shell
            and if not returns a point indicating this.
            The hole is known to be wholly inside or outside the shell,
            so it suffices to find a single point which is interior or exterior,
            or check the edge topology at a point on the boundary of the shell.
            </summary>
            <param name="hole">The hole to test</param>
            <param name="shell">The polygon shell to test against</param>
            <returns>A hole point outside the shell, or <c>null</c> if it is inside.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckHolesNotNested(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Checks if any polygon hole is nested inside another.
            Assumes that holes do not cross (overlap),
            This is checked earlier.
            </summary>
            <param name="poly">The polygon with holes to test</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.CheckShellsNotNested(NetTopologySuite.Geometries.MultiPolygon)">
            <summary>
            Checks that no element polygon is in the interior of another element polygon.
            <para/>Preconditions:
            <list type="bullet">
            <item><description>shells do not partially overlap</description></item>
            <item><description>shells do not touch along an edge</description></item>
            <item><description>no duplicate rings exist</description></item></list>
            These have been confirmed by the <see cref="T:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp.FindPointNotNode(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.LinearRing,NetTopologySuite.GeometriesGraph.GeometryGraph)">
            <summary>
            Find a point from the list of testCoords
            that is NOT a node in the edge for the list of searchCoords.
            </summary>
            <param name="testCoords"></param>
            <param name="searchRing"></param>
            <param name="graph"></param>
            <returns>The point found, or <c>null</c> if none found.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer">
            <summary>Finds and analyzes intersections in and between polygons,
            to determine if they are valid.
            <para/>
            The <see cref="T:NetTopologySuite.Noding.ISegmentString"/>s which are analyzed can have <see cref="T:NetTopologySuite.Operation.Valid.PolygonRing"/>s
            attached. If so they will be updated with intersection information
            to support further validity analysis which must be done after
            basic intersection validity has been confirmed.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer.#ctor(System.Boolean)">
            <summary>
            Creates a new finder, allowing for the mode where inverted rings are valid.
            </summary>
            <param name="isInvertedRingValid"><c>true</c> if inverted rings are valid.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer.PrevCoordinateInRing(NetTopologySuite.Noding.ISegmentString,System.Int32)">
            <summary>
            For a segment string for a ring, gets the coordinate
            previous to the given index (wrapping if the index is 0)
            </summary>
            <param name="ringSS">The ring segment string</param>
            <param name="segIndex">The segment index</param>
            <returns>The coordinate previous to the given segment</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer.IsAdjacentInRing(NetTopologySuite.Noding.ISegmentString,System.Int32,System.Int32)">
            <summary>
            Tests if two segments in a closed <see cref="T:NetTopologySuite.Noding.ISegmentString"/> are adjacent.
            This handles determining adjacency across the start/end of the ring.
            </summary>
            <param name="ringSS">The segment string</param>
            <param name="segIndex0">A segment index</param>
            <param name="segIndex1">A segment index</param>
            <returns><c>true</c> if the segments are adjacent</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonNode">
            <summary>
            Functions to compute topological information
            about nodes (ring intersections) in polygonal geometry.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonNode.IsCrossing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Check if the edges at a node between two rings (or one ring) cross.
            The node is topologically valid if the ring edges do not cross.
            This function assumes that the edges are not collinear. 
            </summary>
            <param name="nodePt">The node location</param>
            <param name="a0">The previous edge endpoint in a ring</param>
            <param name="a1">The next edge endpoint in a ring</param>
            <param name="b0">The previous edge endpoint in the other ring</param>
            <param name="b1">The next edge endpoint in the other ring</param>
            <returns>
            <c>true</c> if the edges cross at the node
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonNode.IsInteriorSegment(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether an edge node-b lies in the interior or exterior
            of a corner of a ring given by a0-node-a1.
            The ring interior is assumed to be on the right of the corner (a CW ring).
            The edge must not be collinear with the corner segments.
            </summary>
            <param name="nodePt">The node location</param>
            <param name="a0">The first vertex of the corner</param>
            <param name="a1">The second vertex of the corner</param>
            <param name="b">The destination vertex of the edge</param>
            <returns><c>true</c> if the edge is interior to the ring corner</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonNode.IsBetween(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if an edge p is between edges e0 and e1,
            where the edges all originate at a common origin.
            The "inside" of e0 and e1 is the arc which does not include the origin.
            The edges are assumed to be distinct (non-collinear).
            </summary>
            <param name="origin">the origin</param>
            <param name="p">the destination point of edge p</param>
            <param name="e0">the destination point of edge e0</param>
            <param name="e1">the destination point of edge e1</param>
            <returns><c>true</c> if p is between e0 and e1</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonNode.IsAngleGreater(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if the angle with the origin of a vector P is greater than that of the
            vector Q.
            </summary>
            <param name="origin">The origin of the vectors</param>
            <param name="p">The endpoint of the vector P</param>
            <param name="q">The endpoint of the vector Q</param>
            <returns><c>true</c> if vector P has angle greater than Q</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonRing">
            <summary>
            A ring of a polygon being analyzed for topological validity.
            The shell and hole rings of valid polygons touch only at discrete points.
            The "touch" relationship induces a graph over the set of rings.
            The interior of a valid polygon must be connected.
            This is the case if there is no "chain" of touching rings
            (which would partition off part of the interior).
            This is equivalent to the touch graph having no cycles.
            Thus the touch graph of a valid polygon is a forest - a set of disjoint trees.
            <para/>
            Also, in a valid polygon two rings can touch only at a single location,
            since otherwise they disconnect a portion of the interior between them.
            This is checked as the touches relation is built
            (so the touch relation representation for a polygon ring does not need to support
            more than one touch location for each adjacent ring).
            <para/>
            The cycle detection algorithm works for polygon rings which also contain self-touches
            (inverted shells and exverted holes).
            <para/>
            Polygons with no holes do not need to be checked for
            a connected interior, unless self-touches are allowed.
            <para/>
            The class also records the topology at self-touch nodes,
            to support checking if an invalid self-touch disconnects the polygon.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.IsShell(NetTopologySuite.Operation.Valid.PolygonRing)">
            <summary>
            Tests if a polygon ring represents a shell.
            </summary>
            <param name="polyRing">The ring to test (may be <c>null</c>)</param>
            <returns><c>true</c> if the ring represents a shell</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.AddTouch(NetTopologySuite.Operation.Valid.PolygonRing,NetTopologySuite.Operation.Valid.PolygonRing,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Records a touch location between two rings,
            and checks if the rings already touch in a different location.
            </summary>
            <param name="ring0">A polygon ring</param>
            <param name="ring1">A polygon ring</param>
            <param name="pt">The location where they touch</param>
            <returns><c>true</c> if the polygons already touch</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.FindHoleCycleLocation(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Valid.PolygonRing})">
            <summary>
            Finds a location (if any) where a chain of holes forms a cycle
            in the ring touch graph.
            The shell may form part of the chain as well.
            This indicates that a set of holes disconnects the interior of a polygon.
            </summary>
            <param name="polyRings">The list of rings to check</param>
            <returns>A vertex contained in a ring cycle or <c>null</c> if none is found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.FindInteriorSelfNode(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Valid.PolygonRing})">
            <summary>
            Finds a location of an interior self-touch in a list of rings,
            if one exists.
            This indicates that a self-touch disconnects the interior of a polygon,
            which is invalid.
            </summary>
            <param name="polyRings">The list of rings to check</param>
            <returns>The location of an interior self-touch node, or <c>null</c> if there are none</returns>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.PolygonRing._touchSetRoot">
            <summary>
            The root of the touch graph tree containing this ring.
            Serves as the id for the graph partition induced by the touch relation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.PolygonRing._touches">
            <summary>
            The set of <see cref="T:NetTopologySuite.Operation.Valid.PolygonRingTouch"/> links
            for this ring.
            The set of all touches in the rings of a polygon
            forms the polygon touch graph.
            This supports detecting touch cycles, which
            reveal the condition of a disconnected interior.
            <para/>
            Only a single touch is recorded between any two rings,
            since more than one touch between two rings
            indicates interior disconnection as well.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.PolygonRing._selfNodes">
            <summary>
            The set of self-nodes in this ring.
            This supports checking valid ring self-touch topology.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.#ctor(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Creates a ring for a polygon shell.
            </summary>
            <param name="ring">The polygon shell</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.#ctor(NetTopologySuite.Geometries.LinearRing,System.Int32,NetTopologySuite.Operation.Valid.PolygonRing)">
            <summary>
            Creates a ring for a polygon hole.
            </summary>
            <param name="ring">The ring geometry</param>
            <param name="index">The index of the hole</param>
            <param name="shell">The parent polygon shell</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.AddTouch(NetTopologySuite.Operation.Valid.PolygonRing,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds a point where a <see cref="T:NetTopologySuite.Operation.Valid.PolygonRing"/> touches another one.
            </summary>
            <param name="ring">The other <see cref="T:NetTopologySuite.Operation.Valid.PolygonRing"/></param>
            <param name="pt">The touch location</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.AddSelfTouch(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds the node (intersection point)
            and the endpoints of the four adjacent segments.
            </summary>
            <param name="origin">The node</param>
            <param name="e00">The 1st position of the 1st edge</param>
            <param name="e01">The 2nd position of the 1st edge</param>
            <param name="e10">The 1st position of the 2nd edge</param>
            <param name="e11">The 2nd position of the 2nd edge</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.IsOnlyTouch(NetTopologySuite.Operation.Valid.PolygonRing,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if this ring touches a given ring at
            the single point specified.
            </summary>
            <param name="ring">The other polygon ring</param>
            <param name="pt">The touch point</param>
            <returns><c>true</c> if the rings touch only at the given point.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.FindHoleCycleLocation">
            <summary>
            Detects whether the subgraph of holes linked by touch to this ring
            contains a hole cycle.
            If no cycles are detected, the set of touching rings is a tree.
            The set is marked using this ring as the root.
            </summary>
            <returns>A vertex om a hole cycle or <c>null</c> if no cycle found</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.ScanForHoleCycle(NetTopologySuite.Operation.Valid.PolygonRingTouch,NetTopologySuite.Operation.Valid.PolygonRing,System.Collections.Generic.Queue{NetTopologySuite.Operation.Valid.PolygonRingTouch})">
            <summary>
            Scans for a hole cycle starting at a given touch.
            </summary>
            <param name="currentTouch">The touch to investigate</param>
            <param name="root">The root of the touch subgraph</param>
            <param name="touchQueue">The queue of rings to scan</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.FindInteriorSelfNode">
            <summary>
            Finds the location of an invalid interior self-touch in this ring,
            if one exists. 
            </summary>
            <returns>The location of an interior self-touch node, or <c>null</c> if there are none
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRing.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonRingTouch">
            <summary>
            Records a point where a <see cref="T:NetTopologySuite.Operation.Valid.PolygonRing"/> touches another one.
            This forms an edge in the induced ring touch graph.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRingTouch.#ctor(NetTopologySuite.Operation.Valid.PolygonRing,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this item
            </summary>
            <param name="ring">The polygon ring</param>
            <param name="pt">The touch position</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonRingSelfNode">
            <summary>
            Represents a ring self-touch node, recording the node (intersection point)
            and the endpoints of the four adjacent segments.
            <para/>
            This is used to evaluate validity of self-touching nodes,
            when they are allowed.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRingSelfNode.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this point
            </summary>
            <param name="nodePt">The self touch position</param>
            <param name="e00">The 1st position of the 1st edge</param>
            <param name="e01">The 2nd position of the 1st edge</param>
            <param name="e10">The 1st position of the 2nd edge</param>
            <param name="e11">The 2nd position of the 2nd edge</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.PolygonRingSelfNode.Coordinate">
            <summary>
            Gets a value indicating the node point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonRingSelfNode.IsExterior(System.Boolean)">
            <summary>
            Tests if a self-touch has the segments of each half of the touch
            lying in the exterior of a polygon.
            This is a valid self-touch.
            It applies to both shells and holes.
            Only one of the four possible cases needs to be tested,
            since the situation has full symmetry.
            </summary>
            <param name="isInteriorOnRight">A flag indicating if the interior is to the right of the parent ring</param>
            <returns><c>true</c> if the self-touch is on the exterior.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer">
            <summary>
            Analyzes the topology of polygonal geometry
            to determine whether it is valid.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.IsRingNested(NetTopologySuite.Geometries.LineString,NetTopologySuite.Geometries.LineString)">
            <summary>
            Tests whether a ring is nested inside another ring
            <para/>
            Preconditions:
            <list type="bullet">
            <item><description>The rings do not cross (i.e. the test is wholly inside or outside the target)</description></item>
            <item><description>The rings may touch at discrete points only</description></item>
            <item><description>The <paramref name="target"/> ring does not self-cross, but it may self-touch</description></item>
            </list>
            If the test ring start point is properly inside or outside, that provides the result.
            Otherwise the start point is on the target ring,
            and the incident start segment(accounting for repeated points) is
            tested for its topology relative to the target ring.
            </summary>
            <param name="test">The ring to test</param>
            <param name="target">The ring to test against</param>
            <returns><c>true</c> if the <paramref name="test"/> ring lies inside the <paramref name="target"/> ring</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.IsIncidentSegmentInRing(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Tests whether a touching segment is interior to a ring.
            <para/>
            Preconditions:
            <list type="bullet">
            <item><description>The segment does not intersect the ring other than at the endpoints</description></item>
            <item><description>The segment vertex p0 lies on the ring</description></item>
            <item><description>The ring does not self-cross, but it may self-touch</description></item>
            </list>
            This works for both shells and holes, but the caller must know
            the ring role.
            </summary>
            <param name="p0">The touching vertex of the segment</param>
            <param name="p1">The second vertex of the segment</param>
            <param name="ringPts">The points of the ring</param>
            <returns><c>true</c> if the segment is inside the ring.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.FindRingVertexPrev(NetTopologySuite.Geometries.Coordinate[],System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds the ring vertex previous to a node point on a ring
            (which is contained in the index'th segment,
            as either the start vertex or an interior point).
            Repeated points are skipped over.
            </summary>
            <param name="ringPts">The ring</param>
            <param name="index">The index of the segment containing the node</param>
            <param name="node">The node point</param>
            <returns>The previous ring vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.FindRingVertexNext(NetTopologySuite.Geometries.Coordinate[],System.Int32,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds the ring vertex next from a node point on a ring
            (which is contained in the index'th segment,
            as either the start vertex or an interior point). 
            </summary>
            <param name="ringPts">The ring</param>
            <param name="index">The index of the segment containing the node</param>
            <param name="node">The node point</param>
            <returns>The next ring vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.IntersectingSegIndex(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the index of the segment which intersects a given point.
            </summary>
            <param name="ringPts">The ring points</param>
            <param name="pt">The intersection point</param>
            <returns>The intersection segment index, or <c>-1</c> if not intersection is found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.FindSelfIntersection(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Finds a self-intersection (if any) in a <see cref="T:NetTopologySuite.Geometries.LinearRing"/>.
            </summary>
            <param name="ring">The ring to analyze</param>
            <returns>A self-intersection point if one exists, or <c>null</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.IsInteriorDisconnected">
            <summary>
            Tests whether the interior of the polygonal geometry is
            disconnected.<br/>
            If true, the disconnection location is available from 
            <see cref="P:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.DisconnectionLocation"/>.
            </summary>
            <returns><c>true</c> if the interior is disconnected</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.DisconnectionLocation">
            <summary>
            Gets a location where the polyonal interior is disconnected.<br/>
            <see cref="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.IsInteriorDisconnected"/> must be called first.
            </summary>
            <returns>The location of an interior disconnection, or <c>null</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.CheckInteriorDisconnectedByHoleCycle">
            <summary>
            Tests whether any polygon with holes has a disconnected interior
            by virtue of the holes (and possibly shell) forming a touch cycle.
            <para/>
            This is a global check, which relies on determining
            the touching graph of all holes in a polygon.
            <para/>
            If inverted rings disconnect the interior
            via a self-touch, this is checked by the <see cref="T:NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer"/>.
            If inverted rings are part of a disconnected ring chain
            this is detected here.  
            </summary>
            <returns><c>true</c> if a polygon has a disconnected interior.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer.CheckInteriorDisconnectedBySelfTouch">
            <summary>
            Tests if an area interior is disconnected by a self-touching ring.
            This must be evaluated after other self-intersections have been analyzed
            and determined to not exist, since the logic relies on
            the rings not self-crossing (winding).
            </summary>
            <returns><c>true</c> if an area interior is disconnected by a self-touch</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.RepeatedPointTester">
            <summary>
            Implements the appropriate checks for repeated points
            (consecutive identical coordinates) as defined in the
            NTS spec.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.RepeatedPointTester.Coordinate">
            <summary>
            Gets a value indicating the location of the repeated point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Checks if a geometry has a repeated point
            </summary>
            <param name="g">The geometry to test</param>
            <returns><c>true</c> if the geometry has a repeated point, otherwise <c>false</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Checks if an array of <c>Coordinate</c>s has a repeated point
            </summary>
            <param name="coord">An array of coordinates</param>
            <returns><c>true</c> if <paramref name="coord"/> has a repeated point, otherwise <c>false</c></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(NetTopologySuite.Geometries.CoordinateSequence)">
            <summary>
            Checks if an array of <c>Coordinate</c>s has a repeated point
            </summary>
            <param name="sequence">A coordinate sequence</param>
            <returns><c>true</c> if <paramref name="sequence"/> has a repeated point, otherwise <c>false</c></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.TopologyValidationErrors">
            <summary>
            Contains information about the nature and location of
            a <see cref="T:NetTopologySuite.Geometries.Geometry" /> validation error.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.NoInvalidIntersection">
            <summary>
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.HoleOutsideShell">
            <summary>
            Indicates that a hole of a polygon lies partially
            or completely in the exterior of the shell.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.NestedHoles">
            <summary>
            Indicates that a hole lies
            in the interior of another hole in the same polygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.DisconnectedInteriors">
            <summary>
            Indicates that the interior of a polygon is disjoint
            (often caused by set of contiguous holes splitting
            the polygon into two parts).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.SelfIntersection">
            <summary>
            Indicates that two rings of a polygonal geometry intersect.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.RingSelfIntersection">
            <summary>
            Indicates that a ring self-intersects.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.NestedShells">
            <summary>
            Indicates that a polygon component of a
            <see cref="T:NetTopologySuite.Geometries.MultiPolygon" /> lies inside another polygonal component.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.DuplicateRings">
            <summary>
            Indicates that a polygonal geometry
            contains two rings which are identical.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.TooFewPoints">
            <summary>
            Indicates that either:
            - A <see cref="T:NetTopologySuite.Geometries.LineString" /> contains a single point.
            - A <see cref="T:NetTopologySuite.Geometries.LinearRing" /> contains 2 or 3 points.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.InvalidCoordinate">
            <summary>
            Indicates that the <c>X</c> or <c>Y</c> ordinate of
            a <see cref="T:NetTopologySuite.Geometries.Coordinate" /> is not a valid
            numeric value (e.g. <see cref="F:System.Double.NaN" />).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.RingNotClosed">
            <summary>
            Indicates that a ring is not correctly closed
            (the first and the last coordinate are different).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.TopologyValidationError">
            <summary>
            Contains information about the nature and location of a <c>Geometry</c>
            validation error.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationError.errMsg">
            <summary>
            These messages must synch up with the indexes above
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.TopologyValidationError.#ctor(NetTopologySuite.Operation.Valid.TopologyValidationErrors,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="errorType"></param>
             <param name="pt"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.TopologyValidationError.#ctor(NetTopologySuite.Operation.Valid.TopologyValidationErrors)">
             <summary>
            
             </summary>
             <param name="errorType"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.TopologyValidationError.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.TopologyValidationError.ErrorType">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.TopologyValidationError.Message">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.TopologyValidationError.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder">
            <summary>
            Finds all connected <see cref="T:NetTopologySuite.Planargraph.Subgraph" />s of a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph" />.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.#ctor(NetTopologySuite.Planargraph.PlanarGraph)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder"/> class.
            </summary>
            <param name="graph">The <see cref="T:NetTopologySuite.Planargraph.PlanarGraph" />.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.AddReachable(NetTopologySuite.Planargraph.Node,NetTopologySuite.Planargraph.Subgraph)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode"></param>
            <param name="subgraph"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.AddEdges(NetTopologySuite.Planargraph.Node,System.Collections.Generic.Stack{NetTopologySuite.Planargraph.Node},NetTopologySuite.Planargraph.Subgraph)">
            <summary>
            Adds the argument node and all its out edges to the subgraph.
            </summary>
            <param name="node"></param>
            <param name="nodeStack"></param>
            <param name="subgraph"></param>
        </member>
        <member name="T:NetTopologySuite.Planargraph.DirectedEdge">
            <summary>
            Represents a directed edge in a <c>PlanarGraph</c>. A DirectedEdge may or
            may not have a reference to a parent Edge (some applications of
            planar graphs may not require explicit Edge objects to be created). Usually
            a client using a <c>PlanarGraph</c> will subclass <c>DirectedEdge</c>
            to add its own application-specific data and methods.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.ToEdges(System.Collections.Generic.IList{NetTopologySuite.Planargraph.DirectedEdge})">
            <summary>
            Returns a List containing the parent Edge (possibly null) for each of the given
            DirectedEdges.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.#ctor(NetTopologySuite.Planargraph.Node,NetTopologySuite.Planargraph.Node,NetTopologySuite.Geometries.Coordinate,System.Boolean)">
            <summary>
            Constructs a DirectedEdge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.Edge">
            <summary>
            Returns this DirectedEdge's parent Edge, or null if it has none.
            Associates this DirectedEdge with an Edge (possibly null, indicating no associated
            Edge).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.Quadrant">
            <summary>
            Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
            orientation lies.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.QuadrantEx">
            <summary>
            Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
            orientation lies.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.DirectionPt">
            <summary>
            Returns a point to which an imaginary line is drawn from the from-node to
            specify this DirectedEdge's orientation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.EdgeDirection">
            <summary>
            Returns whether the direction of the parent Edge (if any) is the same as that
            of this Directed Edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.FromNode">
            <summary>
            Returns the node from which this DirectedEdge leaves.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.ToNode">
            <summary>
            Returns the node to which this DirectedEdge goes.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.Coordinate">
            <summary>
            Returns the coordinate of the from-node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.Angle">
            <summary>
            Returns the angle that the start of this DirectedEdge makes with the
            positive x-axis, in radians.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.Sym">
            <summary>
            Returns the symmetric DirectedEdge -- the other DirectedEdge associated with
            this DirectedEdge's parent Edge.
            Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite
            direction.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.CompareTo(System.Object)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to round off. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCGAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.CompareDirection(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to round off. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCGAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.Write(System.IO.StreamWriter)">
            <summary>
            Writes a detailed string representation of this DirectedEdge to the given PrintStream.
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.Remove">
            <summary>
            Removes this directed edge from its containing graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Planargraph.DirectedEdgeStar">
            <summary>
            A sorted collection of <c>DirectedEdge</c>s which leave a <c>Node</c>
            in a <c>PlanarGraph</c>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.DirectedEdgeStar._outEdges">
            <summary>
            The underlying list of outgoing DirectedEdges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.Add(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Adds a new member to this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.Remove(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Drops a member of this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar.Degree">
            <summary>
            Returns the number of edges around the Node associated with this DirectedEdgeStar.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar.Coordinate">
            <summary>
            Returns the coordinate for the node at which this star is based.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar.Edges">
            <summary>
            Returns the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.SortEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetIndex(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetIndex(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Returns the zero-based index of the given DirectedEdge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetIndex(System.Int32)">
            <summary>
            Returns the remainder when i is divided by the number of edges in this
            DirectedEdgeStar.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetNextEdge(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Returns the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/> on the left-hand
            side of the given <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/>
            (which  must be a member of this DirectedEdgeStar).
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar.GetNextCWEdge(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Returns the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/> on the right-hand (CW)
            side of the given <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/>
            (which must be a member of this DirectedEdgeStar).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Edge">
            <summary>
            Represents an undirected edge of a {PlanarGraph}. An undirected edge
            in fact simply acts as a central point of reference for two opposite
            <c>DirectedEdge</c>s.
            Usually a client using a <c>PlanarGraph</c> will subclass <c>Edge</c>
            to add its own application-specific data and methods.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Edge.dirEdge">
            <summary>
            The two DirectedEdges associated with this Edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.#ctor">
            <summary>
            Constructs an Edge whose DirectedEdges are not yet set. Be sure to call
            <c>SetDirectedEdges(DirectedEdge, DirectedEdge)</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.#ctor(NetTopologySuite.Planargraph.DirectedEdge,NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Constructs an Edge initialized with the given DirectedEdges, and for each
            DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds
            this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.SetDirectedEdges(NetTopologySuite.Planargraph.DirectedEdge,NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets the
            Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.GetDirEdge(System.Int32)">
            <summary>
            Returns one of the DirectedEdges associated with this Edge.
            </summary>
            <param name="i">0 or 1.</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.GetDirEdge(NetTopologySuite.Planargraph.Node)">
            <summary>
            Returns the DirectedEdge that starts from the given node, or null if the
            node is not one of the two nodes associated with this Edge.
            </summary>
            <param name="fromNode"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.GetOppositeNode(NetTopologySuite.Planargraph.Node)">
            <summary>
            If <c>node</c> is one of the two nodes associated with this Edge,
            returns the other node; otherwise returns null.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge.Remove">
            <summary>
            Removes this edge from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Edge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="T:NetTopologySuite.Planargraph.GraphComponent">
            <summary>
            The base class for all graph component classes.
            Maintains flags of use in generic graph algorithms.
            Provides two flags:
            marked - typically this is used to indicate a state that persists
            for the course of the graph's lifetime.  For instance, it can be
            used to indicate that a component has been logically deleted from the graph.
            visited - this is used to indicate that a component has been processed
            or visited by an single graph algorithm.  For instance, a breadth-first traversal of the
            graph might use this to indicate that a node has already been traversed.
            The visited flag may be set and cleared many times during the lifetime of a graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.GraphComponent.SetVisited(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Visited" /> state
            for all <see cref="T:NetTopologySuite.Planargraph.GraphComponent" />s in an <see cref="T:System.Collections.IEnumerator" />.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator" /> to scan.</param>
            <param name="visited">The state to set the <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Visited" /> flag to.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.GraphComponent.SetMarked(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Marked" /> state
            for all <see cref="T:NetTopologySuite.Planargraph.GraphComponent" />s in an <see cref="T:System.Collections.IEnumerator" />.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator" /> to scan.</param>
            <param name="marked">The state to set the <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Marked" /> flag to.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.GraphComponent.GetComponentWithVisitedState(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Finds the first <see cref="T:NetTopologySuite.Planargraph.GraphComponent" />
            in a <see cref="T:System.Collections.IEnumerator" /> set
            which has the specified <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Visited" /> state.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator" /> to scan.</param>
            <param name="visitedState">The <see cref="P:NetTopologySuite.Planargraph.GraphComponent.Visited" /> state to test.</param>
            <returns>The first <see cref="T:NetTopologySuite.Planargraph.GraphComponent" /> found, or <c>null</c> if none found.</returns>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.IsVisited">
            <summary>
            Tests if a component has been visited during the course of a graph algorithm.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.Visited">
            <summary>
            Gets/Sets the visited flag for this component.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.IsMarked">
            <summary>
            Tests if a component has been marked at some point during the processing
            involving this graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.Marked">
            <summary>
            Gets/Sets the marked flag for this component.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent.Data">
            <summary>
            Gets or sets user defined data for this component
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Node">
            <summary>
            A node in a <c>PlanarGraph</c> is a location where 0 or more <c>Edge</c>s
            meet. A node is connected to each of its incident Edges via an outgoing
            DirectedEdge. Some clients using a <c>PlanarGraph</c> may want to
            subclass <c>Node</c> to add their own application-specific
            data and methods.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.GetEdgesBetween(NetTopologySuite.Planargraph.Node,NetTopologySuite.Planargraph.Node)">
            <summary>
            Returns all Edges that connect the two nodes (which are assumed to be different).
            </summary>
            <param name="node0"></param>
            <param name="node1"></param>
            <returns></returns>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Node.pt">
            <summary>
            The location of this Node.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Node.deStar">
            <summary>
            The collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Constructs a Node with the given location.
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Planargraph.DirectedEdgeStar)">
            <summary>
            Constructs a Node with the given location and collection of outgoing DirectedEdges.
            </summary>
            <param name="pt"></param>
            <param name="deStar"></param>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node.Coordinate">
            <summary>
            Returns the location of this Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.AddOutEdge(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Adds an outgoing DirectedEdge to this Node.
            </summary>
            <param name="de"></param>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node.OutEdges">
            <summary>
            Returns the collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node.Degree">
            <summary>
            Returns the number of edges around this Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.GetIndex(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.Remove(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Removes a <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/> incident on this node. Does not change the state of the directed edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.Remove">
            <summary>
            Removes this node from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Planargraph.NodeMap">
            <summary>
            A map of <see cref="T:NetTopologySuite.Planargraph.Node">nodes</see>, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap.Add(NetTopologySuite.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            </summary>
            <param name="n"></param>
            <returns>The added node.</returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap.Remove(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Removes the Node at the given location, and returns it (or null if no Node was there).
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap.Find(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the Node at the given location, or null if no Node was there.
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap.GetEnumerator">
            <summary>
            Returns an Iterator over the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.NodeMap.Values">
            <summary>
            Returns the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.NodeMap.Count">
            <summary>
            Returns the number of Nodes in this NodeMap.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.PlanarGraph">
            <summary>
            Represents a directed graph which is embeddable in a planar surface.
            This class and the other classes in this package serve as a framework for
            building planar graphs for specific algorithms. This class must be
            subclassed to expose appropriate methods to construct the graph. This allows
            controlling the types of graph components ({DirectedEdge}s,
            <c>Edge</c>s and <c>Node</c>s) which can be added to the graph. An
            application which uses the graph framework will almost always provide
            subclasses for one or more graph components, which hold application-specific
            data and graph algorithms.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.PlanarGraph._edges">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.PlanarGraph.dirEdges">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.PlanarGraph.nodeMap">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.FindNode(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Returns the <see cref="T:NetTopologySuite.Planargraph.Node"/> at the given <paramref name="pt">location</paramref>, or <c>null</c> if no <see cref="T:NetTopologySuite.Planargraph.Node"/> was there.
            </summary>
            <param name="pt">The location</param>
            <returns>The node found<br/>
            or <c>null</c> if this graph contains no node at the location
            </returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Add(NetTopologySuite.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            Only subclasses can add Nodes, to ensure Nodes are of the right type.
            </summary>
            <param name="node"></param>
            <returns>The added node.</returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Add(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Adds the Edge and its DirectedEdges with this PlanarGraph.
            Assumes that the Edge has already been created with its associated DirectEdges.
            Only subclasses can add Edges, to ensure the edges added are of the right class.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Add(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges,
            to ensure the edges added are of the right class.
            </summary>
            <param name="dirEdge"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.GetNodeEnumerator">
            <summary>
            Returns an IEnumerator over the Nodes in this PlanarGraph.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Planargraph.PlanarGraph.Nodes">
            <summary>
            Returns the Nodes in this PlanarGraph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.GetDirEdgeEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.GetEdgeEnumerator">
            <summary>
            Returns an Iterator over the Edges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Planargraph.PlanarGraph.Edges">
            <summary>
            Returns the Edges that have been added to this PlanarGraph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Remove(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Removes an Edge and its associated DirectedEdges from their from-Nodes and
            from this PlanarGraph. Note: This method does not remove the Nodes associated
            with the Edge, even if the removal of the Edge reduces the degree of a
            Node to zero.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Remove(NetTopologySuite.Planargraph.DirectedEdge)">
            <summary>
            Removes a <see cref="T:NetTopologySuite.Planargraph.DirectedEdge"/> from its from-<see cref="T:NetTopologySuite.Planargraph.Node"/> and from this PlanarGraph.
            </summary>
            <remarks>
            This method does not remove the <see cref="T:NetTopologySuite.Planargraph.Node"/>s associated with the DirectedEdge,
            even if the removal of the DirectedEdge reduces the degree of a Node to zero.
            </remarks>
            <param name="de"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.Remove(NetTopologySuite.Planargraph.Node)">
            <summary>
            Removes a node from the graph, along with any associated DirectedEdges and
            Edges.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph.FindNodesOfDegree(System.Int32)">
            <summary>
            Returns all Nodes with the given number of Edges around it.
            </summary>
            <param name="degree"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Subgraph">
            <summary>
            A subgraph of a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph" />.
            A subgraph may contain any subset of <see cref="T:NetTopologySuite.Planargraph.Edge" />s
            from the parent graph.
            It will also automatically contain all <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s
            and <see cref="T:NetTopologySuite.Planargraph.Node" />s associated with those edges.
            No new objects are created when edges are added -
            all associated components must already exist in the parent graph.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Subgraph.parentGraph">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Subgraph.edges">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Subgraph.dirEdges">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Subgraph.nodeMap">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.#ctor(NetTopologySuite.Planargraph.PlanarGraph)">
            <summary>
            Creates a new subgraph of the given <see cref="T:NetTopologySuite.Planargraph.PlanarGraph" />.
            </summary>
            <param name="parentGraph"></param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.GetParent">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Planargraph.PlanarGraph" /> which this subgraph is part of.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.Add(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Adds an <see cref="T:NetTopologySuite.Planargraph.Edge" /> to the subgraph.
            The associated <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s and <see cref="T:NetTopologySuite.Planargraph.Node" />s are also added.
            </summary>
            <param name="e">The <see cref="T:NetTopologySuite.Planargraph.Edge" /> to add.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.GetDirEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1" /> over the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge" />s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.GetEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1" /> over the <see cref="T:NetTopologySuite.Planargraph.Edge" />s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.GetNodeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerator`1" /> over the <see cref="T:NetTopologySuite.Planargraph.Node" />s in this graph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph.Contains(NetTopologySuite.Planargraph.Edge)">
            <summary>
            Tests whether an <see cref="T:NetTopologySuite.Planargraph.Edge" /> is contained in this subgraph.
            </summary>
            <param name="e">The <see cref="T:NetTopologySuite.Planargraph.Edge" /> to test.</param>
            <returns><c>true</c> if the <see cref="T:NetTopologySuite.Planargraph.Edge" /> is contained in this subgraph.</returns>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBits">
            <summary>
            Determines the maximum number of common most-significant
            bits in the mantissa of one or numbers.
            Can be used to compute the double-precision number which
            is represented by the common bits.
            If there are no common bits, the number computed is 0.0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.SignExpBits(System.Int64)">
            <summary>
            Computes the bit pattern for the sign and exponent of a
            double-precision number.
            </summary>
            <param name="num"></param>
            <returns>The bit pattern for the sign and exponent.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.NumCommonMostSigMantissaBits(System.Int64,System.Int64)">
            <summary>
            This computes the number of common most-significant bits in the mantissas
            of two double-precision numbers.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="num1"></param>
            /// <param name="num2"></param>
            <returns>The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.ZeroLowerBits(System.Int64,System.Int32)">
            <summary>
            Zeroes the lower n bits of a bitstring.
            </summary>
            <param name="bits">The bitstring to alter.</param>
            <param name="nBits">the number of bits to zero.</param>
            <returns>The zeroed bitstring.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.GetBit(System.Int64,System.Int32)">
            <summary>
            Extracts the i'th bit of a bitstring.
            </summary>
            <param name="bits">The bitstring to extract from.</param>
            <param name="i">The bit to extract.</param>
            <returns>The value of the extracted bit.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.Add(System.Double)">
             <summary>
            
             </summary>
             <param name="num"></param>
        </member>
        <member name="P:NetTopologySuite.Precision.CommonBits.Common">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.ToString(System.Int64)">
            <summary>
            A representation of the Double bits formatted for easy readability
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBitsOp">
            <summary>
            Provides versions of Geometry spatial functions which use
            common bit removal to reduce the likelihood of robustness problems.
            In the current implementation no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            Client classes should check the validity of the returned result themselves.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.#ctor">
            <summary>
            Creates a new instance of class, which reshifts result <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of class, specifying whether
            the result <c>Geometry</c>s should be reshifted.
            </summary>
            <param name="returnToOriginalPrecision"></param>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.Intersection(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.Difference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry, to be subtracted from the first.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.SymDifference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary
            > Computes the set-theoretic symmetric difference of two geometries,
            using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.Buffer(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Computes the buffer a point, using enhanced precision.
            </summary>
            <param name="geom0">The Geometry to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns>The Geometry representing the buffer of the input Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.ComputeResultPrecision(NetTopologySuite.Geometries.Geometry)">
            <summary>
            If required, returning the result to the original precision if required.
            In this current implementation, no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            </summary>
            <param name="result">The result Geometry to modify.</param>
            <returns>The result Geometry with the required precision.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.RemoveCommonBits(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a copy of the input <c>Geometry</c> with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">The Geometry to remove common bits from.</param>
            <returns>A copy of the input Geometry with common bits removed.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsOp.RemoveCommonBits(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a copy of each input <c>Geometry</c>s with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">A Geometry to remove common bits from.</param>
            <param name="geom1">A Geometry to remove common bits from.</param>
            <returns>
            An array containing copies
            of the input Geometry's with common bits removed.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBitsRemover">
            <summary>
            Removes common most-significant mantissa bits
            from one or more <see cref="T:NetTopologySuite.Geometries.Geometry"/>s.
            <para/>
            The CommonBitsRemover "scavenges" precision
            which is "wasted" by a large displacement of the geometry
            from the origin.
            For example, if a small geometry is displaced from the origin
            by a large distance,
            the displacement increases the significant figures in the coordinates,
            but does not affect the <i>relative</i> topology of the geometry.
            Thus the geometry can be translated back to the origin
            without affecting its topology.
            In order to compute the translation without affecting
            the full precision of the coordinate values,
            the translation is performed at the bit level by
            removing the common leading mantissa bits.
            <para/>
            If the geometry envelope already contains the origin,
            the translation procedure cannot be applied.
            In this case, the common bits value is computed as zero.
            <para/>
            If the geometry crosses the Y axis but not the X axis
            (and <i>mutatis mutandum</i>),
            the common bits for Y are zero,
            but the common bits for X are non-zero.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.Add(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Add a point to the set of geometries whose common bits are
            being computed.  After this method has executed the
            common coordinate reflects the common bits of all added
            geometries.
            </summary>
            <param name="geom">A Geometry to test for common bits.</param>
        </member>
        <member name="P:NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinate">
            <summary>
            The common bits of the Coordinates in the supplied Geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.RemoveCommonBits(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Removes the common coordinate bits from a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry from which to remove the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.AddCommonBits(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Adds the common coordinate bits back into a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry to which to add the common coordinate bits.</param>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="P:NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter.CommonCoordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBitsRemover.Translater">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.Translater.#ctor(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="trans"></param>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover.Translater.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
             <summary>
            
             </summary>
             <param name="seq">The coordinate sequence</param>
        </member>
        <member name="T:NetTopologySuite.Precision.CoordinatePrecisionReducerFilter">
            <summary>
            Reduces the precision of the <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s in a
            <see cref="T:NetTopologySuite.Geometries.CoordinateSequence"/> to match the supplied <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>.
            </summary>
            <remarks>
            Uses <see cref="M:NetTopologySuite.Geometries.PrecisionModel.MakePrecise(System.Double)"/>.
            The input is modified in-place, so
            it should be cloned beforehand if the
            original should not be modified.
            </remarks>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.#ctor(NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Creates a new precision reducer filter.
            </summary>
            <param name="precModel">The PrecisionModel to use</param>
        </member>
        <member name="M:NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.Filter(NetTopologySuite.Geometries.CoordinateSequence,System.Int32)">
            <summary>
            Rounds the Coordinates in the sequence to match the PrecisionModel
            </summary>
        </member>
        <member name="P:NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.Done">
            <summary>
            Always runs over all geometry components.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.GeometryChanged">
            <summary>
            Always reports that the geometry has changed
            </summary>
        </member>
        <member name="T:NetTopologySuite.Precision.EnhancedPrecisionOp">
            <summary>
            Provides versions of Geometry spatial functions which use
            enhanced precision techniques to reduce the likelihood of robustness problems.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.EnhancedPrecisionOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.EnhancedPrecisionOp.Intersection(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.EnhancedPrecisionOp.Union(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.EnhancedPrecisionOp.Difference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.EnhancedPrecisionOp.SymDifference(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the set-theoretic symmetric difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="T:NetTopologySuite.Precision.GeometryPrecisionReducer">
            <summary>
            Reduces the precision of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>
            according to the supplied <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/>,
            ensuring that the result is valid (unless specified otherwise).
            <para/>
            By default the geometry precision model is not changed.
            This can be overridden by using <see cref="P:NetTopologySuite.Precision.GeometryPrecisionReducer.ChangePrecisionModel"/>.
            <h4>Topological Precision Reduction</h4>
            The default mode of operation ensures the reduced result is topologically valid
            (i.e. <see cref="P:NetTopologySuite.Geometries.Geometry.IsValid"/> is true).
            To ensure this polygonal geometry is reduced in a topologically valid fashion
            (technically, by using snap-rounding).
            Note that this may change polygonal geometry structure
            (e.g.two polygons separated by a distance below the specified precision
            will be merged into a single polygon).
            Duplicate vertices are removed.
            This mode is invoked by the static method <see cref="M:NetTopologySuite.Precision.GeometryPrecisionReducer.Reduce(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)"/>.
            <para/>
            Normally, collapsed linear components(e.g.lines collapsing to a point)
            are not included in the result.
            This behavior can be changed
            by setting <see cref="P:NetTopologySuite.Precision.GeometryPrecisionReducer.RemoveCollapsedComponents"/> to <c>false</c>,
            or by using the static method <see cref="M:NetTopologySuite.Precision.GeometryPrecisionReducer.ReduceKeepCollapsed(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)"/>.
            <para/>
            In general input must be valid geometry, or an <see cref="T:System.ArgumentException"/>
            will be thrown. However if the invalidity is "mild" or very small then it
            may be eliminated by precision reduction.
            <h4> Pointwise Precision Reduction</h4>
            Alternatively, geometry can be reduced pointwise by using {@link #setPointwise(boolean)}.
            Linear and point geometry are always reduced pointwise(i.e.without further change to
            topology or structure), since this does not change validity.
            Invalid inputs are allowed.
            Duplicate vertices are preserved.
            Collapsed components are always included in the result.
            The result geometry may be invalid.
            <para/>
            This mode is invoked by the static method <see cref="M:NetTopologySuite.Precision.GeometryPrecisionReducer.ReducePointwise(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.GeometryPrecisionReducer.Reduce(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Reduces precision of a geometry, ensuring output geometry is valid.
            Collapsed linear and polygonal components are removed.
            The geometry precision model is not changed.
            Invalid input geometry may cause an error,
            unless the invalidity is below the scale of the precision reduction.
            </summary>
            <param name="g">The geometry to reduce</param>
            <param name="precModel">The precision model to use</param>
            <returns>The reduced geometry</returns>
            <exception cref="T:System.ArgumentException">Thrwon if the reduction fails due to invalid input geometry</exception>
        </member>
        <member name="M:NetTopologySuite.Precision.GeometryPrecisionReducer.ReduceKeepCollapsed(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Reduces precision of a geometry, ensuring output polygonal geometry is valid,
            and preserving collapsed linear elements.
            The geometry precision model is not changed.
            Invalid input geometry may cause an error,
            unless the invalidity is below the scale of the precision reduction.
            </summary>
            <param name="g">The geometry to reduce</param>
            <param name="precModel">The precision model to use</param>
            <returns>The reduced geometry</returns>
            <exception cref="T:System.ArgumentException">Thrwon if the reduction fails due to invalid input geometry</exception>
        </member>
        <member name="M:NetTopologySuite.Precision.GeometryPrecisionReducer.ReducePointwise(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Reduce precision of a geometry in a pointwise way.
            All input geometry elements are preserved in the output,
            including invalid polygons and collapsed polygons and linestrings.
            The output may not be valid, due to collapse or self-intersection.
            The geometry precision model is not changed.
            Invalid input geometry is allowed.
            </summary>
            <param name="g">The geometry to reduce</param>
            <param name="precModel">The precision model to use</param>
            <returns>The reduced geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Precision.GeometryPrecisionReducer.RemoveCollapsedComponents">
            <summary>Gets or sets whether the reduction will result in collapsed components
            being removed completely, or simply being collapsed to an (invalid)
            Geometry of the same type.
            The default is to remove collapsed components.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Precision.GeometryPrecisionReducer.ChangePrecisionModel">
            <summary>
            Gets or sets whether the <see cref = "T:NetTopologySuite.Geometries.PrecisionModel"/> of the new reduced Geometry
            will be changed to be the <see cref="T:NetTopologySuite.Geometries.PrecisionModel"/> supplied to
            specify the precision reduction.
            <para/>
            The default is to <b>not</b> change the precision model
            </summary>
        </member>
        <member name="P:NetTopologySuite.Precision.GeometryPrecisionReducer.Pointwise">
            <summary>
            Gets or sets whether the precision reduction will be done
            in pointwise fashion only.
            Pointwise precision reduction reduces the precision
            of the individual coordinates only, but does
            not attempt to recreate valid topology.
            This is only relevant for geometries containing polygonal components.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.GeometryPrecisionReducer.Reduce(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Reduces the precision of a geometry,
            according to the specified strategy of this reducer.
            </summary>
            <param name="geom">The geometry to reduce</param>
            <returns>The precision-reduced geometry</returns>
            <exception cref="T:System.ArgumentException">if the reduction fails
            due to input geometry is invalid.</exception>
        </member>
        <member name="M:NetTopologySuite.Precision.GeometryPrecisionReducer.ChangePM(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.PrecisionModel)">
            <summary>
            Duplicates a geometry to one that uses a different PrecisionModel,
            without changing any coordinate values.
            </summary>
            <param name="geom">The geometry to duplicate</param>
            <param name="pm">The precision model to use</param>
            <returns>The geometry value with a new precision model</returns>
        </member>
        <member name="T:NetTopologySuite.Precision.MinimumClearance">
            <summary>
            Computes the Minimum Clearance of a <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            <para/>
            The <b>Minimum Clearance</b> is a measure of
            what magnitude of perturbation of
            the vertices of a geometry can be tolerated
            before the geometry becomes topologically invalid.
            The smaller the Minimum Clearance distance,
            the less vertex perturbation the geometry can tolerate
            before becoming invalid.
            </summary>
            <remarks>
            The concept was introduced by Thompson and Van Oosterom
            [TV06], based on earlier work by Milenkovic [Mi88].
            <para/>
            The Minimum Clearance of a geometry G
            is defined to be the value <i>r</i>
            such that "the movement of all points by a distance
            of <i>r</i> in any direction will
            guarantee to leave the geometry valid" [TV06].
            An equivalent constructive definition [Mi88] is that
            <i>r</i> is the largest value such:
            <list type="bullet">
            <item><description>No two distinct vertices of G are closer than <i>r</i>.</description></item>
            <item><description>No vertex of G is closer than <i>r</i> to an edge of G of which the vertex is not an endpoint</description></item>
            </list>
            The following image shows an example of the Minimum Clearance
            of a simple polygon.
            <para/>
            <center><img src="/images/minClearance.png" alt="minimum clearance"/></center>
            <para/>
            If G has only a single vertex (i.e. is a
            <see cref="T:NetTopologySuite.Geometries.Point"/>), the value of the minimum clearance
            is <see cref="F:System.Double.MaxValue"/>.
            <para/>
            If G is a <see cref="T:NetTopologySuite.Geometries.IPuntal"/> or <see cref="T:NetTopologySuite.Geometries.ILineal"/> geometry,
            then in fact no amount of perturbation
            will render the geometry invalid.
            In this case a Minimum Clearance is still computed
            based on the vertex and segment distances
            according to the constructive definition.
            <para/>
            It is possible for no Minimum Clearance to exist.
            For instance, a <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> with all members identical
            has no Minimum Clearance
            (i.e. no amount of perturbation will cause
            the member points to become non-identical).
            Empty geometries also have no such distance.
            The lack of a meaningful MinimumClearance distance is detected
            and suitable values are returned by
            <see cref="M:NetTopologySuite.Precision.MinimumClearance.GetDistance"/> and <see cref="M:NetTopologySuite.Precision.MinimumClearance.GetLine"/>.
            <para/>
            The computation of Minimum Clearance utilizes
            the <see cref="M:NetTopologySuite.Index.Strtree.STRtree`1.NearestNeighbour(NetTopologySuite.Index.Strtree.IItemDistance{NetTopologySuite.Geometries.Envelope,`0})"/>
            method to provide good performance even for
            large inputs.
            <para/>
            An interesting note is that for the case of <see cref="T:NetTopologySuite.Geometries.MultiPoint"/>s,
            the computed Minimum Clearance line
            effectively determines the Nearest Neighbours in the collection.
            <h3>References</h3>
            <list type="bullet">
            <item><description>[Mi88] Milenkovic, V. J.,
            <i>Verifiable implementations of geometric algorithms
            using finite precision arithmetic</i>.
            in Artificial Intelligence, 377-401. 1988</description></item>
            <item><description>[TV06] Thompson, Rod and van Oosterom, Peter,
            <i>Interchange of Spatial Data-Inhibiting Factors</i>,
            Agile 2006, Visegrad, Hungary. 2006</description></item>
            </list>
            </remarks>
            /// <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Precision.MinimumClearance.GetDistance(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the Minimum Clearance distance for
            the given Geometry.
            </summary>
            <param name="g">The input geometry</param>
            <returns>The minimum clearance</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.MinimumClearance.GetLine(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets a LineString containing two points
            which are at the Minimum Clearance distance
            for the given Geometry.
            </summary>
            <param name="g">The input geometry</param>
            <returns>The value of the minimum clearance distance<br/>
            or <c>LINESTRING EMPTY</c> if no minimum clearance distance exists.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.MinimumClearance.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an object to compute the Minimum Clearance for the given Geometry
            </summary>
            <param name="geom">The input geometry</param>
        </member>
        <member name="M:NetTopologySuite.Precision.MinimumClearance.GetDistance">
            <summary>
            Gets the Minimum Clearance distance.
            <para>If no distance exists
             (e.g. in the case of two identical points)
            <see cref="F:System.Double.MaxValue"/> is returned.</para>
            </summary>
            <returns>
            The value of the minimum clearance distance<br/>
            or <see cref="F:System.Double.MaxValue"/> if no Minimum Clearance distance exists
            </returns>
        </member>
        <member name="M:NetTopologySuite.Precision.MinimumClearance.GetLine">
            <summary>
            Gets a LineString containing two points
            which are at the Minimum Clearance distance.<para/>
            If no distance could be found
            (e.g. in the case of two identical points)
            <c>LINESTRING EMPTY</c> is returned.
            </summary>
            <returns>The value of the minimum clearance distance, <br/>
            or <c>LINESTRING EMPTY</c> if no minimum clearance distance exists.</returns>
        </member>
        <member name="T:NetTopologySuite.Precision.MinimumClearance.MinClearanceDistance">
             <summary>
             Implements the MinimumClearance distance function:
             <code>
             dist(p1, p2) =
                 p1 != p2 : p1.distance(p2)
                 p1 == p2 : Double.MAX
            
             dist(p, seg) =
                 p != seq.p1 &amp;&amp; p != seg.p2
                     ? seg.distance(p)
                     : Double.MaxValue
             </code>
             Also computes the values of the nearest points, if any.
             </summary>
             <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Precision.PointwisePrecisionReducerTransformer">
            <summary>
            A transformer to reduce the precision of a geometry pointwise.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Precision.PrecisionReducerTransformer">
            <summary>
            A transformer to reduce the precision of geometry in a
            topologically valid way.<br/>
            Repeated points are removed.
            If geometry elements collapse below their valid length,
            they may be removed
            by specifying <c>isRemoveCollapsed</c> as <c>true</c>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Precision.PrecisionReducerTransformer.TransformPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Precision.PrecisionReducerTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="T:NetTopologySuite.Precision.SimpleMinimumClearance">
            <summary>
            Computes the minimum clearance of a geometry or
            set of geometries.<para/>
            The <b>Minimum Clearance</b> is a measure of
            what magnitude of perturbation of its vertices can be tolerated
            by a geometry before it becomes topologically invalid.
            <para/>
            This class uses an inefficient O(N^2) scan.
            It is primarily for testing purposes.
            </summary>
            <seealso cref="T:NetTopologySuite.Precision.MinimumClearance"/>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Shape.CubicBezierCurve">
            <summary>
            Creates a curved geometry by replacing the segments
            of the input with Cubic Bezier Curves.
            </summary>
            <remarks>
            The Bezier control points are determined from the segments of the geometry
            and the alpha control parameter controlling curvedness, and
            the optional skew parameter controlling the shape of the curve at vertices.
            The Bezier Curves are created to be C2-continuous (smooth)
            at each input vertex.
            <para/>
            Alternatively, the Bezier control points can be supplied explicitly.
            <para/>
            The result is not guaranteed to be valid, since large alpha values
            may cause self-intersections.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.Create(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates a geometry of linearized Cubic Bezier Curves
            defined by the segments of the input and a parameter
            controlling how curved the result should be.
            </summary>
            <param name="geom">The geometry defining the curve</param>
            <param name="alpha">A curvedness parameter (0 is linear, 1 is round, >1 is increasingly curved)</param>
            <returns>The linearized curved geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.Create(NetTopologySuite.Geometries.Geometry,System.Double,System.Double)">
            <summary>
            Creates a geometry of linearized Cubic Bezier Curves
            defined by the segments of the inputand a parameter
            controlling how curved the result should be, with a skew factor
            affecting the curve shape at each vertex.
            </summary>
            <param name="geom">The geometry defining the curve</param>
            <param name="alpha">The curvedness parameter (0 is linear, 1 is round, >1 is increasingly curved)</param>
            <param name="skew">The skew parameter (0 is none, positive skews towards longer side, negative towards shorter</param>
            <returns>The linearized curved geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.Create(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a geometry of linearized Cubic Bezier Curves
            defined by the segments of the input
            and a list (or lists) of control points.
            </summary>
            <remarks>
            Typically the control point geometry
            is a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>
            containing an element for each line or ring in the input geometry.
            The list of control points for each linear element must contain two
            vertices for each segment (and thus <code>2 * npts - 2</code>).
            </remarks>
            <param name="geom">The geometry defining the curve</param>
            <param name="controlPoints">A geometry containing the control point elements.</param>
            <returns>The linearized curved geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.#ctor(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Creates a new instance producing a Bezier curve defined by a geometry
            and an alpha curvedness value.
            </summary>
            <param name="geom">The geometry defining curve</param>
            <param name="alpha">A curvedness parameter (0 = linear, 1 = round, 2 = distorted)</param>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.#ctor(NetTopologySuite.Geometries.Geometry,System.Double,System.Double)">
            <summary>
            Creates a new instance producing a Bezier curve defined by a geometry,
            an alpha curvedness value, and a skew factor.
            </summary>
            <param name="geom">The geometry defining curve</param>
            <param name="alpha">curvedness parameter (0 is linear, 1 is round, >1 is increasingly curved)</param>
            <param name="skew">The skew parameter (0 is none, positive skews towards longer side, negative towards shorter</param>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.#ctor(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a new instance producing a Bezier curve defined by a geometry,
            and a list (or lists) of control points.
            </summary><remarks>
            <para/>
            Typically the control point geometry
            is a <see cref="T:NetTopologySuite.Geometries.LineString"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>
            containing an element for each line or ring in the input geometry.
            The list of control points for each linear element must contain two
            vertices for each segment (and thus <code>2 * npts - 2</code>).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.GetResult">
            <summary>
            Gets the computed Bezier curve geometry
            </summary>
            <returns>The curved geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.ControlPoints(NetTopologySuite.Geometries.Coordinate[],System.Boolean,System.Double,System.Double)">
            <summary>
            Creates control points for each vertex of curve.
            The control points are collinear with each vertex,
            thus providing C1-continuity.
            By default the control vectors are the same length,
            which provides C2-continuity(same curvature on each
            side of vertex.
            The alpha parameter controls the length of the control vectors.
            Alpha = 0 makes the vectors zero-length, and hence flattens the curves.
            Alpha = 1 makes the curve at right angles roughly circular.
            Alpha > 1 starts to distort the curve and may introduce self-intersections.
            <para/>
            The control point array contains a pair of coordinates for each input segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.SetLineEndControlPoints(NetTopologySuite.Geometries.Coordinate[],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Sets the end control points for a line.
            Produce a symmetric curve for the first and last segments
            by using mirrored control points for start and end vertex.
            </summary>
            <param name="coords">The coordinates</param>
            <param name="ctrl">The control points</param>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.AimedControlPoint(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a control point aimed at the control point at the opposite end of the segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.CubicBezier(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Double[][],NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Calculates vertices along a cubic Bezier curve.
            </summary>
            <param name="p0">The start point</param>
            <param name="p1">The end point</param>
            <param name="ctrl1">The first control point</param>
            <param name="ctrl2">The second control point</param>
            <param name="param">A set of interpolation parameters</param>
            <param name="curve">An array to hold generated points.</param>
        </member>
        <member name="M:NetTopologySuite.Shape.CubicBezierCurve.ComputeIterpolationParameters(System.Int32)">
            <summary>
            Gets the interpolation parameters for a Bezier curve approximated by a
            given number of vertices.
            </summary>
            <param name="n">The number of vertices</param>
            <returns>An array of double[4] holding the parameter values</returns>
        </member>
        <member name="T:NetTopologySuite.Shape.Fractal.HilbertCode">
            <summary>
            Encodes points as the index along finite planar Hilbert curves.
            <para>
            The planar Hilbert Curve is a continuous space-filling curve.
            In the limit the Hilbert curve has infinitely many vertices and fills
            the space of the unit square.
            A sequence of finite approximations to the infinite Hilbert curve
            is defined by the level number.
            The finite Hilbert curve at level n H contains 2 points.
            Each finite Hilbert curve defines an ordering of the
            points in the 2-dimensional range square containing the curve.
            Curves fills the range square of side 2.
            Curve points have ordinates in the range [0, 2 - 1].
            The index of a point along a Hilbert curve is called the Hilbert code.
            The code for a given point is specific to the level chosen.
            </para>
            <para>
            This implementation represents codes using 32-bit integers.
            This allows levels 0 to 16 to be handled.
            The class supports encoding points in the range of a given level curve
            and decoding the point for a given code value.
            </para>
            <para>
            The Hilbert order has the property that it tends to preserve locality.
            This means that codes which are near in value will have spatially proximate
            points.  The converse is not always true - the delta between
            codes for nearby points is not always small.  But the average delta
            is small enough that the Hilbert order is an effective way of linearizing space
            to support range queries.
            </para>
            </summary>
            <author>
            Martin Davis
            </author>
            <seealso cref="T:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder"/>
            <seealso cref="T:NetTopologySuite.Shape.Fractal.MortonCode"/>
        </member>
        <member name="F:NetTopologySuite.Shape.Fractal.HilbertCode.MaxLevel">
            <summary>
            The maximum curve level that can be represented.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.Size(System.Int32)">
            <summary>
            The number of points in the curve for the given level.
            The number of points is 2.
            </summary>
            <param name="level">The level of the curve</param>
            <returns>The number of points.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.MaxOrdinate(System.Int32)">
            <summary>
            The maximum ordinate value for points
            in the curve for the given level.
            The maximum ordinate is 2 - 1.
            </summary>
            <param name="level">The level of the curve.</param>
            <returns>The maximum ordinate value.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.Level(System.Int32)">
            <summary>
            The level of the finite Hilbert curve which contains at least
            the given number of points.
            </summary>
            <param name="numPoints">The number of points required.</param>
            <returns>The level of the curve.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.Encode(System.Int32,System.Int32,System.Int32)">
            <summary>
            Encodes a point (x,y)
            in the range of the the Hilbert curve at a given level
            as the index of the point along the curve.
            The index will lie in the range [0, 2].
            </summary>
            <param name="level">The level of the Hilbert curve.</param>
            <param name="x">The x ordinate of the point.</param>
            <param name="y">The y ordinate of the point.</param>
            <returns>The index of the point along the Hilbert curve.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.LevelClamp(System.Int32)">
            <summary>
            Clamps a level to the range valid for
            the index algorithm used.
            </summary>
            <param name="level">The level of a Hilbert curve.</param>
            <returns>A valid level.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCode.Decode(System.Int32,System.Int32)">
            <summary>
            Computes the point on a Hilbert curve
            of given level for a given code index.
            The point ordinates will lie in the range [0, 2 - 1].
            </summary>
            <param name="level">The Hilbert curve level.</param>
            <param name="index">The index of the point on the curve.</param>
            <returns>The point on the Hilbert curve.</returns>
        </member>
        <member name="T:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder">
            <summary>
            Generates a <see cref="T:NetTopologySuite.Geometries.LineString"/> representing the Hilbert Curve
            at a given level.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder"/> class
            using the provided <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geomFactory">The geometry factory to use.</param>
        </member>
        <member name="P:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.Level">
            <summary>
            Gets or sets the level of curve to generate.
            The level must be in the range [0 - 16].
            This determines the
            number of points in the generated curve.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.GetGeometry">
            <inheritdoc />
        </member>
        <member name="F:NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder.HeightFactor">
            <summary>
            The height of an equilateral triangle of side one
            </summary>
        </member>
        <member name="T:NetTopologySuite.Shape.Fractal.MortonCode">
            <summary>
            Encodes points as the index along the planar Morton (Z-order) curve.
            <para>
            The planar Morton (Z-order) curve is a continuous space-filling curve.
            The Morton curve defines an ordering of the
            points in the positive quadrant of the plane.
            The index of a point along the Morton curve is called the Morton code.
            </para>
            <para>
            A sequence of subsets of the Morton curve can be defined by a level number.
            Each level subset occupies a square range.
            The curve at level n M contains 2 points.
            It fills the range square of side 2.
            Curve points have ordinates in the range [0, 2 - 1].
            The code for a given point is identical at all levels.
            The level simply determines the number of points in the curve subset
            and the size of the range square.
            </para>
            <para>
            This implementation represents codes using 32-bit integers.
            This allows levels 0 to 16 to be handled.
            The class supports encoding points
            and decoding the point for a given code value.
            </para>
            <para>
            The Morton order has the property that it tends to preserve locality.
            This means that codes which are near in value will have spatially proximate
            points.  The converse is not always true - the delta between
            codes for nearby points is not always small.  But the average delta
            is small enough that the Morton order is an effective way of linearizing space
            to support range queries.
            </para>
            </summary>
            <author>
            Martin Davis
            </author>
            <seealso cref="T:NetTopologySuite.Shape.Fractal.MortonCurveBuilder"/>
            <seealso cref="T:NetTopologySuite.Shape.Fractal.HilbertCode"/>
        </member>
        <member name="F:NetTopologySuite.Shape.Fractal.MortonCode.MaxLevel">
            <summary>
            The maximum curve level that can be represented.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCode.Size(System.Int32)">
            <summary>
            The number of points in the curve for the given level.
            The number of points is 2.
            </summary>
            <param name="level">The level of the curve</param>
            <returns>The number of points.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCode.MaxOrdinate(System.Int32)">
            <summary>
            The maximum ordinate value for points
            in the curve for the given level.
            The maximum ordinate is 2 - 1.
            </summary>
            <param name="level">The level of the curve.</param>
            <returns>The maximum ordinate value.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCode.Level(System.Int32)">
            <summary>
            The level of the finite Morton curve which contains at least
            the given number of points.
            </summary>
            <param name="numPoints">The number of points required.</param>
            <returns>The level of the curve.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCode.Encode(System.Int32,System.Int32)">
            <summary>
            Computes the index of the point (x,y)
            in the Morton curve ordering.
            </summary>
            <param name="x">The x ordinate of the point.</param>
            <param name="y">The y ordinate of the point.</param>
            <returns>The index of the point along the Morton curve.</returns>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCode.Decode(System.Int32)">
            <summary>
            Computes the point on the Morton curve
            for a given index.
            </summary>
            <param name="index">The index of the point on the curve.</param>
            <returns>The point on the curve.</returns>
        </member>
        <member name="T:NetTopologySuite.Shape.Fractal.MortonCurveBuilder">
            <summary>
            Generates a <see cref="T:NetTopologySuite.Geometries.LineString"/> representing the Morton Curve
            at a given level.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCurveBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Shape.Fractal.MortonCurveBuilder"/> class
            using the provided <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geomFactory">The geometry factory to use.</param>
        </member>
        <member name="P:NetTopologySuite.Shape.Fractal.MortonCurveBuilder.Level">
            <summary>
            Gets or sets the level of curve to generate.
            The level must be in the range [0 - 16].
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Fractal.MortonCurveBuilder.GetGeometry">
            <inheritdoc />
        </member>
        <member name="P:NetTopologySuite.Shape.GeometricShapeBuilder.NumPoints">
            <summary>
            Gets or sets the total number of points in the created <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            The created geometry will have no more than this number of points,
            unless more are needed to create a valid geometry.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Shape.Random.RandomPointsBuilder">
            <summary>
            Creates random point sets contained in a
            region defined by either a rectangular or a polygonal extent.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsBuilder.#ctor">
            <summary>
            Create a shape factory which will create shapes using the default
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create a shape factory which will create shapes using the given
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>
            </summary>
            <param name="geomFact">The factory to use</param>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsBuilder.SetExtent(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets a polygonal mask.
            </summary>
            <exception cref="T:System.ArgumentException">if the mask is not polygonal</exception>
        </member>
        <member name="T:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder">
            <summary>
            Creates random point sets where the points
            are constrained to lie in the cells of a grid.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.#ctor">
            <summary>
            Create a builder which will create shapes using the default
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create a builder which will create shapes using the given
            <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geomFact">The factory to use</param>
        </member>
        <member name="P:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.ConstrainedToCircle">
            <summary>
            Gets or sets whether generated points are constrained to lie
            within a circle contained within each grid cell.
            This provides greater separation between points
            in adjacent cells.
            <para/>
            The default is to not be constrained to a circle.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.GutterFraction">
            <summary>
            Gets or sets the fraction of the grid cell side which will be treated as
            a gutter, in which no points will be created.
            <para/>
            The provided value is clamped to the range [0.0, 1.0].
            </summary>
        </member>
        <member name="M:NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.GetGeometry">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Geometries.MultiPoint"/> containing the generated point
            </summary>
            <returns>A MultiPoint</returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier">
            <summary>
            Simplifies a line (sequence of points) using
            the standard Douglas-Peucker algorithm.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.Simplify(NetTopologySuite.Geometries.Coordinate[],System.Double)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="distanceTolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates an instance of this class using the provided <paramref name="pts"/> array of coordinates
            </summary>
            <param name="pts">An array of coordinates</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.DistanceTolerance">
            <summary>
            The distance tolerance for the simplification.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.Simplify">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.DouglasPeuckerSimplifier">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.Geometry"/> using the Douglas-Peucker algorithm.
            </summary>
            <remarks>
            Ensures that any polygonal geometries returned are valid.
            Simple lines are not guaranteed to remain simple after simplification.
            All geometry types are handled.
            Empty and point geometries are returned unchanged.
            Empty geometry components are deleted.
            <para/>
            Note that in general D-P does not preserve topology -
            e.g. polygons can be split, collapse to lines or disappear
            holes can be created or disappear,
            and lines can cross.
            To simplify point while preserving topology use TopologySafeSimplifier.
            (However, using D-P is significantly faster).
            <para/>
            KNOWN BUGS:
            In some cases the approach used to clean invalid simplified polygons
            can distort the output geometry severely.
            </remarks>
            <seealso cref="T:NetTopologySuite.Simplify.TopologyPreservingSimplifier"/>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.Simplify(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Simplifies a geometry using a given tolerance.
            </summary>
            <param name="geom">The geometry to simplify.</param>
            <param name="distanceTolerance">The tolerance to use.</param>
            <returns>A simplified version of the geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a simplifier for a given geometry.
            </summary>
            <param name="inputGeom">The geometry to simplify.</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DistanceTolerance">
            <summary>
            The distance tolerance for the simplification.
            </summary>
            <remarks>
            All vertices in the simplified geometry will be within this
            distance of the original geometry.
            The tolerance value must be non-negative.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.EnsureValidTopology">
            <summary>
            Controls whether simplified polygons will be "fixed"
            to have valid topology.
            </summary>
            <remarks>
            The caller may choose to disable this because:
            <list type="bullet">
            <item><description>valid topology is not required</description></item>
            <item><description>fixing topology is a relative expensive operation</description></item>
            <item><description>in some pathological cases the topology fixing operation may either fail or run for too long</description></item>
            </list>
            The default is to fix polygon topology.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.GetResultGeometry">
            <summary>
            Gets the simplified geometry.
            </summary>
            <returns>The simplified geometry.</returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer">
            <summary>
            The transformer class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Simplifies a polygon, fixing it if required.
            </summary>
            <param name="geom">The geometry to transform</param>
            <param name="parent">The parent geometry</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformLinearRing(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Simplifies a LinearRing.  If the simplification results in a degenerate ring, remove the component.
            </summary>
            <returns>null if the simplification results in a degenerate ring</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)"/>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier.DPTransformer.CreateValidArea(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a valid area point from one that possibly has
            bad topology (i.e. self-intersections).
            Since buffer can handle invalid topology, but always returns
            valid point, constructing a 0-width buffer "corrects" the
            topology.
            Note this only works for area geometries, since buffer always returns
            areas.  This also may return empty geometries, if the input
            has no actual area.<br/>
            If the input is empty or is not polygonal,
            this ensures that POLYGON EMPTY is returned.
            </summary>
            <param name="rawAreaGeom">An area point possibly containing self-intersections.</param>
            <returns>A valid area point.</returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.LineSegmentIndex">
            <summary>
            An index of LineSegments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentIndex.Add(NetTopologySuite.Simplify.TaggedLineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentIndex.Add(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentIndex.Remove(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentIndex.Query(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="querySeg"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.LineSegmentVisitor">
            <summary>
            ItemVisitor subclass to reduce volume of query results.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentVisitor.#ctor(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="querySeg"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.LineSegmentVisitor.VisitItem(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="P:NetTopologySuite.Simplify.LineSegmentVisitor.Items">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Simplify.OldVWLineSimplifier">
            <summary>
            Simplifies a linestring (sequence of points) using the
            Visvalingam-Whyatt algorithm.
            The Visvalingam-Whyatt algorithm simplifies geometry
            by removing vertices while trying to minimize the area changed.
            </summary>
            <version>1.7</version>
        </member>
        <member name="T:NetTopologySuite.Simplify.PolygonHullSimplifier">
            <summary>
            Computes topology-preserving simplified hulls of polygonal geometry.
            Both outer and inner hulls can be computed.
            Outer hulls contain the input geometry and are larger in area.
            Inner hulls are contained by the input geometry and are smaller in area.
            In both the hull vertices are a subset of the input vertices.
            The hull construction attempts to minimize the area difference
            with the input geometry.
            <para/>
            Hulls are generally concave if the input is.
            Computed hulls are topology-preserving: 
            they do not contain any self-intersections or overlaps, 
            so the result polygonal geometry is valid.
            <para/>
            Polygons with holes and MultiPolygons are supported.
            The result has the same geometric type and structure as the input.
            <para/>
            The number of vertices in the computed hull is determined by a target parameter.
            Two parameters are supported:
            <list type="bullet">
            <item><term>Vertex Number fraction</term><description>the fraction of the input vertices retained in the result.
            Value 1 produces the original geometry.
            Smaller values produce less concave results.
            For outer hulls, value 0 produces the convex hull (with triangles for any holes).
            For inner hulls, value 0 produces a triangle (if no holes are present).</description></item>
            <item><term>Area Delta ratio</term><description>
            the ratio of the change in area to the input area.Value 0 produces the original geometry.
            Larger values produce less concave results.</description></item>
            </list>
            The algorithm ensures that the result does not cause the target parameter
            to be exceeded. This allows computing outer or inner hulls
            with a small area delta ratio as an effective way of removing
            narrow gores and spikes.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.Hull(NetTopologySuite.Geometries.Geometry,System.Boolean,System.Double)">
            <summary>
            Computes topology-preserving simplified hull of a polygonal geometry,
            with hull shape determined by a target parameter
            specifying the fraction of the input vertices retained in the result.
            Larger values compute less concave results.
            A value of 1 produces the convex hull; a value of 0 produces the original geometry.
            Either outer or inner hulls can be computed.
            </summary>
            <param name="geom">The polygonal geometry to process</param>
            <param name="isOuter">A flag indicating whether to compute an outer or inner hull</param>
            <param name="vertexNumFraction">The target fraction of number of input vertices in result</param>
            <returns>The hull geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.HullByAreaDelta(NetTopologySuite.Geometries.Geometry,System.Boolean,System.Double)">
            <summary>Computes a boundary-respecting hull of a polygonal geometry,
            with hull shape determined by a target parameter
            specifying the ratio of maximum difference in area to original area.
            Larger values compute less concave results.
            A value of 0 produces the original geometry.
            Either outer or inner hulls can be computed.
            </summary>
            <param name="geom">The polygonal geometry to process</param>
            <param name="isOuter">A flag indicating whether to compute an outer or inner hull</param>
            <param name="areaDeltaRatio">The target ratio of area difference to original area</param>
            <returns>The hull geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.#ctor(NetTopologySuite.Geometries.Geometry,System.Boolean)">
            <summary>
            Creates a new instance
            to compute a simplified hull of a polygonal geometry.
            An outer or inner hull is computed
            depending on the value of <paramref name="isOuter"/>. 
            </summary>
            <param name="inputGeom">The polygonal geometry to process</param>
            <param name="isOuter">Indicates whether to compute an outer or inner hull</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.PolygonHullSimplifier.VertexNumFraction">
            <summary>
            Gets or sets a value indicating the target fraction of input vertices
            which are retained in the result.
            The value should be in the range [0,1].
            </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.PolygonHullSimplifier.AreaDeltaRatio">
            <summary>
            Gets or sets a value indicating the target maximum ratio of the change in area of the result to the input area.
            The value must be 0 or greater.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.GetResult">
            <summary>
            Gets the result polygonal hull geometry.
            </summary>
            <returns>The polygonal geometry for the hull</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.ComputeMultiPolygonAll(NetTopologySuite.Geometries.MultiPolygon)">
            <summary>
            Computes hulls for MultiPolygon elements for
            the cases where hulls might overlap.
            </summary>
            <param name="multiPoly">The MultiPolygon to process</param>
            <returns>The hull geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.PolygonHullSimplifier.InitPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Simplify.RingHullIndex)">
            <summary>
            Create all ring hulls for the rings of a polygon,
            so that all are in the hull index if required.
            </summary>
            <param name="poly" >The polygon being processed</param>
            <param name="hullIndex">The hull index if present, or <c>null</c></param>
            <returns>A list of ring hulls</returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.RingHull">
            <summary>
            Computes the outer or inner hull of a ring
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Simplify.RingHull.#ctor(NetTopologySuite.Geometries.LinearRing,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="ring">The ring vertices to process</param>
            <param name="isOuter">A flag whether the hull is outer or inner</param>
        </member>
        <member name="M:NetTopologySuite.Simplify.RingHull.RemoveCorner(NetTopologySuite.Simplify.RingHull.Corner,NetTopologySuite.Utilities.PriorityQueue{NetTopologySuite.Simplify.RingHull.Corner})">
            <summary>
            Removes a corner by removing the apex vertex from the ring.
            Two new corners are created with apexes
            at the other vertices of the corner
            (if they are non-convex and thus removable).
            </summary>
            <param name="corner">The corner to remove</param>
            <param name="cornerQueue">The corner queue</param>
        </member>
        <member name="M:NetTopologySuite.Simplify.RingHull.HasIntersectingVertex(NetTopologySuite.Simplify.RingHull.Corner,NetTopologySuite.Geometries.Envelope,NetTopologySuite.Simplify.RingHull)">
            Tests if any vertices in a hull intersect the corner triangle.
            Uses the vertex spatial index for efficiency.
            
            @param corner the corner vertices
            @param cornerEnv the envelope of the corner
            @param hull the hull to test
            @return true if there is an intersecting vertex
        </member>
        <member name="M:NetTopologySuite.Simplify.RingHull.Corner.CompareTo(NetTopologySuite.Simplify.RingHull.Corner)">
            Orders corners by increasing area
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLineSegment">
            <summary>
            A LineSegment which is tagged with its location in a <c>Geometry</c>.
            Used to index the segments in a point and recover the segment locations
            from the index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineSegment.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Geometry,System.Int32)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="parent"></param>
             <param name="index"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineSegment.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineSegment.Parent">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineSegment.Index">
             <summary>
            
             </summary>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLinesSimplifier">
            <summary>
            Simplifies a collection of <c>TaggedLineString</c>s, preserving topology
            (in the sense that no new intersections are introduced).
            This class is essentially just a container for the common
            indexes used by <see cref="T:NetTopologySuite.Simplify.TaggedLineStringSimplifier"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLinesSimplifier.DistanceTolerance">
            <summary>
            Gets or sets the distance tolerance for the simplification.<br/>
            Points closer than this tolerance to a simplified segment may
            be removed.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLinesSimplifier.Simplify(System.Collections.Generic.ICollection{NetTopologySuite.Simplify.TaggedLineString})">
            <summary>
            Simplifies a collection of <c>TaggedLineString</c>s.
            </summary>
            <param name="taggedLines">The collection of lines to simplify.</param>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLineString">
            <summary>
            Represents a <see cref="T:NetTopologySuite.Geometries.LineString"/> which can be modified to a simplified shape.
            This class provides an attribute which specifies the minimum allowable length
            for the modified result.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.#ctor(NetTopologySuite.Geometries.LineString)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.#ctor(NetTopologySuite.Geometries.LineString,System.Int32)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
             <param name="minimumSize"></param>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.MinimumSize">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.Parent">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.ParentCoordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.ResultCoordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.ResultSize">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.GetSegment(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.Init">
             <summary>
            
             </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineString.Segments">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.AddToResult(NetTopologySuite.Geometries.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.AsLineString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.AsLinearRing">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineString.ExtractCoordinates(System.Collections.Generic.IList{NetTopologySuite.Geometries.LineSegment})">
             <summary>
            
             </summary>
             <param name="segs"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLineStringSimplifier">
            <summary>
            Simplifies a TaggedLineString, preserving topology
            (in the sense that no new intersections are introduced).
            Uses the recursive Douglas-Peucker  algorithm.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLineStringSimplifier.DistanceTolerance">
            <summary>
            Sets the distance tolerance for the simplification.
            All vertices in the simplified geometry will be within this
            distance of the original geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier.Simplify(NetTopologySuite.Simplify.TaggedLineString)">
            <summary>
            Simplifies the given <see cref="T:NetTopologySuite.Simplify.TaggedLineString"/>
            using the distance tolerance specified.
            </summary>
            <param name="line">The linestring to simplify.</param>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier.Flatten(System.Int32,System.Int32)">
            <summary>
            Flattens a section of the line between
            indexes <paramref name="start"/> and <paramref name="end"/>,
            replacing them with a line between the endpoints.
            The input and output indexes are updated
            to reflect this.
            </summary>
            <param name="start">The start index of the flattened section.</param>
            <param name="end">The end index of the flattened section.</param>
            <returns>The new segment created.</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier.IsInLineSection(NetTopologySuite.Simplify.TaggedLineString,System.Int32[],NetTopologySuite.Simplify.TaggedLineSegment)">
            <summary>
            Tests whether a segment is in a section of a <see cref="T:NetTopologySuite.Simplify.TaggedLineString"/>.
            </summary>
            <param name="line"></param>
            <param name="sectionIndex"></param>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier.Remove(NetTopologySuite.Simplify.TaggedLineString,System.Int32,System.Int32)">
            <summary>
            Remove the segs in the section of the line.
            </summary>
            <param name="line"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="T:NetTopologySuite.Simplify.TopologyPreservingSimplifier">
            <summary>
            Simplifies a point and ensures that
            the result is a valid point having the
            same dimension and number of components as the input,
            and with the components having the same topological
            relationship.
            <para/>
            If the input is a polygonal geometry
            (<see cref="T:NetTopologySuite.Geometries.Polygon"/> or <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/>):
            <list type="bullet">
            <item><description>The result has the same number of shells and holes as the input,
             with the same topological structure</description></item>
            <item><description>The result rings touch at no more than the number of touching points in the input
            (although they may touch at fewer points).
            The key implication of this statement is that if the
            input is topologically valid, so is the simplified output.</description></item>
            </list>
            For linear geometries, if the input does not contain
            any intersecting line segments, this property
            will be preserved in the output.
            <para/>
            For all geometry types, the result will contain
            enough vertices to ensure validity.  For polygons
            and closed linear geometries, the result will have at
            least 4 vertices; for open LineStrings the result
            will have at least 2 vertices.
            <para/>
            All geometry types are handled.
            Empty and point geometries are returned unchanged.
            Empty geometry components are deleted.
            <para/>
            The simplification uses a maximum-distance difference algorithm
            similar to the Douglas-Peucker algorithm.
            </summary>
            <remarks>
            <h3>KNOWN BUGS</h3>
            <list type="bullet">
            <item><description>May create invalid topology if there are components which are small
            relative to the tolerance value.
            In particular, if a small hole is very near an edge,
            it is possible for the edge to be moved by a relatively large tolerance value
            and end up with the hole outside the result shell (or inside another hole).
            Similarly, it is possible for a small polygon component to end up inside
            a nearby larger polygon.
            A workaround is to test for this situation in post-processing and remove
            any invalid holes or polygons.</description></item>
            </list>
            </remarks>
            <seealso cref="T:NetTopologySuite.Simplify.DouglasPeuckerSimplifier"/>
        </member>
        <member name="M:NetTopologySuite.Simplify.TopologyPreservingSimplifier.Simplify(NetTopologySuite.Geometries.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="distanceTolerance"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.TopologyPreservingSimplifier.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates an instance of this class for the provided <paramref name="inputGeom"/> geometry
            </summary>
            <param name="inputGeom">The geometry to simplify</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.TopologyPreservingSimplifier.DistanceTolerance">
            <summary>
            Gets or sets the distance tolerance for the simplification.<br/>
            Points closer than this tolerance to a simplified segment may
            be removed.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TopologyPreservingSimplifier.GetResultGeometry">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.TopologyPreservingSimplifier.LineStringTransformer">
            <summary>
            A LineString transformer
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TopologyPreservingSimplifier.LineStringTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer.TransformCoordinates(NetTopologySuite.Geometries.CoordinateSequence,NetTopologySuite.Geometries.Geometry)"/>>
        </member>
        <member name="T:NetTopologySuite.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter">
            <summary>
            A filter to add linear geometries to the LineString map
            with the appropriate minimum size constraint.
            Closed <see cref="T:NetTopologySuite.Geometries.LineString"/>s (including <see cref="T:NetTopologySuite.Geometries.LinearRing"/>s
            have a minimum output size constraint of 4,
            to ensure the output is valid.
            For all other LineStrings, the minimum size is 2 points.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.Filter(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Filters linear geometries.
            </summary>
            <param name="geom">A geometry of any type</param>
        </member>
        <member name="T:NetTopologySuite.Simplify.VWLineSimplifier">
            <summary>
            Simplifies a linestring (sequence of points) using the
            Visvalingam-Whyatt algorithm.
            The Visvalingam-Whyatt algorithm simplifies geometry
            by removing vertices while trying to minimize the area changed.
            </summary>
            <version>1.7</version>
        </member>
        <member name="T:NetTopologySuite.Simplify.VWSimplifier">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.Geometry"/> using the Visvalingam-Whyatt area-based algorithm.
            Ensures that any polygonal geometries returned are valid. Simple lines are not
            guaranteed to remain simple after simplification. All geometry types are
            handled. Empty and point geometries are returned unchanged. Empty geometry
            components are deleted.
            The simplification tolerance is specified as a distance.
            This is converted to an area tolerance by squaring it.
            <para>
            <b>Known Bugs</b>
            * Not yet optimized for performance.
            * Does not simplify the endpoint of rings.
            <b>To Do</b>
            * Allow specifying desired number of vertices in the output.
            </para>
            </summary>
            <remarks>
            Note that in general this algorithm does not preserve topology - e.g. polygons can be split,
            collapse to lines or disappear holes can be created or disappear, and lines
            can cross.
            </remarks>
            <version>1.7</version>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.Simplify(NetTopologySuite.Geometries.Geometry,System.Double)">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.Geometry"/> using a given tolerance.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to simplify.</param>
            <param name="distanceTolerance">The tolerance to use.</param>
            <returns>A simplified version of the <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a simplifier for a given <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="inputGeom">The <see cref="T:NetTopologySuite.Geometries.Geometry"/> to simplify.</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.VWSimplifier.DistanceTolerance">
            <summary>
            Sets the distance tolerance for the simplification. All vertices in the
            simplified <see cref="T:NetTopologySuite.Geometries.Geometry"/> will be within this distance of the original geometry.
            The tolerance value must be non-negative.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Simplify.VWSimplifier.IsEnsureValidTopology">
            <summary>
            Controls whether simplified polygons will be "fixed" to have valid
            topology. The caller may choose to disable this because:
            * valid topology is not required.
            * fixing topology is a relative expensive operation.
            * in some pathological cases the topology fixing operation may either
            fail or run for too long.
            </summary>
            <remarks>The default is to fix polygon topology.</remarks>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.GetResultGeometry">
            <summary>
            Gets the simplified <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <returns>The simplified <see cref="T:NetTopologySuite.Geometries.Geometry"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.VWTransformer.TransformPolygon(NetTopologySuite.Geometries.Polygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.Polygon"/>, fixing it if required.
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.VWTransformer.TransformLinearRing(NetTopologySuite.Geometries.LinearRing,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.LinearRing"/>. If the simplification results in a degenerate
            ring, remove the component.
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns><c>null</c> if the simplification results in a degenerate ring.</returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.VWTransformer.TransformMultiPolygon(NetTopologySuite.Geometries.MultiPolygon,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Simplifies a <see cref="T:NetTopologySuite.Geometries.MultiPolygon"/>, fixing it if required.
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Simplify.VWSimplifier.VWTransformer.CreateValidArea(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Creates a valid area geometry from one that possibly has bad topology
            (i.e. self-intersections). Since buffer can handle invalid topology, but
            always returns valid geometry, constructing a 0-width buffer "corrects"
            the topology. Note this only works for area geometries, since buffer
            always returns areas. This also may return empty geometries, if the input
            has no actual area.
            </summary>
            <param name="rawAreaGeom">An area geometry possibly containing self-intersections.</param>
            <returns>A valid area geometry.</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder">
            <summary>
            A utility class which creates Conforming Delaunay Triangulations
            from collections of points and linear constraints, and extract the resulting
            triangulation edges or triangles as geometries.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.SetSites(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets the sites (point or vertices) which will be triangulated.
            All vertices of the given geometry will be used as sites.
            The site vertices do not have to contain the constraint
            vertices as well; any site vertices which are
            identical to a constraint vertex will be removed
            from the site vertex set.
            </summary>
            <remarks>The geometry from which the sites will be extracted.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.Constraints">
            <summary>
            Sets the linear constraints to be conformed to.
            All linear components in the input will be used as constraints.
            The constraint vertices do not have to be disjoint from
            the site vertices.
            The constraints must not contain duplicate segments (up to orientation).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.Tolerance">
            <summary>
            Sets the snapping tolerance which will be used
            to improved the robustness of the triangulation computation.
            A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.GetSubdivision">
            <summary>
            Gets the QuadEdgeSubdivision which models the computed triangulation.
            </summary>
            <returns>The subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.GetEdges(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the edges of the computed triangulation as a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <param name="geomFact">The geometry factory to use to create the output</param>
            <returns>the edges of the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.GetTriangles(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the faces of the computed triangulation as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>.
            </summary>
            <param name="geomFact">the geometry factory to use to create the output</param>
            <returns>the faces of the triangulation</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator">
             <summary>
             Computes a Conforming Delaunay Triangulation over a set of sites and a set of
             linear constraints.
             </summary>
             <remarks>
             <para>
             A conforming Delaunay triangulation is a true Delaunay triangulation. In it
             each constraint segment is present as a union of one or more triangulation
             edges. Constraint segments may be subdivided into two or more triangulation
             edges by the insertion of additional sites. The additional sites are called
             Steiner points, and are necessary to allow the segments to be faithfully
             reflected in the triangulation while maintaining the Delaunay property.
             Another way of stating this is that in a conforming Delaunay triangulation
             every constraint segment will be the union of a subset of the triangulation
             edges (up to tolerance).
             </para>
             <para>
             A Conforming Delaunay triangulation is distinct from a Constrained Delaunay triangulation.
             A Constrained Delaunay triangulation is not necessarily fully Delaunay,
             and it contains the constraint segments exactly as edges of the triangulation.
             </para>
             <para>
             A typical usage pattern for the triangulator is:
             <code>
               ConformingDelaunayTriangulator cdt = new ConformingDelaunayTriangulator(sites, tolerance);
            
               // optional
               cdt.SplitPointFinder = splitPointFinder;
               cdt.VertexFactory = vertexFactory;
            
               cdt.SetConstraints(segments,  new List&lt;Vertex&gt;(vertexMap.Values));
               cdt.FormInitialDelaunay();
               cdt.EnforceConstraints();
               subdiv = cdt.Subdivision;
             </code>
             </para>
             </remarks>
             <author>David Skea</author>
             <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.QuadEdge.Vertex},System.Double)">
            <summary>
            Creates a Conforming Delaunay Triangulation based on the given
            unconstrained initial vertices. The initial vertex set should not contain
            any vertices which appear in the constraint set.
            </summary>
            <param name="initialVertices">a collection of <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex"/></param>
            <param name="tolerance">the distance tolerance below which points are considered identical</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.SetConstraints(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Segment},System.Collections.Generic.IList{NetTopologySuite.Triangulate.QuadEdge.Vertex})">
            <summary>
            Sets the constraints to be conformed to by the computed triangulation.
            The constraints must not contain duplicate segments (up to orientation).
            The unique set of vertices (as <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex"/>es)
            forming the constraints must also be supplied.
            Supplying it explicitly allows the ConstraintVertexes to be initialized
            appropriately (e.g. with external data), and avoids re-computing the unique set
            if it is already available.
            </summary>
            <param name="segments">list of the constraint <see cref="T:NetTopologySuite.Triangulate.Segment"/>s</param>
            <param name="segVertices">the set of unique <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex"/>es referenced by the segments</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.SplitPointFinder">
            <summary>
            Gets or sets the <see cref="T:NetTopologySuite.Triangulate.IConstraintSplitPointFinder"/> to be
            used during constraint enforcement.
            Different splitting strategies may be appropriate
            for special situations.
            </summary>
            <remarks>the ConstraintSplitPointFinder to be used</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.Tolerance">
            <summary>
            Gets the tolerance value used to construct the triangulation.
            </summary>
            <remarks>a tolerance value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.VertexFactory">
            <summary>
            Gets and sets the <see cref="T:NetTopologySuite.Triangulate.ConstraintVertexFactory"/> used to create new constraint vertices at split points.
            </summary>
            <remarks>Allows the setting of a custom <see cref="T:NetTopologySuite.Triangulate.ConstraintVertexFactory"/> to be used
            to allow vertices carrying extra information to be created.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.Subdivision">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/> which represents the triangulation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.KDT">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/> which contains the vertices of the triangulation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.InitialVertices">
            <summary>
            Gets the sites (vertices) used to initialize the triangulation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.ConstraintSegments">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Triangulate.Segment"/>s which represent the constraints.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.ConvexHull">
            <summary>
            Gets the convex hull of all the sites in the triangulation,
            including constraint vertices.
            Only valid after the constraints have been enforced.
            </summary>
            <remarks>the convex hull of the sites</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.CreateVertex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Triangulate.Segment)">
            <summary>
            Creates a vertex on a constraint segment
            </summary>
            <param name="p">the location of the vertex to create</param>
            <param name="seg">the constraint segment it lies on</param>
            <returns>the new constraint vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.InsertSites(System.Collections.Generic.ICollection{NetTopologySuite.Triangulate.QuadEdge.Vertex})">
            <summary>
            Inserts all sites in a collection
            </summary>
            <param name="vertices">a collection of ConstraintVertex</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.InsertSite(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Inserts a site into the triangulation, maintaining the conformal Delaunay property.
            This can be used to further refine the triangulation if required
            (e.g. to approximate the medial axis of the constraints,
            or to improve the grading of the triangulation).
            </summary>
            <param name="p">the location of the site to insert</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.FormInitialDelaunay">
            <summary>
            Computes the Delaunay triangulation of the initial sites.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.EnforceConstraints">
            <summary>
            Enforces the supplied constraints into the triangulation.
            </summary>
            <exception cref="T:NetTopologySuite.Triangulate.ConstraintEnforcementException">
            if the constraints cannot be enforced</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.FindNonGabrielPoint(NetTopologySuite.Triangulate.Segment)">
            <summary>
            Given a set of points stored in the kd-tree and a line segment defined by
            two points in this set, finds a <see cref="T:NetTopologySuite.Geometries.Coordinate"/> in the circumcircle of
            the line segment, if one exists. This is called the Gabriel point - if none
            exists then the segment is said to have the Gabriel condition. Uses the
            heuristic of finding the non-Gabriel point closest to the midpoint of the
            segment.
            </summary>
            <param name="seg">the line segment</param>
            <returns>
            A point which is non-Gabriel,
            or null if no point is non-Gabriel
            </returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConstraintEnforcementException">
            <summary>
            Indicates a failure during constraint enforcement.
            </summary>
            <author>Martin Davis</author>
            <version>1.0</version>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintEnforcementException.#ctor(System.String)">
            <summary>
            Creates a new instance with a given message.
            </summary>
            <param name="msg">a string</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintEnforcementException.#ctor(System.String,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new instance with a given message and approximate location.
            </summary>
            <param name="msg">a string</param>
            <param name="pt">the location of the error</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConstraintEnforcementException.Coordinate">
            <summary>
            Gets the approximate location of this error.
            </summary>
            <remarks>a location</remarks>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConstraintVertex">
            <summary>
            A vertex in a Constrained Delaunay Triangulation.
            The vertex may or may not lie on a constraint.
            If it does it may carry extra information about the original constraint.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintVertex.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new constraint vertex
            </summary>
            <param name="p">the location of the vertex</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConstraintVertex.IsOnConstraint">
            <summary>
            Gets or sets whether this vertex lies on a constraint.
            </summary>
            <remarks>true if the vertex lies on a constraint</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConstraintVertex.Constraint">
            <summary>
            Gets or sets the external constraint object
            </summary>
            <remarks>object which carries information about the constraint this vertex lies on</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintVertex.Merge(NetTopologySuite.Triangulate.ConstraintVertex)">
            <summary>
            Merges the constraint data in the vertex <tt>other</tt> into this vertex.
            This method is called when an inserted vertex is
            very close to an existing vertex in the triangulation.
            </summary>
            <param name="other">the constraint vertex to merge</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConstraintVertexFactory">
            <summary>
            An interface for factories which create a <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex"/>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder">
            <summary>
            A utility class which creates Delaunay Triangulations
            from collections of points and extract the resulting
            triangulation edges or triangles as geometries.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.ExtractUniqueCoordinates(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Extracts the unique <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s from the given <see cref="T:NetTopologySuite.Geometries.Geometry"/>.
            </summary>
            <param name="geom">the geometry to extract from</param>
            <returns>a List of the unique Coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.ToVertices(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Converts all <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s in a collection to <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>es.
            </summary>
            <param name="coords">the coordinates to convert</param>
            <returns>a List of Vertex objects</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.Envelope(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Computes the <see cref="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.Envelope(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Coordinate})"/> of a collection of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="coords">a List of Coordinates</param>
            <returns>the envelope of the set of coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.SetSites(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets the sites (vertices) which will be triangulated.
            All vertices of the given geometry will be used as sites.
            </summary>
            <param name="geom">the geometry from which the sites will be extracted.</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.SetSites(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Sets the sites (vertices) which will be triangulated
            from a collection of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="coords">a collection of Coordinates.</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.Tolerance">
            <summary>
            Sets the snapping tolerance which will be used
            to improved the robustness of the triangulation computation.
            A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.GetSubdivision">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/> which models the computed triangulation.
            </summary>
            <returns>the subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.GetEdges(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the edges of the computed triangulation as a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>.
            </summary>
            <param name="geomFact">the geometry factory to use to create the output</param>
            <returns>the edges of the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.GetTriangles(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the faces of the computed triangulation as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>.
            </summary>
            <param name="geomFact">the geometry factory to use to create the output</param>
            <returns>the faces of the triangulation</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.IConstraintSplitPointFinder">
            <summary>
            An interface for strategies for determining the location of split points on constraint segments.
            The location of split points has a large effect on the performance and robustness of enforcing a
            constrained Delaunay triangulation. Poorly chosen split points can cause repeated splitting,
            especially at narrow constraint angles, since the split point will end up encroaching on the
            segment containing the original encroaching point. With detailed knowledge of the geometry of the
            constraints, it is sometimes possible to choose better locations for splitting.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IConstraintSplitPointFinder.FindSplitPoint(NetTopologySuite.Triangulate.Segment,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds a point at which to split an encroached segment to allow the original segment to appear
            as edges in a constrained Delaunay triangulation.
            </summary>
            <param name="seg">the encroached segment</param>
            <param name="encroachPt">the encroaching point</param>
            <returns>the point at which to split the encroached segment</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator">
            <summary>
            Computes a Delaunay Triangulation of a set of <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>es, using an
            incremental insertion algorithm.
            </summary>
            <author>Martin Davis</author>
            <version>1.0</version>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.#ctor(NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision)">
            <summary>
            Creates a new triangulator using the given <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>.
            The triangulator uses the tolerance of the supplied subdivision.
            </summary>
            <param name="subdiv">a subdivision in which to build the TIN</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.InsertSites(System.Collections.Generic.ICollection{NetTopologySuite.Triangulate.QuadEdge.Vertex})">
            <summary>
            Inserts all sites in a collection. The inserted vertices <b>MUST</b> be
            unique up to the provided tolerance value. (i.e. no two vertices should be
            closer than the provided tolerance value). They do not have to be rounded
            to the tolerance grid, however.
            </summary>
            <param name="vertices">a Collection of Vertex</param>
            <exception cref="T:NetTopologySuite.Triangulate.QuadEdge.LocateFailureException">if the location algorithm fails to converge in a reasonable number of iterations</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.InsertSite(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Inserts a new point into a subdivision representing a Delaunay
            triangulation, and fixes the affected edges so that the result is still a
            Delaunay triangulation.
            </summary>
            <returns>a quadedge containing the inserted vertex</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.MidpointSplitPointFinder">
            <summary>
            A simple split point finder which returns the midpoint of the split segment. This is a default
            strategy only. Usually a more sophisticated strategy is required to prevent repeated splitting.
            Other points which could be used are:
            <ul>
            <li>The projection of the encroaching point on the segment</li>
            <li>A point on the segment which will produce two segments which will not be further encroached</li>
            <li>The point on the segment which is the same distance from an endpoint as the encroaching</li>
            point
            </ul>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.MidpointSplitPointFinder.FindSplitPoint(NetTopologySuite.Triangulate.Segment,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets the midpoint of the split segment
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder">
            <summary>
            A strategy for finding constraint split points which attempts to maximise the length of the split
            segments while preventing further encroachment. (This is not always possible for narrow angles).
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder.FindSplitPoint(NetTopologySuite.Triangulate.Segment,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            A basic strategy for finding split points when nothing extra is known about the geometry of
            the situation.
            </summary>
            <param name="seg">the encroached segment</param>
            <param name="encroachPt">the encroaching point</param>
            <returns>the point at which to split the encroached segment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder.ProjectedSplitPoint(NetTopologySuite.Triangulate.Segment,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes a split point which is the projection of the encroaching point on the segment
            </summary>
            <param name="seg">The segment</param>
            <param name="encroachPt">The enchroaching point</param>
            <returns>A split point on the segment</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator">
            <summary>
            Computes the Constrained Delaunay Triangulation of polygons.
            The Constrained Delaunay Triangulation of a polygon is a set of triangles
            covering the polygon, with the maximum total interior angle over all
            possible triangulations.  It provides the "best quality" triangulation
            of the polygon.
            <para/>
            Holes are supported.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.Triangulate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes the Constrained Delaunay Triangulation of each polygon element in a geometry.
            </summary>
            <param name="geom">The input geometry</param>
            <returns>A GeometryCollection of the computed triangle polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs a new Constrained Delaunay triangulator.
            </summary>
            <param name="inputGeom">The input geometry</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.GetResult">
            <summary>
            Gets the triangulation as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> of triangular <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s.
            </summary>
            <returns>A collection of the result triangle polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.GetTriangles">
            <summary>
            Gets the triangulation as a list of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s.
            </summary>
            <returns>The list of <c>Tri</c>s in the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.TriangulatePolygon(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Computes the triangulation of a single polygon
            and returns it as a list of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s.
            </summary>
            <param name="poly">The input polygon</param>
            <returns>A list of <c>Tri</c>s forming the triangulation</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper">
            <summary>
            Triangulates a polygon using the Ear-Clipping technique.
            The polygon is provided as a closed list of contiguous vertices
            defining its boundary.
            The vertices must have clockwise orientation.
            <para/>
            The polygon boundary must not self-cross,
            but may self-touch at points or along an edge.
            It may contain repeated points, which are treated as a single vertex.
            By default every vertex is triangulated,
            including ones which are "flat" (the adjacent segments are collinear).
            These can be removed by setting <see cref="P:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.SkipFlatCorners"/>.
            <para/>
            The polygon representation does not allow holes.
            Polygons with holes can be triangulated by preparing them with <see cref="T:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner"/>.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.Triangulate(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Triangulates a polygon via ear-clipping.
            </summary>
            <param name="polyShell">The vertices of the polygon</param>
            <returns>A list of <c>Tri</c>s</returns>
        </member>
        <member name="F:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper._vertex">
            <summary>
            The polygon vertices are provided in CW orientation.
            Thus for convex interior angles
            the vertices forming the angle are in CW orientation.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper._vertexCoordIndex">
            <summary>
            Indexing vertices improves ear intersection testing performance.
            The polyShell vertices are contiguous, so are suitable for an SPRtree.
            Note that a KDtree cannot be used because the vertex indices must be stored
            and duplicates must be stored.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.#ctor(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a new instance of this class
            </summary>
            <param name="polyShell">The vertices of the polygon to process</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.SkipFlatCorners">
            <summary>
            Gets or sets whether flat corners formed by collinear adjacent line segments
            are included in the triangulation.
            Skipping flat corners reduces the number of triangles in the output.
            However, it produces a triangulation which does not include
            all input vertices.  This may be undesirable for downstream processes
            (such as computing a Constrained Delaunay Triangulation for
            purposes of computing the medial axis).
            <para/>
            The default is to include all vertices in the result triangulation.
            This still produces a valid triangulation, with no zero-area triangles.
            <para/>
            Note that repeated vertices are always skipped.
            </summary>
            <returns>A flag indicating if flat corners formed by collinear adjacent line segments
            are included in the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.FindIntersectingVertex(System.Int32,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Finds a vertex contained in the corner triangle, if any.
            Uses the vertex spatial index for efficiency.
            <para/>
            Also finds any vertex which is a duplicate of the corner apex vertex.
            This requires a full scan of the vertices to confirm ear is valid.
            This is usually a rare situation, so has little impact on performance.
            </summary>
            <param name="cornerIndex">The index of the corner apex vertex</param>
            <param name="corner">The corner vertices</param>
            <returns>The index of an intersecting or duplicate vertex, or <see cref="F:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.NoVertexIndex"/> if none</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.IsValidEarScan(System.Int32,NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Scan all vertices in current ring to check if any are duplicates
            of the corner apex vertex, and if so whether the corner ear
            intersects the adjacent segments and thus is invalid.
            </summary>
            <param name="cornerIndex">The index of the corner apex</param>
            <param name="corner">The corner vertices</param>
            <returns><c>true</c> if the corner ia a valid ear</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.RemoveCorner">
            <summary>
            Remove the corner apex vertex and update the candidate corner location.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.FetchCorner(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Fetch the corner vertices from the indices.
            </summary>
            <param name="cornerVertex">An array for the corner vertices</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.NextCorner(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Move to next corner.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.NextIndex(System.Int32)">
            <summary>
            Get the index of the next available shell coordinate starting from the given index.
            </summary>
            <param name="index">Coordinate position</param>
            <returns>Index of the next available shell coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonEarClipper.IsCornerInvalid(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Detects if a corner has repeated points (AAB or ABB), or is collapsed (ABA).
            </summary>
            <param name="pts">The corner points</param>
            <returns><c>true</c> if the corner is flat or collapsed</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner">
            <summary>
            Transforms a polygon with holes into a single self-touching (invalid) ring
            by joining holes to the exterior shell or to another hole.
            The holes are added from the lowest upwards.
            As the resulting shell develops, a hole might be added to what was
            originally another hole.
            <para/>
            There is no attempt to optimize the quality of the join lines.
            In particular, a hole which already touches at a vertex may be
            joined at a different vertex.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner._comparer">
            <summary>
            The comparer to use when sorting <see cref="F:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner._shellCoordsSortedArray"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.Compute">
            <summary>
            Computes the joined ring.
            </summary>
            <returns>The points in the joined ring</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.AddOrderedCoord(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Adds a coordinate to the <see cref="F:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner._shellCoordsSorted"/> set and
            clears the <see cref="F:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner._shellCoordsSortedArray"/> array.
            </summary>
            <param name="coord">A coordinate</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.JoinHole(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Joins a single hole to the current shellRing.
            </summary>
            <param name="hole">The hole to join</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.GetShellCoordIndex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Get the i'th <paramref name="shellVertex"/> in <see cref="F:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner._shellCoords"/> that the current should add after
            </summary>
            <param name="shellVertex">The coordinate of the shell vertex</param>
            <param name="holeVertex">The coordinate of the hole vertex</param>
            <returns>The i'th shellvertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.GetShellCoordIndexSkip(NetTopologySuite.Geometries.Coordinate,System.Int32)">
            <summary>
            Find the index of the coordinate in ShellCoords ArrayList,
            skipping over some number of matches
            </summary>
            <param name="coord"></param>
            <param name="numSkip"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.FindLeftShellVertices(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets a list of shell vertices that could be used to join with the hole.
            This list contains only one item if the chosen vertex does not share the same
            x value with <paramref name="holeCoord"/>
            </summary>
            <param name="holeCoord">The hole coordinate</param>
            <returns>A list of candidate join vertices</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.IsJoinable(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Determine if a line segment between a hole vertex
            and a shell vertex lies inside the input polygon.
            </summary>
            <param name="holeCoord">A hole coordinate</param>
            <param name="shellCoord">A shell coordinate</param>
            <returns><c>true</c> if the line lies inside the polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.CrossesPolygon(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a line segment crosses the polygon boundary.
            </summary>
            <param name="p0">A vertex</param>
            <param name="p1">A vertex</param>
            <returns><c>true</c> if the line segment crosses the polygon boundary</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.AddHoleToShell(System.Int32,NetTopologySuite.Geometries.Coordinate[],System.Int32)">
            <summary>
            Add hole vertices at proper position in shell vertex list.
            For a touching/zero-length join line, avoids adding the join vertices twice.
            Also adds hole points to ordered coordinates.
            </summary>
            <param name="shellJoinIndex">The index of join vertex in shell</param>
            <param name="holeCoords">The vertices of the hole to be inserted</param>
            <param name="holeJoinIndex">The index of join vertex in hole</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.SortHoles(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Sort the hole rings by minimum X, minimum Y.
            </summary>
            <param name="poly">Polygon that contains the holes</param>
            <returns>A list of sorted hole rings</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.FindLeftVertices(NetTopologySuite.Geometries.LinearRing)">
            <summary>
            Gets a list of indices of the leftmost vertices in a ring.
            </summary>
            <param name="ring">The hole ring</param>
            <returns>Index of the left most vertex</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator">
            <summary>
            Computes a triangulation of each polygon in a {@link Geometry}.
            A polygon triangulation is a non-overlapping set of triangles which
            cover the polygon and have the same vertices as the polygon.
            The priority is on performance rather than triangulation quality,
            so that the output may contain many narrow triangles.
            <para/>
            Holes are handled by joining them to the shell to form a
            (self-touching) polygon shell with no holes.
            Although invalid, this can be triangulated effectively.
            <para/>
            For better-quality triangulation use <see cref="T:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator"/>.
            </summary>
            <seealso cref="T:NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator"/>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.Triangulate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Computes a triangulation of each polygon in a geometry.
            </summary>
            <param name="geom">A geometry containing polygons</param>
            <returns>A <c>GeometryCollection</c> containing the polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.#ctor(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Constructs a new triangulator.
            </summary>
            <param name="inputGeom">The input geometry</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.GetResult">
            <summary>
            Gets the triangulation as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> of triangular <see cref="T:NetTopologySuite.Geometries.Polygon"/>s.
            </summary>
            <returns>A collection of the result triangle polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.GetTriangles">
            <summary>
            Gets the triangulation as a list of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s.
            </summary>
            <returns>The list of Tris in the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.TriangulatePolygon(NetTopologySuite.Geometries.Polygon)">
            <summary>
            Computes the triangulation of a single polygon
            </summary>
            <returns>A list of triangular polygons</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover">
            <summary>
            Improves the quality of a triangulation of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s via
            iterated Delaunay flipping.
            This produces a Constrained Delaunay Triangulation
            with the constraints being the boundary of the input triangulation.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.Improve(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Improves the quality of a triangulation of {@link Tri}s via
            iterated Delaunay flipping.
            The Tris are assumed to be linked into a Triangulation
            (e.g. via <see cref="!:TriangulationBuilder"/>).
            </summary>
            <param name="triList">The list of <c>Tri</c>s to improve</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.ImproveScan(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>Improves a triangulation by examining pairs of adjacent triangles
            (forming a quadrilateral) and testing if flipping the diagonal of
            the quadrilateral would produce two new triangles with larger minimum
            interior angles.
            </summary>
            <returns>The number of flips that were made</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.ImproveNonDelaunay(NetTopologySuite.Triangulate.Tri.Tri,System.Int32)">
            <summary>
            Does a flip of the common edge of two Tris if the Delaunay condition is not met.
            </summary>
            <param name="tri">A <c>Tri</c></param>
            <param name="index">The index of the <paramref name="tri"/></param>
            <returns><c>true</c> if the triangles were flipped</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.IsConvex(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if the quadrilateral formed by two adjacent triangles is convex.
            opp0-adj0-adj1 and opp1-adj1-adj0 are the triangle corners
            and hence are known to be convex.
            The quadrilateral is convex if the other corners opp0-adj0-opp1
            and opp1-adj1-opp0 have the same orientation (since at least one must be convex).
            </summary>
            <param name="adj0">The adjacent edge vertex 0</param>
            <param name="adj1">The adjacent edge vertex 1</param>
            <param name="opp0">The corner vertex of triangle 0</param>
            <param name="opp1">The corner vertex of triangle 1</param>
            <returns><c>true</c> if the quadrilateral is convex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.IsDelaunay(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if either of a pair of adjacent triangles satisfy the Delaunay condition.
            The triangles are opp0-adj0-adj1 and opp1-adj1-adj0.
            The Delaunay condition is not met if one opposite vertex
            lies is in the circumcircle of the other triangle.
            </summary>
            <param name="adj0">The adjacent edge vertex 0</param>
            <param name="adj1">The adjacent edge vertex 1</param>
            <param name="opp0">The corner vertex of triangle 0</param>
            <param name="opp1">The corner vertex of triangle 1</param>
            <returns><c>true</c> if the triangles are Delaunay</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover.IsInCircle(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a point p is in the circumcircle of a triangle abc
            (oriented clockwise).
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point</param>
            <returns><c>true</c> if the point is in the circumcircle</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal">
            <summary>
            A framework to visit sets of edge-connected <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle"/>s in breadth-first order
            </summary>
            <author>Martin Davis</author>
            <version>1.0</version>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal.Init(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle})">
            <summary>
            Called to initialize the traversal queue with a given set of <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle"/>s
            </summary>
            <param name="tris">a collection of QuadEdgeTriangle</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal.VisitAll(NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor)">
            <summary>
            Subclasses call this method to perform the visiting process.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator">
            <summary>
            An interface for classes which locate an edge in a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>
            which either contains a given <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/> V
            or is an edge of a triangle which contains V.
            Implementors may utilized different strategies for
            optimizing locating containing edges/triangles.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor">
            <summary>
            Interface for classes which process triangles visited during traversals of a
            <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor.Visit(NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle,System.Int32,NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle)">
            <summary>
            Visits a triangle during a traversal of a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>. An implementation of
            this method may perform processing on the current triangle. It must also decide whether a
            neighbouring triangle should be added to the queue so its neighbours are visited. Often it
            will perform processing on the neighbour triangle as well, in order to mark it as processed
            (visited) and/or to determine if it should be visited. Note that choosing <b>not</b> to
            visit the neighbouring triangle is the terminating condition for many traversal algorithms.
            In particular, if the neighbour triangle has already been visited, it should not be visited
            again.
            </summary>
            <param name="currTri">the current triangle being processed</param>
            <param name="edgeIndex">the index of the edge in the current triangle being traversed</param>
            <param name="neighbTri">a neighbouring triangle next in line to visit</param>
            <returns>true if the neighbour triangle should be visited</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor">
            <summary>
            An interface for algorithms which process the triangles in a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>.
            </summary>
            <author>Martin Davis</author>
            <version>1.0</version>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor.Visit(NetTopologySuite.Triangulate.QuadEdge.QuadEdge[])">
            <summary>
            Visits the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s of a triangle.
            </summary>
            <param name="triEdges">an array of the 3 quad edges in a triangle (in CCW order)</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator">
            <summary>
            Locates <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s in a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>,
            optimizing the search by starting in the
            locality of the last edge found.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator.Locate(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Locates an edge e, such that either v is on e, or e is an edge of a triangle containing v.
            The search starts from the last located edge and proceeds on the general direction of v.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge">
            <summary>
            A class that represents the edge data structure which implements the quadedge algebra.
            The quadedge algebra was described in a well-known paper by Guibas and Stolfi,
            "Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams",
            <i>ACM Transactions on Graphics</i>, 4(2), 1985, 75-123.
            <para>
            Each edge object is part of a quartet of 4 edges,
            linked via their <tt>Rot</tt> references.
            Any edge in the group may be accessed using a series of <see cref="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Rot"/> operations.
            Quadedges in a subdivision are linked together via their <tt>Next</tt> references.
            The linkage between the quadedge quartets determines the topology
            of the subdivision.
            </para>
            <para>
            The edge class does not contain separate information for vertices or faces; a vertex is implicitly
            defined as a ring of edges (created using the <tt>Next</tt> field).
            </para>
            </summary>
            <author>David Skea</author>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.MakeEdge(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Creates a new QuadEdge quartet from <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>o to <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/> d.
            </summary>
            <param name="o">the origin Vertex</param>
            <param name="d">the destination Vertex</param>
            <returns>the new QuadEdge quartet</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Connect(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Creates a new QuadEdge connecting the destination of a to the origin of
            b, in such a way that all three have the same left face after the
            connection is complete. Additionally, the data pointers of the new edge
            are set.
            </summary>
            <returns>the connected edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Splice(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Splices two edges together or apart.
            Splice affects the two edge rings around the origins of a and b, and, independently, the two
            edge rings around the left faces of <tt>a</tt> and <tt>b</tt>.
            In each case, (i) if the two rings are distinct,
            Splice will combine them into one, or (ii) if the two are the same ring, Splice will break it
            into two separate pieces. Thus, Splice can be used both to attach the two edges together, and
            to break them apart.
            </summary>
            <param name="a">an edge to splice</param>
            <param name="b">an edge to splice</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Swap(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Turns an edge counterclockwise inside its enclosing quadrilateral.
            </summary>
            <param name="e">the quadedge to turn</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.#ctor">
            <summary>
            Quadedges must be made using {@link makeEdge},
            to ensure proper construction.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.GetPrimary">
            <summary>
            Gets the primary edge of this quadedge and its <tt>sym</tt>.
            The primary edge is the one for which the origin
            and destination coordinates are ordered
            according to the standard <see cref="T:NetTopologySuite.Geometries.Coordinate"/> ordering
            </summary>
            <returns>the primary quadedge</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Data">
            <summary>
            Gets or sets the external data value for this edge.
            </summary>
            <remarks>
            an object containing external data
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Delete">
            <summary>
            Marks this quadedge as being deleted.
            This does not free the memory used by
            this quadedge quartet, but indicates
            that this edge no longer participates
            in a subdivision.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.IsLive">
            <summary>
            Tests whether this edge has been deleted.
            </summary>
            <returns>true if this edge has not been deleted.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.SetNext(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Sets the connected edge
            </summary>
            <param name="next">edge</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Rot">
            <summary>
            Gets the dual of this edge, directed from its right to its left.
            </summary>
            <remarks>Gets or Sets the rotated edge</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.InvRot">
            <summary>
            Gets the dual of this edge, directed from its left to its right.
            </summary>
            <remarks>Gets the inverse rotated edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Sym">
            <summary>
            Gets the edge from the destination to the origin of this edge.
            </summary>
            <remarks>Gets the sym of the edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.ONext">
            <summary>
            Gets the next CCW edge around the origin of this edge.
            </summary>
            <remarks>Gets the next linked edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.OPrev">
            <summary>
            Gets the next CW edge around (from) the origin of this edge.
            </summary>
            <remarks>Gets the previous edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.DNext">
            <summary>
            Gets the next CCW edge around (into) the destination of this edge.
            </summary>
            <remarks>Get the next destination edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.DPrev">
            <summary>
            Gets the next CW edge around (into) the destination of this edge.
            </summary>
            <remarks>Get the previous destination edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.LNext">
            <summary>
            Gets the CCW edge around the left face following this edge.
            </summary>
            <remarks>Gets the next left face edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.LPrev">
            <summary>
            Gets the CCW edge around the left face before this edge.
            </summary>
            <remarks>Get the previous left face edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.RNext">
            <summary>
            Gets the edge around the right face ccw following this edge.
            </summary>
            <remarks>Gets the next right face edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.RPrev">
            <summary>
            Gets the edge around the right face ccw before this edge.
            </summary>
            <remarks>Gets the previous right face edge.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Orig">
            <summary>
            Gets or sets the vertex for the edge's origin
            </summary>
            <remarks>Gets the origin vertex</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Dest">
            <summary>
            Gets or sets the vertex for the edge's destination
            </summary>
            <remarks>Gets the destination vertex</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Length">
            <summary>
            Gets the length of the geometry of this quadedge.
            </summary>
            <remarks>Gets the length of the quadedge</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.EqualsNonOriented(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Tests if this quadedge and another have the same line segment geometry,
            regardless of orientation.
            </summary>
            <param name="qe">a quadedge</param>
            <returns>true if the quadedges are based on the same line segment regardless of orientation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.EqualsOriented(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Tests if this quadedge and another have the same line segment geometry
            with the same orientation.
            </summary>
            <param name="qe">a quadedge</param>
            <returns>true if the quadedges are based on the same line segment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.ToLineSegment">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.LineSegment"/> representing the
            geometry of this edge.
            </summary>
            <returns>a LineSegment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdge.ToString">
            <summary>
            Converts this edge to a WKT two-point <tt>LINESTRING</tt> indicating
            the geometry of this edge.
            </summary>
            <returns>a String representing this edge's geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision">
            <summary>
            A class that contains the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s representing a planar
            subdivision that models a triangulation.
            The subdivision is constructed using the
            quadedge algebra defined in the class <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>.
            All metric calculations
            are done in the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/> class.
            In addition to a triangulation, subdivisions
            support extraction of Voronoi diagrams.
            This is easily accomplished, since the Voronoi diagram is the dual
            of the Delaunay triangulation.
            <para>
            Subdivisions can be provided with a tolerance value. Inserted vertices which
            are closer than this value to vertices already in the subdivision will be
            ignored. Using a suitable tolerance value can prevent robustness failures
            from happening during Delaunay triangulation.
            </para>
            <para>
            Subdivisions maintain a <b>frame</b> triangle around the client-created
            edges. The frame is used to provide a bounded "container" for all edges
            within a TIN. Normally the frame edges, frame connecting edges, and frame
            triangles are not included in client processing.
            </para>
            </summary>
            <author>David Skea</author>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetTriangleEdges(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Triangulate.QuadEdge.QuadEdge[])">
            <summary>
            Gets the edges for the triangle to the left of the given <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>.
            </summary>
            <param name="startQE" />
            <param name="triEdge" />
            <exception cref="T:System.ArgumentException">if the edges do not form a triangle</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.#ctor(NetTopologySuite.Geometries.Envelope,System.Double)">
            <summary>
            Creates a new instance of a quad-edge subdivision based on a frame triangle
            that encloses a supplied bounding box. A new super-bounding box that
            contains the triangle is computed and stored.
            </summary>
            <param name="env">the bounding box to surround</param>
            <param name="tolerance">the tolerance value for determining if two sites are equal</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Tolerance">
            <summary>
            Gets the vertex-equality tolerance value
            used in this subdivision
            </summary>
            <remarks>Gets the tolerance value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Envelope">
            <summary>
            Gets the envelope of the Subdivision (including the frame).
            </summary>
            <remarks>Gets the envelope</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetEdges">
            <summary>
            Gets the collection of base <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s (one for every pair of
            vertices which is connected).
            </summary>
            <returns>a collection of QuadEdges</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.SetLocator(NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator)">
            <summary>
            Sets the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator"/> to use for locating containing triangles
            in this subdivision.
            </summary>
            <param name="locator">a QuadEdgeLocator</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.MakeEdge(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Creates a new quadedge, recording it in the edges list.
            </summary>
            <param name="o">The origin vertex</param>
            <param name="d">The destination vertex</param>
            <returns>A new quadedge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Connect(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Creates a new QuadEdge connecting the destination of a to the origin of b,
            in such a way that all three have the same left face after the connection
            is complete. The quadedge is recorded in the edges list.
            </summary>
            <param name="a">A quadedge</param>
            <param name="b">A quadedge</param>
            <returns>A quadedge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Delete(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Deletes a quadedge from the subdivision. Linked quadedges are updated to
            reflect the deletion.
            </summary>
            <param name="e">the quadedge to delete</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.LocateFromEdge(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Locates an edge of a triangle which contains a location
            specified by a Vertex v.
            The edge returned has the
            property that either v is on e, or e is an edge of a triangle containing v.
            The search starts from startEdge amd proceeds on the general direction of v.
            </summary>
            <remarks>
            This locate algorithm relies on the subdivision being Delaunay. For
            non-Delaunay subdivisions, this may loop for ever.
            </remarks>
            <param name="v">the location to search for</param>
            <param name="startEdge">an edge of the subdivision to start searching at</param>
            <returns>a QuadEdge which contains v, or is on the edge of a triangle containing v</returns>
            <exception cref="T:NetTopologySuite.Triangulate.QuadEdge.LocateFailureException">
            if the location algorithm fails to converge in a reasonable
            number of iterations
            </exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Locate(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Finds a quadedge of a triangle containing a location
            specified by a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>, if one exists.
            </summary>
            <param name="v">the vertex to locate</param>
            <returns>a quadedge on the edge of a triangle which touches or contains the location<br/>
            or null if no such triangle exists
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Locate(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Finds a quadedge of a triangle containing a location
            specified by a <see cref="T:NetTopologySuite.Geometries.Coordinate"/>, if one exists.
            </summary>
            <param name="p">the Coordinate to locate</param>
            <returns>a quadedge on the edge of a triangle which touches or contains the location,
            or null if no such triangle exists
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.Locate(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Locates the edge between the given vertices, if it exists in the
            subdivision.
            </summary>
            <param name="p0">a coordinate</param>
            <param name="p1">another coordinate</param>
            <returns>the edge joining the coordinates, if present,
            or null if no such edge exists
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.InsertSite(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Inserts a new site into the Subdivision, connecting it to the vertices of
            the containing triangle (or quadrilateral, if the split point falls on an
            existing edge).
            </summary>
            <remarks>
            <para>
            This method does NOT maintain the Delaunay condition. If desired, this must
            be checked and enforced by the caller.
            </para>
            <para>
            This method does NOT check if the inserted vertex falls on an edge. This
            must be checked by the caller, since this situation may cause erroneous
            triangulation
            </para>
            </remarks>
            <param name="v">the vertex to insert</param>
            <returns>a new quad edge terminating in v</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.IsFrameEdge(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Tests whether a QuadEdge is an edge incident on a frame triangle vertex.
            </summary>
            <param name="e">the edge to test</param>
            <returns>true if the edge is connected to the frame triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.IsFrameBorderEdge(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Tests whether a QuadEdge is an edge on the border of the frame facets and
            the internal facets. E.g. an edge which does not itself touch a frame
            vertex, but which touches an edge which does.
            </summary>
            <param name="e">the edge to test</param>
            <returns>true if the edge is on the border of the frame</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.IsFrameVertex(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Tests whether a vertex is a vertex of the outer triangle.
            </summary>
            <param name="v">the vertex to test</param>
            <returns>true if the vertex is an outer triangle vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.IsOnEdge(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether a {@link Coordinate} lies on a {@link QuadEdge}, up to a
            tolerance determined by the subdivision tolerance.
            </summary>
            <param name="e">a QuadEdge</param>
            <param name="p">a point</param>
            <returns>true if the vertex lies on the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.IsVertexOfEdge(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/> is the start or end vertex of a
            <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>, up to the subdivision tolerance distance.
            </summary>
            <param name="e" />
            <param name="v" />
            <returns>true if the vertex is a endpoint of the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVertices(System.Boolean)">
            <summary>
            Gets the unique <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>es in the subdivision,
            including the frame vertices if desired.
            </summary>
            <param name="includeFrame">true if the frame vertices should be included</param>
            <returns>a collection of the subdivision vertices</returns>
            <see cref="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVertexUniqueEdges(System.Boolean)"/>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVertexUniqueEdges(System.Boolean)">
            <summary>
            Gets a collection of <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s whose origin
            vertices are a unique set which includes
            all vertices in the subdivision.
            The frame vertices can be included if required.
            </summary>
            <remarks>
            This is useful for algorithms which require traversing the
            subdivision starting at all vertices.
            Returning a quadedge for each vertex
            is more efficient than
            the alternative of finding the actual vertices
            using <see cref="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVertices(System.Boolean)"/> and then locating
            quadedges attached to them.
            </remarks>
            <param name="includeFrame">true if the frame vertices should be included</param>
            <returns>a collection of QuadEdge with the vertices of the subdivision as their origins</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetPrimaryEdges(System.Boolean)">
            <summary>
            Gets all primary quadedges in the subdivision.
            A primary edge is a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>
            which occupies the 0'th position in its array of associated quadedges.
            These provide the unique geometric edges of the triangulation.
            </summary>
            <param name="includeFrame">true if the frame edges are to be included</param>
            <returns>a List of QuadEdges</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.TriangleCircumcentreVisitor">
            <summary>
            A TriangleVisitor which computes and sets the
            circumcentre as the origin of the dual
            edges originating in each triangle.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="F:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision._triEdges">
            <summary>
            The quadedges forming a single triangle.
            Only one visitor is allowed to be active at a
            time, so this is safe.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.FetchTriangleToVisit(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,System.Collections.Generic.Stack{NetTopologySuite.Triangulate.QuadEdge.QuadEdge},System.Boolean,System.Collections.Generic.HashSet{NetTopologySuite.Triangulate.QuadEdge.QuadEdge})">
            <summary>
            Stores the edges for a visited triangle. Also pushes sym (neighbour) edges
            on stack to visit later.
            </summary>
            <param name="edge" />
            <param name="edgeStack" />
            <param name="includeFrame" />
            <param name="visitedEdges"></param>
            <returns>the visited triangle edges,<br/>
            or <c>null</c> if the triangle should not be visited (for instance, if it is outer)
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetTriangleEdges(System.Boolean)">
            <summary>
            Gets a list of the triangles
            in the subdivision, specified as
            an array of the primary quadedges around the triangle.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included</param>
            <returns>a List of QuadEdge[3] arrays</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetTriangleVertices(System.Boolean)">
            <summary>
            Gets a list of the triangles in the subdivision,
            specified as an array of the triangle <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>es.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included</param>
            <returns>a List of Vertex[3] arrays</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetTriangleCoordinates(System.Boolean)">
            <summary>
            Gets the coordinates for each triangle in the subdivision as an array.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included</param>
            <returns>a list of Coordinate[4] representing each triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetEdges(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the geometry for the edges in the subdivision as a <see cref="T:NetTopologySuite.Geometries.MultiLineString"/>
            containing 2-point lines.
            </summary>
            <param name="geomFact">the GeometryFactory to use</param>
            <returns>a MultiLineString</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetTriangles(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the geometry for the triangles in a triangulated subdivision as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            of triangular <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s.
            </summary>
            <param name="geomFact">the GeometryFactory to use</param>
            <returns>a GeometryCollection of triangular Polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVoronoiDiagram(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the cells in the Voronoi diagram for this triangulation.
            The cells are returned as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection" /> of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s
            </summary>
            <remarks>
            The userData of each polygon is set to be the <see cref="T:NetTopologySuite.Geometries.Coordinate" />
            of the cell site.  This allows easily associating external
            data associated with the sites to the cells.
            </remarks>
            <param name="geomFact">a geometry factory</param>
            <returns>a GeometryCollection of Polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVoronoiCellPolygons(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets a List of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s for the Voronoi cells
            of this triangulation.
            </summary>
            <remarks>
            The UserData of each polygon is set to be the <see cref="T:NetTopologySuite.Geometries.Coordinate"/>
            of the cell site.  This allows easily associating external
            data associated with the sites to the cells.
            </remarks>
            <param name="geomFact">a geometry factory</param>
            <returns>a List of Polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.GetVoronoiCellPolygon(NetTopologySuite.Triangulate.QuadEdge.QuadEdge,NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the Voronoi cell around a site specified
            by the origin of a QuadEdge.
            </summary>
            <remarks>
            The userData of the polygon is set to be the <see cref="T:NetTopologySuite.Geometries.Coordinate" />
            of the site.  This allows attaching external
            data associated with the site to this cell polygon.
            </remarks>
            <param name="qe">a quadedge originating at the cell site</param>
            <param name="geomFact">a factory for building the polygon</param>
            <returns>a polygon indicating the cell extent</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle">
            <summary>
            Models a triangle formed from <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s in a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>
            which forms a triangulation. The class provides methods to access the
            topological and geometric properties of the triangle and its neighbours in
            the triangulation. Triangle vertices are ordered in CCW orientation in the
            structure.
            </summary>
            <remarks>
            QuadEdgeTriangles support having an external data attribute attached to them.
            Alternatively, this class can be subclassed and attributes can
            be defined in the subclass.  Subclasses will need to define
            their own <c>BuilderVisitor</c> class
            and <c>CreateOn</c> method.
            </remarks>
            <author>Martin Davis</author>
            <version>1.0</version>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.CreateOn(NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision)">
            <summary>
            Creates <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle"/>s for all facets of a
            <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/> representing a triangulation.
            The <tt>data</tt> attributes of the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>s in the subdivision
            will be set to point to the triangle which contains that edge.
            This allows tracing the neighbour triangles of any given triangle.
            </summary>
            <param name="subdiv">The QuadEdgeSubdivision to create the triangles on.</param>
            <returns>A List of the created QuadEdgeTriangles</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.Contains(NetTopologySuite.Triangulate.QuadEdge.Vertex[],NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the point pt is contained in the triangle defined by 3 <see cref="T:NetTopologySuite.Triangulate.QuadEdge.Vertex"/>es.
            </summary>
            <param name="tri">an array containing at least 3 Vertexes</param>
            <param name="pt">the point to test</param>
            <returns>true if the point is contained in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.Contains(NetTopologySuite.Triangulate.QuadEdge.QuadEdge[],NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests whether the point pt is contained in the triangle defined by 3 <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdge"/>es.
            </summary>
            <param name="tri">an array containing at least 3 QuadEdges</param>
            <param name="pt">the point to test</param>
            <returns>true if the point is contained in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.#ctor(NetTopologySuite.Triangulate.QuadEdge.QuadEdge[])">
            <summary>
            Creates a new triangle from the given edges.
            </summary>
            <param name="edge">An array of the edges of the triangle in CCW order</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.Data">
            <summary>
            Gets or sets the external data value for this triangle.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.GetVertices">
            <summary>
            Gets the vertices for this triangle.
            </summary>
            <returns>a new array containing the triangle vertices</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.GetEdgeIndex(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Gets the index for the given edge of this triangle
            </summary>
            <param name="e">a QuadEdge</param>
            <returns>the index of the edge in this triangle,<br/>
            or -1 if the edge is not an edge of this triangle
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.GetEdgeIndex(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Gets the index for the edge that starts at vertex v.
            </summary>
            <param name="v">the vertex to find the edge for</param>
            <returns>the index of the edge starting at the vertex, <br/>
            or -1 if the vertex is not in the triangle
            </returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.IsBorder">
            <summary>
            Tests whether this triangle is adjacent to the outside of the subdivision.
            </summary>
            <returns>true if the triangle is adjacent to the subdivision exterior</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.GetTrianglesAdjacentToVertex(System.Int32)">
            <summary>
            Gets the triangles which are adjacent (include) to a
            given vertex of this triangle.
            </summary>
            <param name="vertexIndex">The vertex to query</param>
            <returns>A list of the vertex-adjacent triangles</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.GetNeighbours">
            <summary>
            Gets the neighbours of this triangle. If there is no neighbour triangle, the array element is
            <c>null</c>
            </summary>
            <returns>an array containing the 3 neighbours of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil.FindEdgesIncidentOnOrigin(NetTopologySuite.Triangulate.QuadEdge.QuadEdge)">
            <summary>
            Gets all edges which are incident on the origin of the given edge.
            </summary>
            <param name="start">the edge to start at</param>
            <returns>a List of edges which have their origin at the origin of the given
            edge</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate">
            <summary>
            Algorithms for computing values and predicates
            associated with triangles.
            </summary>
            <remarks>
            For some algorithms extended-precision
            implementations are provided, which are more robust
            (i.e. they produce correct answers in more cases).
            Also, some more robust formulations of
            some algorithms are provided, which utilize
            normalization to the origin.
            </remarks>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleNonRobust(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point is inside the circle defined by
            the triangle with vertices a, b, c (oriented counter-clockwise).
            This test uses simple
            double-precision arithmetic, and thus is not 100% robust.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns>true if this point is inside the circle defined by the points a, b, c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleNormalized(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point is inside the circle defined by
            the triangle with vertices a, b, c (oriented counter-clockwise).
            </summary>
            <remarks>
            <para> This test uses simple
            double-precision arithmetic, and thus is not 100% robust.
            However, by using normalization to the origin
            it provides improved robustness and increased performance.</para>
            <para>Based on code by J.R.Shewchuk.</para>
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns>true if this point is inside the circle defined by the points a, b, c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.TriArea(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes twice the area of the oriented triangle (a, b, c), i.e., the area is positive if the
            triangle is oriented counterclockwise.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>The area of the triangle defined by the points a, b, c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleRobust(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point is inside the circle defined by
            the triangle with vertices a, b, c (oriented counter-clockwise).
            </summary>
            <remarks>
            This method uses more robust computation.
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns>true if this point is inside the circle defined by the points a, b, c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleDDFast(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Tests if a point is inside the circle defined by
            the triangle with vertices a, b, c (oriented counter-clockwise).
            </summary>
            <remarks>
            The computation uses <see cref="T:NetTopologySuite.Mathematics.DD"/> arithmetic for robustness, but a faster approach.
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns>true if this point is inside the circle defined by the points a, b, c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.TriAreaDDFast(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes twice the area of the oriented triangle (a, b, c), i.e., the area
            is positive if the triangle is oriented counterclockwise.
            </summary>
            <remarks>
            The computation uses {@link DD} arithmetic for robustness.
            </remarks>
            <param name="a">a vertex of the triangle</param>
            <param name="b">a vertex of the triangle</param>
            <param name="c">a vertex of the triangle</param>
            <returns>The area of a triangle defined by the points a, b and c</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleDDNormalized(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <param name="c"></param>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.IsInCircleCC(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the inCircle test using distance from the circumcentre.
            Uses standard double-precision arithmetic.
            </summary>
            <remarks>
            In general this doesn't
            appear to be any more robust than the standard calculation. However, there
            is at least one case where the test point is far enough from the
            circumcircle that this test gives the correct answer.
            <pre>
            LINESTRING (1507029.9878 518325.7547, 1507022.1120341457 518332.8225183258,
            1507029.9833 518325.7458, 1507029.9896965567 518325.744909031)
            </pre>
            </remarks>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <param name="p">The point to test</param>
            <returns>The area of a triangle defined by the points a, b and c</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.QuadEdge.Vertex">
            <summary>
            Models a site (node) in a <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/>.
            The sites can be points on a line string representing a
            linear site.<para/>
            The vertex can be considered as a vector with a norm, length, inner product, cross
            product, etc. Additionally, point relations (e.g., is a point to the left of a line, the circle
            defined by this point and two others, etc.) are also defined in this class.
            <para/>
            It is common to want to attach user-defined data to
            the vertices of a subdivision.
            One way to do this is to subclass <tt>Vertex</tt>
            to carry any desired information.
            </summary>
            <author>David Skea</author>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.#ctor(System.Double,System.Double)">
            <summary>
            Creates an instance of this class using the given x- and y-ordinate valuse
            </summary>
            <param name="x">x-ordinate value</param>
            <param name="y">y-ordinate value</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of this class using the given x-, y- and z-ordinate values
            </summary>
            <param name="x">x-ordinate value</param>
            <param name="y">y-ordinate value</param>
            <param name="z">z-ordinate value</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.#ctor(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this class using a clone of the given <see cref="P:NetTopologySuite.Triangulate.QuadEdge.Vertex.Coordinate"/>.
            </summary>
            <param name="p">The coordinate</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.Vertex.X">
            <summary>
            Gets the x-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.Vertex.Y">
            <summary>
            Gets the y-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.Vertex.Z">
            <summary>
            Gets the z-ordinate value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.QuadEdge.Vertex.Coordinate">
            <summary>
            Gets the coordinate
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.Equals(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.CrossProduct(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Computes the cross product k = u X v.
            </summary>
            <param name="v">a vertex</param>
            <returns>returns the magnitude of u X v</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.Dot(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Computes the inner or dot product
            </summary>
            <param name="v">A vertex</param>
            <returns>The dot product u.v</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.Times(System.Double)">
            <summary>
            Computes the scalar product c(v)
            </summary>
            <param name="c">A vertex</param>
            <returns>The scaled vector</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.IsInCircle(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Tests if this is inside the circle defined by the points a, b, c. This test uses simple
            double-precision arithmetic, and thus may not be robust.
            </summary>
            <param name="a">A vertex of the triangle</param>
            <param name="b">A vertex of the triangle</param>
            <param name="c">A vertex of the triangle</param>
            <returns>true if this vertex is inside the circumcircle (a, b, c)</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.IsCcw(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Tests whether the triangle formed by this vertex and two
            other vertices is in CCW orientation.
            </summary>
            <param name="b">a vertex</param>
            <param name="c">a vertex</param>
            <returns>true if the triangle is oriented CCW</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.CircumRadiusRatio(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Computes the value of the ratio of the circumradius to shortest edge. If smaller than some
            given tolerance B, the associated triangle is considered skinny. For an equal lateral
            triangle this value is 0.57735. The ratio is related to the minimum triangle angle theta by:
            circumRadius/shortestEdge = 1/(2sin(theta)).
            </summary>
            <param name="b">second vertex of the triangle</param>
            <param name="c">third vertex of the triangle</param>
            <returns>ratio of circumradius to shortest edge.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.MidPoint(NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            returns a new vertex that is mid-way between this vertex and another end point.
            </summary>
            <param name="a">the other end point.</param>
            <returns>the point mid-way between this and that.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.CircleCenter(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            Computes the centre of the circumcircle of this vertex and two others.
            </summary>
            <param name="b" />
            <param name="c" />
            <returns>the Coordinate which is the circumcircle of the 3 points.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.InterpolateZValue(NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex,NetTopologySuite.Triangulate.QuadEdge.Vertex)">
            <summary>
            For this vertex enclosed in a triangle defined by three vertices v0, v1 and v2, interpolate
            a z value from the surrounding vertices.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.InterpolateZ(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Interpolates the Z-value (height) of a point enclosed in a triangle
            whose vertices all have Z values.
            The containing triangle must not be degenerate
            (in other words, the three vertices must enclose a
            non-zero area).
            </summary>
            <param name="p">The point to interpolate the Z value of</param>
            <param name="v0">A vertex of a triangle containing the <paramref name="p"/></param>
            <param name="v1">A vertex of a triangle containing the <paramref name="p"/></param>
            <param name="v2">A vertex of a triangle containing the <paramref name="p"/></param>
            <returns>The interpolated Z-value (height) of the point</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.QuadEdge.Vertex.InterpolateZ(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the interpolated Z-value for a point p lying on the segment p0-p1
            </summary>
            <param name="p">The point to interpolate the Z value of</param>
            <param name="p0">A vertex of the segment <paramref name="p"/> is lying on</param>
            <param name="p1">A vertex of the segment <paramref name="p"/> is lying on</param>
            <returns>The interpolated Z-value (height) of the point</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Segment">
             <summary>
             Models a constraint segment in a triangulation.
             A constraint segment is an oriented straight line segment between a start point
             and an end point.
             </summary>
             <author>David Skea</author>
             <author>Martin Davis</author>
            
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance for the given ordinates.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Object)">
            <summary>
            Creates a new instance for the given ordinates,  with associated external data.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,System.Object)">
            <summary>
            Creates a new instance for the given points, with associated external data.
            </summary>
            <param name="p0">the start point</param>
            <param name="p1">the end point</param>
            <param name="data">an external data object</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a new instance for the given points.
            </summary>
            <param name="p0">the start point</param>
            <param name="p1">the end point</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.Start">
            <summary>
            Gets the start coordinate of the segment
            </summary>
            <remarks>a Coordinate</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.End">
            <summary>
            Gets the end coordinate of the segment
            </summary>
            <remarks>a Coordinate</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.StartX">
            <summary>
            Gets the start X ordinate of the segment
            </summary>
            <remarks>the X ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.StartY">
            <summary>
            Gets the start Y ordinate of the segment
            </summary>
            <remarks>the Y ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.StartZ">
            <summary>
            Gets the start Z ordinate of the segment
            </summary>
            <remarks>the Z ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.EndX">
            <summary>
            Gets the end X ordinate of the segment
            </summary>
            <remarks>the X ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.EndY">
            <summary>
            Gets the end Y ordinate of the segment
            </summary>
            <remarks>he Y ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.EndZ">
            <summary>
            Gets the end Z ordinate of the segment
            </summary>
            <remarks>the Z ordinate value</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.LineSegment">
            <summary>
            Gets a <tt>LineSegment</tt> modelling this segment.
            </summary>
            <remarks>a LineSegment</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment.Data">
            <summary>
            Gets or sets the external data associated with this segment
            </summary>
            <remarks>a data object</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.EqualsTopologically(NetTopologySuite.Triangulate.Segment)">
            <summary>
            Determines whether two segments are topologically equal.
            I.e. equal up to orientation.
            </summary>
            <param name="s">a segment</param>
            <returns>true if the segments are topologically equal</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.Intersection(NetTopologySuite.Triangulate.Segment)">
            <summary>
            Computes the intersection point between this segment and another one.
            </summary>
            <param name="s">a segment</param>
            <returns>the intersection point, or <c>null</c> if there is none</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment.ToString">
            <summary>
            Computes a string representation of this segment.
            </summary>
            <returns>a string</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.SplitSegment">
            <summary>
            Models a constraint segment which can be split in two in various ways,
            according to certain geometric constraints.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment.PointAlongReverse(NetTopologySuite.Geometries.LineSegment,System.Double)">
            <summary>
            Computes the {@link Coordinate} that lies a given fraction along the line defined by the
            reverse of the given segment. A fraction of <c>0.0</c> returns the end point of the
            segment; a fraction of <c>1.0</c> returns the start point of the segment.
            </summary>
            <param name="seg">the LineSegment</param>
            <param name="segmentLengthFraction">the fraction of the segment length along the line</param>
            <returns>the point at that distance</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment.#ctor(NetTopologySuite.Geometries.LineSegment)">
            <summary>
            Creates an instance of this class using the provided <c>LineSegment</c>
            </summary>
            <param name="seg">A <c>LineSegment</c></param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.SplitSegment.MinimumLength">
            <summary>
            Gets or sets a value indicating the minimum length of a segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.SplitSegment.SplitPoint">
            <summary>
            Gets a value indicating the computed split point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment.SplitAt(System.Double,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the <see cref="P:NetTopologySuite.Triangulate.SplitSegment.SplitPoint"/> using the provided <paramref name="length"/> and <paramref name="endPt"/>.
            </summary>
            <param name="length">The length to split at</param>
            <param name="endPt">The <c>Coordinate</c> to split at</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment.SplitAt(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Computes the <see cref="P:NetTopologySuite.Triangulate.SplitSegment.SplitPoint"/> close to the given <c>Coordinate</c>,
            ensuring that <see cref="P:NetTopologySuite.Triangulate.SplitSegment.MinimumLength"/> is not violated.
            </summary>
            <param name="pt">The <c>Coordinate</c> to split at</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Tri.Tri">
            <summary>
            A memory-efficient representation of a triangle in a triangulation.
            Contains three vertices, and links to adjacent <c>Tri</c>s for each edge.
            <c>Tri</c>s are constructed independently, and if needed linked
            into a triangulation using <see cref="T:NetTopologySuite.Triangulate.Tri.TriangulationBuilder"/>.
            <para/>
            An edge of a Tri in a triangulation is called a boundary edge
            if it has no adjacent triangle.<br/>
            The set of Tris containing boundary edges are called the triangulation border.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.ToGeometry(System.Collections.Generic.ICollection{NetTopologySuite.Triangulate.Tri.Tri},NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s
            representing the triangles in a list.
            </summary>
            <param name="tris">A collection of <c>Tri</c>s</param>
            <param name="geomFact">The GeometryFactory to use</param>
            <returns>The <c>Polygon</c>s for the triangles</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.AreaOf(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Computes the area of a set of Tris.
            </summary>
            <param name="triList">A set of tris</param>
            <returns>The total area of the triangles</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Validate(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Validates a list of <c>Tri</c>s.
            </summary>
            <param name="triList">The list of <c>Tri</c>s to validate</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Create(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a triangle with the given vertices.
            The vertices should be oriented clockwise.
            </summary>
            <param name="p0">The first triangle vertex</param>
            <param name="p1">The second triangle vertex</param>
            <param name="p2">The third triangle vertex</param>
            <returns>The created trianlge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Create(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Creates a triangle from an array with three vertex coordinates.
            The vertices should be oriented clockwise.
            </summary>
            <param name="pts">The array of vertex coordinates</param>
            <returns>The created triangle</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.P0">
            <summary>
            Gets a value indicating the 1st point of this <c>Tri</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.P1">
            <summary>
            Gets a value indicating the 2nd point of this <c>Tri</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.P2">
            <summary>
            Gets a value indicating the 3rd point of this <c>Tri</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.Tri0">
            <summary>
            Gets a value indicating the adjacent <c>Tri</c> across the edge <see cref="P:NetTopologySuite.Triangulate.Tri.Tri.P0"/> clockwise towards the next point.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.Tri1">
            <summary>
            Gets a value indicating the adjacent <c>Tri</c> across the edge <see cref="P:NetTopologySuite.Triangulate.Tri.Tri.P1"/> clockwise towards the next point.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.Tri2">
            <summary>
            Gets a value indicating the adjacent <c>Tri</c> across the edge <see cref="P:NetTopologySuite.Triangulate.Tri.Tri.P2"/> clockwise towards the next point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a triangle with the given vertices.
            The vertices should be oriented clockwise.
            </summary>
            <param name="p0">The first triangle vertex</param>
            <param name="p1">The second triangle vertex</param>
            <param name="p2">The third triangle vertex</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.SetAdjacent(NetTopologySuite.Triangulate.Tri.Tri,NetTopologySuite.Triangulate.Tri.Tri,NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Sets the adjacent triangles.<br/>
            The vertices of the adjacent triangles are
            assumed to match the appropriate vertices in this triangle.
            </summary>
            <param name="tri0">The triangle adjacent to edge 0</param>
            <param name="tri1">The triangle adjacent to edge 1</param>
            <param name="tri2">The triangle adjacent to edge 2</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.SetAdjacent(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Sets the triangle adjacent to the edge originating
            at a given vertex.<br/>
            The vertices of the adjacent triangles are
            assumed to match the appropriate vertices in this triangle.
            </summary>
            <param name="pt">The edge start point</param>
            <param name="tri">The adjacent triangle</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.SetTri(System.Int32,NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Sets the triangle adjacent to an edge.<br/>
            The vertices of the adjacent triangle are
            assumed to match the appropriate vertices in this triangle.
            </summary>
            <param name="edgeIndex">The edge triangle is adjacent to</param>
            <param name="tri">The adjacent triangle</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Split(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Splits a triangle by a point located inside the triangle.
            Creates the three new resulting triangles with adjacent links
            set correctly.
            Returns the new triangle whose 0'th vertex is the splitting point.
            </summary>
            <param name="p">The point to insert</param>
            <returns>The new triangle whose 0'th vertex is <paramref name="p"/></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Flip(System.Int32)">
            <summary>
            Interchanges the vertices of this triangle and a neighbor
            so that their common edge
            becomes the the other diagonal of the quadrilateral they form.
            Neighbour triangle links are modified accordingly.
            </summary>
            <param name="index">The index of the adjacent tri to flip with</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Replace(NetTopologySuite.Triangulate.Tri.Tri,NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Replaces an adjacent triangle with a different one.
            </summary>
            <param name="triOld">An adjacent triangle</param>
            <param name="triNew">The triangle to replace with</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Degree(System.Int32,System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Computes the degree of a Tri vertex, which is the number of tris containing it.
            This must be done by searching the entire triangulation,
            since the containing tris may not be adjacent or edge-connected. 
            </summary>
            <param name="index">The vertex index</param>
            <param name="triList">The triangulation</param>
            <returns>The degree of the vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Remove(System.Collections.Generic.IList{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Removes this tri from the triangulation containing it.
            All links between the tri and adjacent ones are nulled.
            </summary>
            <param name="triList">The triangulation</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Remove">
            <summary>
            Removes this triangle from a triangulation.
            All adjacent references and the references to this
            Tri in the adjacent Tris are set to <c>null</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetAdjacentTris(NetTopologySuite.Triangulate.Tri.Tri,System.Int32,System.Int32)">
            <summary>
            Gets the triangles adjacent to the quadrilateral
            formed by this triangle and an adjacent one.
            The triangles are returned in the following order:
            <para/>
            Order:
            <list type="number">
            <item><description>opp0-adj0 edge</description></item>
            <item><description>opp0-adj1 edge</description></item>
            <item><description>opp1-adj0 edge</description></item>
            <item><description>opp1-adj1 edge</description></item>
            </list>
            </summary>
            <param name="triAdj">An adjacent triangle</param>
            <param name="index">The index of the common edge in this triangle</param>
            <param name="indexAdj">The index of the common edge in the adjacent triangle</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Validate">
            <summary>
            Validates that a <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/> is correct.
            Currently just checks that orientation is CW.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/> is not valid</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.ValidateAdjacent(System.Int32)">
            <summary>
            Validates that the vertices of an adjacent linked triangle are correct.
            </summary>
            <param name="index">The index of the adjacent triangle</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetCoordinate(System.Int32)">
            <summary>
            Gets the coordinate for a vertex.
            This is the start vertex of the edge.
            </summary>
            <param name="index">The vertex (edge) index</param>
            <returns>The vertex coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetIndex(NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Gets the index of the triangle vertex which has a given coordinate (if any).
            This is also the index of the edge which originates at the vertex.
            </summary>
            <param name="p">The coordinate to find</param>
            <returns>The vertex index, or -1 if it is not in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetIndex(NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Gets the edge index which a triangle is adjacent to (if any),
            based on the adjacent triangle link.
            </summary>
            <param name="tri">The <c>Tri</c> to find</param>
            <returns>The index of the edge adjacent to the triangle, or -1 if not found</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetAdjacent(System.Int32)">
            <summary>
            Gets the triangle adjacent to an edge.
            </summary>
            <param name="index">The edge index</param>
            <returns>The adjacent triangle (may be <c>null</c>)</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.HasAdjacent">
            <summary>
            Tests if this tri has any adjacent tris.
            </summary>
            <returns><c>true</c> if there is at least one adjacent tri</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.HasAdjacent(System.Int32)">
            <summary>
            Tests if there is an adjacent triangle to an edge.
            </summary>
            <param name="index">The edge index</param>
            <returns><c>true</c> if there is a triangle adjacent to edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.IsAdjacent(NetTopologySuite.Triangulate.Tri.Tri)">
            <summary>
            Tests if a triangle is adjacent to some edge of this triangle.
            </summary>
            <param name="tri">The triangle to test</param>
            <returns><c>true</c> if the triangle is adjacent</returns>
            <see cref="M:NetTopologySuite.Triangulate.Tri.Tri.GetIndex(NetTopologySuite.Triangulate.Tri.Tri)"/>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.NumAdjacent">
            <summary>
            Computes the number of triangle adjacent to this triangle.
            This is a number in the range [0,2].</summary>
            <returns>The number of adjacent triangles</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.IsInteriorVertex(System.Int32)">
            <summary>
            Tests if a tri vertex is interior.
            A vertex of a triangle is interior if it
            is fully surrounded by other triangles.
            </summary>
            <param name="index">The vertex index</param>
            <returns><c>true</c> if the vertex is interior</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.IsBorder">
            <summary>
            Tests if a tri contains a boundary edge,
            and thus on the border of the triangulation containing it.
            </summary>
            <returns><c>true</c> if the tri is on the border of the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.IsBoundary(System.Int32)">
            <summary>
            Tests if an edge is on the boundary of a triangulation.
            </summary>
            <param name="index">The index of an edge</param>
            <returns><c>true</c> if the edge is on the boundary</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Next(System.Int32)">
            <summary>
            Computes the vertex or edge index which is the next one
            (counter-clockwise) around the triangle.
            </summary>
            <param name="index">The index</param>
            <returns>The next index value</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.Prev(System.Int32)">
            <summary>
            Computes the vertex or edge index which is the previous one
            (counter-clockwise) around the triangle.
            </summary>
            <param name="index">The index</param>
            <returns>The previous index value</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.OppVertex(System.Int32)">
            <summary>
            Gets the index of the vertex opposite an edge.
            </summary>
            <param name="edgeIndex">The edge index</param>
            <returns>The index of the opposite vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.OppEdge(System.Int32)">
            <summary>
            Gets the index of the edge opposite a vertex.
            </summary>
            <param name="vertexIndex">The index of the vertex</param>
            <returns>The index of the opposite edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.MidPoint(System.Int32)">
            <summary>
            Computes a coordinate for the midpoint of a triangle edge.
            </summary>
            <param name="edgeIndex">The edge index</param>
            <returns>the midpoint of the triangle edge</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.Area">
            <summary>Gets the area of the triangle.</summary>
            <returns>The area of the triangle</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.Tri.Length">
            <summary>
            Gets the perimeter length of the perimeter of the triangle.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.GetLength(System.Int32)">
            <summary>
            Gets the length of an edge of the triangle.
            </summary>
            <param name="edgeIndex">The edge index</param>
            <returns>The edge length</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.ToPolygon(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Creates a <see cref="N:NetTopologySuite.Triangulate.Polygon"/> representing this triangle.
            </summary>
            <param name="geomFact">The geometry factory</param>
            <returns>A polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.Tri.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Tri.TriangulationBuilder">
            <summary>
            Builds a triangulation from a set of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s
            by populating the links to adjacent triangles.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.TriangulationBuilder.Build(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Computes the triangulation of a set of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s.
            </summary>
            <param name="triList">An enumeration of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.TriangulationBuilder.#ctor(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Tri.Tri})">
            <summary>
            Creates an instance of this class and computes the triangulation of a set of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s.
            </summary>
            <param name="triList">An enumeration of <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>s</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Tri.TriEdge">
            <summary>
            Represents an edge in a <see cref="T:NetTopologySuite.Triangulate.Tri.Tri"/>,
            to be used as a key for looking up Tris
            while building a triangulation.
            The edge value is normalized to allow lookup
            of adjacent triangles.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.TriEdge.P0">
            <summary>
            Gets or sets a value indicating the start point of this <see cref="T:NetTopologySuite.Triangulate.Tri.TriEdge"/>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Tri.TriEdge.P1">
            <summary>
            Gets or sets a value indicating the end point of this <see cref="T:NetTopologySuite.Triangulate.Tri.TriEdge"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Tri.TriEdge.#ctor(NetTopologySuite.Geometries.Coordinate,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="a">A coordinate</param>
            <param name="b">A coordinate</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper">
            <summary>
            Creates a map between the vertex <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s of a
            set of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s,
            and the parent geometry, and transfers the source geometry
            data objects to geometry components tagged with the coordinates.
            </summary>
            <remarks>
            This class can be used in conjunction with <see cref="T:NetTopologySuite.Triangulate.VoronoiDiagramBuilder"/>
            to transfer data objects from the input site geometries
            to the constructed Voronoi polygons.
            </remarks>
            <author>Martin Davis</author>
            <see cref="T:NetTopologySuite.Triangulate.VoronoiDiagramBuilder"/>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.LoadSourceGeometries(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Loads the vertices of a geometry and maps them with th the <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/>.
            </summary>
            <param name="geoms">A geometry</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.LoadSourceGeometries(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Loads the vertices of a collection of geometries and maps them with the <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/>.
            </summary>
            <param name="geoms">A collection of geometry</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.LoadSourceGeometries(NetTopologySuite.Geometries.GeometryCollection)">
            <summary>
            Loads the vertices of the geometries of a <c>GeometryCollection</c> and maps them with the <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/>.
            </summary>
            <param name="geomColl">A <c>GeometryCollection</c></param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.Coordinates">
            <summary>
            Gets a value indicating the coordinates.
            </summary>
            <returns>A list of <c>Coordinate</c>s.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.TransferData(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Input is assumed to be a multiGeometry
            in which every component has its userData
            set to be a Coordinate which is the key to the output data.
            The Coordinate is used to determine
            the output data object to be written back into the component.
            </summary>
            <param name="targetGeom" />
        </member>
        <member name="T:NetTopologySuite.Triangulate.VoronoiDiagramBuilder">
            <summary>
            A utility class which creates Voronoi Diagrams
            from collections of points.
            The diagram is returned as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s,
            representing the faces of the Voronoi diagram.
            /// The faces are clipped to the larger of:
            <list type="bullet">
            <item>
                <description>an envelope supplied by <see cref="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.set_ClipEnvelope(NetTopologySuite.Geometries.Envelope)"/>.</description>
            </item>
            <item>
                <description>an envelope determined by the input sites.</description>
            </item>
            </list>
            The <tt>userData</tt> attribute of each face <tt>Polygon</tt> is set to
            the <tt>Coordinate</tt>  of the corresponding input site.
            This allows using a <tt>Map</tt> to link faces to data associated with sites.
            </summary>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.SetSites(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Sets the sites (point or vertices) which will be diagrammed.
            All vertices of the given geometry will be used as sites.
            </summary>
            <param name="geom">geom the geometry from which the sites will be extracted.</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.SetSites(System.Collections.Generic.ICollection{NetTopologySuite.Geometries.Coordinate})">
            <summary>
            Sets the sites (point or vertices) which will be diagrammed
            from a collection of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="coords">a collection of Coordinates.</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.ClipEnvelope">
            <summary>
            Sets the envelope to clip the diagram to.
            The diagram will be clipped to the larger
            of this envelope or an envelope surrounding the sites.
            </summary>
            <remarks>the clip envelope.</remarks>
        </member>
        <member name="P:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.Tolerance">
            <summary>
            Sets the snapping tolerance which will be used
            to improved the robustness of the triangulation computation.
            A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
            <remarks>tolerance the tolerance distance to use</remarks>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.GetSubdivision">
            <summary>
            Gets the <see cref="T:NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision"/> which models the computed diagram.
            </summary>
            <returns>the subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder.GetDiagram(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Gets the faces of the computed diagram as a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/>
            of <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s, clipped as specified.
            <para/>
            The <see cref="P:NetTopologySuite.Geometries.Geometry.UserData"/> attribute of each face <see cref="N:NetTopologySuite.Triangulate.Polygon"/> is set to
            the <c>Coordinate</c> of the corresponding input site.
            This allows using a <see cref="T:System.Collections.Generic.IDictionary`2"/> to link faces to data associated with sites.
            </summary>
            <param name="geomFact">the geometry factory to use to create the output</param>
            <returns>a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/> containing the face <see cref="N:NetTopologySuite.Triangulate.Polygon"/>s of the diagram</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2">
            <summary>
            An alternative implementation of the priority queue abstract data type.
            This allows us to do more than <see cref="T:NetTopologySuite.Utilities.PriorityQueue`1"/>, which we
            got from JTS.  Ultimately, this queue enables scenarios that have more
            favorable execution speed characteristics at the cost of less favorable
            memory and usability characteristics.
            </summary>
            <typeparam name="TPriority">
            The type of the priority for each queue node.
            </typeparam>
            <typeparam name="TData">
            The type of data stored in the queue.
            </typeparam>
            <remarks>
            When enumerating over the queue, note that the elements will not be in
            sorted order.  To get at the elements in sorted order, use the copy
            constructor and repeatedly <see cref="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Dequeue"/> elements from it.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.#ctor">
            <summary>
            Initializes a new instance of the
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> class.
            </summary>
            <param name="capacity">
            The initial queue capacity.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> class.
            </summary>
            <param name="priorityComparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> to use to compare priority values,
            or <see langword="null"/> to use the default comparer for the type.
            </param>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> class.
            </summary>
            <param name="capacity">
            The initial queue capacity.
            </param>
            <param name="priorityComparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> to use to compare priority values,
            or <see langword="null"/> to use the default comparer for the type.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than 1.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.#ctor(NetTopologySuite.Utilities.AlternativePriorityQueue{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> class.
            </summary>
            <param name="copyFrom">
            The <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/> to
            copy from.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="copyFrom"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Count">
            <summary>
            Gets the number of nodes currently stored in this queue.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Head">
            <summary>
            Gets the node at the head of the queue.
            This is the node whose <typeparamref name="TPriority"/> compares
            less than or equal to the priority of all other nodes in the queue.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Clear">
            <summary>
            Removes all nodes from this queue.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Contains(NetTopologySuite.Utilities.PriorityQueueNode{`0,`1})">
            <summary>
            Determines whether the given node is contained within this queue.
            </summary>
            <param name="node">
            The node to locate in the queue.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="node"/> is found in the
            queue, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Enqueue(NetTopologySuite.Utilities.PriorityQueueNode{`0,`1},`0)">
            <summary>
            Adds a given node to the queue with the given priority.
            </summary>
            <param name="node">
            The node to add to the queue.
            </param>
            <param name="priority">
            The priority for the node.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="node"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Dequeue">
            <summary>
            Removes and returns the head of the queue.
            </summary>
            <returns>
            The removed element.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.ChangePriority(NetTopologySuite.Utilities.PriorityQueueNode{`0,`1},`0)">
            <summary>
            Changes the priority of the given node.
            </summary>
            <param name="node">
            The node whose priority to change.
            </param>
            <param name="priority">
            The new priority for the node.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="node"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.Remove(NetTopologySuite.Utilities.PriorityQueueNode{`0,`1})">
            <summary>
            Removes the given node from this queue if it is present.
            </summary>
            <param name="node">
            The node to remove if present.
            </param>
            <returns>
            A value indicating whether the node was removed.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:NetTopologySuite.Utilities.AlternativePriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:NetTopologySuite.Utilities.Assert">
            <summary>
            A utility for making programming assertions.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.IsTrue(System.Boolean)">
            <summary>
            Tests if <paramref name="assertion"/> is <c>true</c>
            <para/>
            If the test fails, <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with no message is thrown.
            </summary>
            <param name="assertion">The assertion value</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
            Tests if <paramref name="assertion"/> is <c>true</c>
            <para/>
            If the test fails, <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with <paramref name="message"/> is thrown.
            </summary>
            <param name="assertion">The assertion value</param>
            <param name="message">A message describing the failure condition.</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.IsEquals(System.Object,System.Object)">
            <summary>
            Tests if two values are equal.
            <para/>
            If the test fails, <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with no specific message is thrown.
            </summary>
            <param name="expectedValue">The expected value</param>
            <param name="actualValue">The actual value</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.IsEquals(System.Object,System.Object,System.String)">
            <summary>
            Tests if two values are equal.
            <para/>
            If the test fails, <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with <paramref name="message"/> is thrown.
            </summary>
            <param name="expectedValue">The expected value</param>
            <param name="actualValue">The actual value</param>
            <param name="message">A message describing the failure condition.</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.ShouldNeverReachHere">
            <summary>
            Throws an <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with no specific message text.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Assert.ShouldNeverReachHere(System.String)">
            <summary>
            Throws an <see cref="T:NetTopologySuite.Utilities.AssertionFailedException"/> with <paramref name="message"/> as specific message text.
            </summary>
            <param name="message">A text describing the failure condition</param>
        </member>
        <member name="T:NetTopologySuite.Utilities.AssertionFailedException">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.AssertionFailedException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.AssertionFailedException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="T:NetTopologySuite.Utilities.CoordinateArrayFilter">
            <summary>
            A <c>CoordinateFilter</c> that creates an array containing every coordinate in a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.CoordinateArrayFilter.#ctor(System.Int32)">
            <summary>
            Constructs a <c>CoordinateArrayFilter</c>.
            </summary>
            <param name="size">The number of points that the <c>CoordinateArrayFilter</c> will collect.</param>
        </member>
        <member name="P:NetTopologySuite.Utilities.CoordinateArrayFilter.Coordinates">
            <summary>
            Returns the <c>Coordinate</c>s collected by this <c>CoordinateArrayFilter</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.CoordinateArrayFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="T:NetTopologySuite.Utilities.CoordinateCompare">
            <summary>
            CoordinateCompare is used in the sorting of arrays of Coordinate objects.
            Implements a lexicographic comparison.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.CoordinateCompare.Compare(System.Object,System.Object)">
             <summary>
             Compares two object and returns a value indicating whether one is less than, equal to or greater
             than the other.
             </summary>
             <param name="x">First Coordinate object to compare.</param>
             <param name="y">Second Coordinate object to compare.</param>
             <returns>
            &lt;table cellspacing="0" class="dtTABLE"&gt;
            &lt;TR VALIGN="top"&gt;
                &lt;TH width=50%&gt;Value&lt;/TH&gt;
            &lt;TH width=50%&gt;Condition&lt;/TH&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
                &lt;TD width=50%&gt;Less than zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; is less than &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
                &lt;TD width=50%&gt;Zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; equals &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
                &lt;TD width=50%&gt;Greater than zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; is greater than &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;/table&gt;
             </returns>
             <remarks>If a implements IComparable, then a. CompareTo (b) is returned; otherwise, if b
             implements IComparable, then b. CompareTo (a) is returned.
             Comparing a null reference (Nothing in Visual Basic) with any type is allowed and does not
             generate an exception when using IComparable. When sorting, a null reference (Nothing) is
             considered to be less than any other object.
             </remarks>
        </member>
        <member name="T:NetTopologySuite.Utilities.CoordinateCountFilter">
            <summary>
            A <c>CoordinateFilter</c> that counts the total number of coordinates
            in a <c>Geometry</c>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.CoordinateCountFilter.Count">
            <summary>
            Returns the result of the filtering.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.CoordinateCountFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="T:NetTopologySuite.Utilities.Degrees">
            <summary>
            Converts degrees to radians.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Degrees.ToRadians(System.Double)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="degrees">The angle in degrees.</param>
            <returns>The angle in radians.</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.FunctionsUtil">
            <summary>
            A utility class to get <see cref="T:NetTopologySuite.Geometries.GeometryFactory"/>s, <see cref="T:NetTopologySuite.Geometries.Envelope"/>s
            off of <see cref="T:NetTopologySuite.Geometries.Geometry"/>s or to build aggregate geometries.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.FunctionsUtil.DefaultEnvelope">
            <summary>
            Gets a default envelope
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.GetEnvelopeOrDefault(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Gets the envelope of a geometry.
            </summary>
            <param name="g">A geometry</param>
            <returns>The envelope of <paramref name="g"/> or <see cref="F:NetTopologySuite.Utilities.FunctionsUtil.DefaultEnvelope"/> if <c>g == null</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.GetFactoryOrDefault(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Function to get the geometry factory of a geometry. If
            <paramref name="g"/> is <c>null</c>, a default geometry
            factory is returned.
            </summary>
            <param name="g">A geometry</param>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.GetFactoryOrDefault(System.Collections.Generic.IEnumerable{NetTopologySuite.Geometries.Geometry})">
            <summary>
            Function to get the geometry factory of the first
            geometry in a series of geometries.<para/>
            If no geometry is provided in <paramref name="gs"/>,
            a default geometry factory is returned.
            </summary>
            <param name="gs">An enumeration of geometries</param>
            <returns>A geometry factory</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.BuildGeometry(System.Collections.Generic.List{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.Geometry)">
            <summary>
            Builds a geometry from a list of geometries.
            <para/>
            The function returns
            <list type="bullet">
            <item><term><c>null</c></term><description>if the list is <c>null</c> or empty</description></item>
            <item><term><c><paramref name="geoms"/>[0]</c></term><description>if the list contains one single item.</description></item>
            <item><term>a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/></term>if <paramref name="parentGeom"/> is a <tt>GeometryCollection</tt>.</item>
            <item><term>a <tt>Multi</tt>-geometry</term> in all other cases.</item>
            </list>
            </summary>
            <param name="geoms">A list of geometries.</param>
            <param name="parentGeom">A parent geometry</param>
            <returns>A geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.BuildGeometry(System.Collections.Generic.IList{NetTopologySuite.Geometries.Geometry},NetTopologySuite.Geometries.Geometry)">
            <summary>
            Builds a geometry from a list of geometries.
            <para/>
            The function returns
            <list type="bullet">
            <item><term><c>null</c></term><description>if the list is <c>null</c> or empty</description></item>
            <item><term><c><paramref name="geoms"/>[0]</c></term><description>if the list contains one single item.</description></item>
            <item><term>a <see cref="T:NetTopologySuite.Geometries.GeometryCollection"/></term>if <paramref name="parentGeom"/> is a <tt>GeometryCollection</tt>.</item>
            <item><term>a <tt>Multi</tt>-geometry</term> in all other cases.</item>
            </list>
            </summary>
            <param name="geoms">A list of geometries.</param>
            <param name="parentGeom">A parent geometry</param>
            <returns>A geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.BuildGeometry(NetTopologySuite.Geometries.Geometry[])">
            <summary>
            Method to build a geometry. 
            </summary>
            <param name="geoms">An array of geometries</param>
            <returns>A <c>GEOMETRYCOLLECTION</c> containing <paramref name="geoms"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.FunctionsUtil.BuildGeometry(NetTopologySuite.Geometries.Geometry,NetTopologySuite.Geometries.Geometry)">
            <summary>
            Method to build a geometry.
            </summary>
            <param name="a">A geometry</param>
            <param name="b">A geometry</param>
            <returns>A <c>GEOMETRYCOLLECTION</c> containing <paramref name="a"/> and <paramref name="b"/>.</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.GeometricShapeFactory">
            <summary>
            Computes various kinds of common geometric shapes.
            Allows various ways of specifying the location and extent of the shapes,
            as well as number of line segments used to form them.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.GeometricShapeFactory.GeomFact">
            <summary>
            A geometry factory
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.GeometricShapeFactory.PrecModel">
            <summary>
            A precision model
            </summary>
            
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.#ctor">
            <summary>
            Create a shape factory which will create shapes using the default GeometryFactory.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.#ctor(NetTopologySuite.Geometries.GeometryFactory)">
            <summary>
            Create a shape factory which will create shapes using the given GeometryFactory.
            </summary>
            <param name="geomFact">The factory to use.</param>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Base">
            <summary>
            Gets/Sets the location of the shape by specifying the base coordinate
            (which in most cases is the
            lower left point of the envelope containing the shape).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Centre">
            <summary>
            Gets/Sets the location of the shape by specifying the centre of
            the shape's bounding box.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Envelope">
            <summary>
            Gets or sets the envelope of the shape
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.NumPoints">
            <summary>
            Gets/Sets the total number of points in the created Geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Size">
            <summary>
            Gets/Sets the size of the extent of the shape in both x and y directions.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Width">
            <summary>
            Gets/Sets the width of the shape.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Height">
            <summary>
            Gets/Sets the height of the shape.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Rotation">
            <summary>
            Gets/Sets the rotation angle, in radians, to use for the shape.
            The rotation is applied relative to the centre of the shape.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.Rotate(NetTopologySuite.Geometries.Geometry)">
            <summary>
            Rotates a geometry by <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Rotation"/> angle
            </summary>
            <param name="geom">The geometry to rotate</param>
            <returns>A rotated geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateCoord(System.Double,System.Double)">
            <summary>
            Creates a coordinate at (<paramref name="x"/>, <paramref name="y"/>)
            </summary>
            <param name="x">The x-ordinate value</param>
            <param name="y">The y-ordinate value</param>
            <returns>A coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateCoordTrans(System.Double,System.Double,NetTopologySuite.Geometries.Coordinate)">
            <summary>
            Creates a translated coordinate at (<paramref name="x"/> + <paramref name="trans.X.X"/>, <paramref name="y"/> + <paramref name="trans.Y.Y"/>)
            </summary>
            <param name="x">The x-ordinate value</param>
            <param name="y">The y-ordinate value</param>
            <param name="trans">A translation vector (coordinate)</param>
            <returns>A coordinate</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateRectangle">
            <summary>
            Creates a rectangular <c>Polygon</c>.
            </summary>
            <returns>A rectangular polygon.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateCircle">
            <summary>
            Creates a circular <c>Polygon</c>.
            </summary>
            <returns>A circular polygon.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateEllipse">
            <summary>
            Creates an elliptical <c>Polygon</c>.
            If the supplied envelope is square the
            result will be a circle.
            </summary>
            <returns>An an ellipse or circle.</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateSquircle">
            <summary>
            Creates a squircular <see cref="T:NetTopologySuite.Geometries.Polygon"/>.
            </summary>
            <returns>a squircle</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateSupercircle(System.Double)">
            <summary>
            Creates a supercircular <see cref="T:NetTopologySuite.Geometries.Polygon"/>
            of a given positive power.
            </summary>
            <returns>a supercircle</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateArc(System.Double,System.Double)">
            <summary>
            Creates a elliptical arc, as a LineString.
            </summary><remarks>
            The arc is always created in a counter-clockwise direction.
            </remarks>
            <param name="startAng">Start angle in radians</param>
            <param name="angExtent">Size of angle in radians</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.GeometricShapeFactory.CreateArcPolygon(System.Double,System.Double)">
            <summary>
            Creates an elliptical arc polygon.
            </summary>
            <remarks>
            The polygon is formed from the specified arc of an ellipse
            and the two radii connecting the endpoints to the centre of the ellipse.
            </remarks>
            <param name="startAng">Start angle in radians</param>
            <param name="angExtent">Size of angle in radians</param>
            <returns>An elliptical arc polygon</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions">
            <summary>
            A dimension class for <see cref="T:NetTopologySuite.Utilities.GeometricShapeFactory"/>s
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Base">
            <summary>
            Gets or sets a value indicating the base of the shapes to be created
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Centre">
            <summary>
            Gets or sets a value indicating the centre of the shapes to be created
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Width">
            <summary>
            Gets or sets a value indicating the width of the <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Envelope"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Height">
            <summary>
            Gets or sets a value indicating the height of the <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Envelope"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Size">
            <summary>
            Sets <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Width"/> and <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Height"/> to the same value
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.MinSize">
            <summary>
            Gets a value indicating the minimum size of the shape's <see cref="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Envelope"/>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.Envelope">
            <summary>
            Gets or sets a value indicating the bounds of the shape to be created
            </summary>
        </member>
        <member name="T:NetTopologySuite.Utilities.Global">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Global.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.Global.global">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Global.GetNfi">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.Guard">
            <summary>
            A guard class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Guard.IsNotNull(System.Object,System.String)">
            <summary>
            Checks if a value is <b>not</b> <c>null</c>.
            </summary>
            <param name="candidate">The value to check for <c>null</c></param>
            <param name="propertyName">The name of the property that <paramref name="candidate"/> belongs to.</param>
        </member>
        <member name="T:NetTopologySuite.Utilities.HexConverter">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.HexConverter.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.HexConverter.ConvertAny2Any(System.String,System.Int32,System.Int32)">
            <summary>
            Convert the given numeric value (passed as string) of the base specified by <c>baseIn</c>
            to the value specified by <c>baseOut</c>.
            </summary>
            <param name="valueIn">Numeric value to be converted, as string.</param>
            <param name="baseIn">Base of input value.</param>
            <param name="baseOut">Base to use for conversion.</param>
            <returns>Converted value, as string.</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.Memory">
            <summary>
            Utility functions to report memory usage.
            </summary>
            <author>mbdavis</author>
        </member>
        <member name="P:NetTopologySuite.Utilities.Memory.Total">
            <summary>
            Gets a value indicating the total memory used.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.Memory.TotalString">
            <summary>
            Gets a string describing the total memory used
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.Memory.KB">
            <summary>
            Number of bytes in a kilo-byte
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.Memory.MB">
            <summary>
            Number of bytes in mega-byte
            </summary>
        </member>
        <member name="F:NetTopologySuite.Utilities.Memory.GB">
            <summary>
            Number of bytes in a giga-byte
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Memory.Format(System.Int64)">
            <summary>
            Formats a number of bytes
            </summary>
            <param name="mem">The number of bytes</param>
            <returns>A string describing a number of bytes</returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.Memory.Round(System.Double)">
            <summary>
            Rounds a double to 2 decimal places
            </summary>
            <param name="d">The number to round</param>
            <returns>The rounded number</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.PriorityQueue`1">
            <summary>
            A priority queue over a set of <see cref="T:System.IComparable`1"/> objects.
            </summary>
            <typeparam name="T">Objects to add</typeparam>
            <author>Martin Davis</author>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.#ctor">
            <summary>
            Creates an instance of this class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="capacity">The capacity of the queue</param>
            <param name="comparer">The comparer to use for computing priority values</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.Add(`0)">
            <summary>Insert into the priority queue. Duplicates are allowed.
            </summary>
            <param name="x">The item to insert.</param>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.IsEmpty">
            <summary>
            Test if the priority queue is logically empty.
            </summary>
            <returns><c>true</c> if empty, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:NetTopologySuite.Utilities.PriorityQueue`1.Size">
            <summary>
            Returns size.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.Clear">
            <summary>
            Make the priority queue logically empty.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.Poll">
            <summary>
            Remove the smallest item from the priority queue.
            </summary>
            <remarks>The smallest item, or <c>default(T)</c> if empty.</remarks>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.Peek">
            <summary>
            Gets the smallest item without removing it from the queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueue`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>>
        </member>
        <member name="T:NetTopologySuite.Utilities.PriorityQueueNode`2">
            <summary>
            A container for a prioritized node that sites in an
            <see cref="T:NetTopologySuite.Utilities.AlternativePriorityQueue`2"/>.
            </summary>
            <typeparam name="TPriority">
            The type to use for the priority of the node in the queue.
            </typeparam>
            <typeparam name="TData">
            The type to use for the data stored by the node in the queue.
            </typeparam>
        </member>
        <member name="M:NetTopologySuite.Utilities.PriorityQueueNode`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Utilities.PriorityQueueNode`2"/> class.
            </summary>
            <param name="data">
            The <typeparamref name="TData"/> to store in this node.
            </param>
        </member>
        <member name="P:NetTopologySuite.Utilities.PriorityQueueNode`2.Data">
            <summary>
            Gets the <typeparamref name="TData"/> that is stored in this node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Utilities.PriorityQueueNode`2.Priority">
            <summary>
            Gets the <typeparamref name="TPriority"/> of this node in the queue.
            </summary>
            <remarks>
            The queue may update this priority while the node is still in the queue.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Utilities.PriorityQueueNode`2.QueueIndex">
            <summary>
            Gets or sets the index of this node in the queue.
            </summary>
            <remarks>
            This should only be read and written by the queue itself.
            It has no "real" meaning to anyone else.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Utilities.Radians">
            <summary>
            Converts radians to degress.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.Radians.ToDegrees(System.Double)">
            <summary>
            Converts radians to degress.
            </summary>
            <param name="radians">Angle in radians.</param>
            <returns>The angle in degrees.</returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.ReverseOrder">
             <summary>
            
             </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.ReverseOrder.Compare(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <param name="y"></param>
             <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Utilities.UniqueCoordinateArrayFilter">
            <summary>
            A <see cref="T:NetTopologySuite.Geometries.ICoordinateFilter"/>
            that extracts a unique array of<c>Coordinate</c> s.
            The array of coordinates contains no duplicate points.
            <para/>
            It preserves the order of the input points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.FilterCoordinates(NetTopologySuite.Geometries.Coordinate[])">
            <summary>
            Convenience method which allows running the filter over an array of <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <param name="coords">an array of coordinates</param>
            <returns>an array of the unique coordinates</returns>
        </member>
        <member name="P:NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.Coordinates">
            <summary>
            Returns the gathered <see cref="T:NetTopologySuite.Geometries.Coordinate"/>s.
            </summary>
            <returns>The <c>Coordinate</c>s collected by this <c>ICoordinateArrayFilter</c></returns>
        </member>
        <member name="M:NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.Filter(NetTopologySuite.Geometries.Coordinate)">
            <inheritdoc cref="M:NetTopologySuite.Geometries.ICoordinateFilter.Filter(NetTopologySuite.Geometries.Coordinate)"/>
        </member>
        <member name="T:RTools_NTS.Util.CharBuffer">
            <summary>
            Buffer for characters.  This approximates StringBuilder
            but is designed to be faster for specific operations.
            This is about 30% faster for the operations I'm interested in
            (Append, Clear, Length, ToString).
            This trades off memory for speed.
            </summary>
            <remarks>
            <para>To make Remove from the head fast, this is implemented
            as a ring buffer.</para>
            <para>This uses head and tail indices into a fixed-size
            array. This will grow the array as necessary.</para>
            </remarks>
        </member>
        <member name="P:RTools_NTS.Util.CharBuffer.Length">
            <summary>
            Gets/Sets the number of characters in the character buffer.
            Increasing the length this way provides indeterminate results.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.CharBuffer.Capacity">
            <summary>
            Returns the capacity of this character buffer.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.#ctor(System.Int32)">
            <summary>
            Construct with a specific capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Grow(System.Int32)">
            <summary>
            Reallocate the buffer to be larger. For the new size, this
            uses the max of the requested length and double the current
            capacity.
            This does not shift, meaning it does not change the head or
            tail indices.
            </summary>
            <param name="requestedLen">The new requested length.</param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.CheckCapacity(System.Int32)">
            <summary>
            Ensure that we're set for the requested length by
            potentially growing or shifting contents.
            </summary>
            <param name="requestedLength"></param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.ShiftToZero">
            <summary>
            Move the buffer contents such that headIndex becomes 0.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.SetBuffer(System.Char[],System.Int32)">
            <summary>
            Overwrite this object's underlying buffer with the specified
            buffer.
            </summary>
            <param name="b">The character array.</param>
            <param name="len">The number of characters to consider filled
            in the input buffer.</param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Append(System.Char)">
            <summary>
            Append a character to this buffer.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Append(System.String)">
            <summary>
            Append a string to this buffer.
            </summary>
            <param name="s">The string to append.</param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Append(RTools_NTS.Util.CharBuffer)">
            <summary>
            Append a string to this buffer.
            </summary>
            <param name="s">The string to append.</param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Remove(System.Int32)">
            <summary>
            Remove a character at the specified index.
            </summary>
            <param name="i">The index of the character to remove.</param>
            <returns></returns>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a specified number of characters at the specified index.
            </summary>
            <param name="i">The index of the characters to remove.</param>
            <param name="n">The number of characters to remove.</param>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.IndexOf(System.Char)">
            <summary>
            Find the first instance of a character in the buffer, and
            return its index.  This returns -1 if the character is
            not found.
            </summary>
            <param name="c">The character to find.</param>
            <returns>The index of the specified character, or -1
            for not found.</returns>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.Clear">
            <summary>
            Empty the buffer.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.CharBuffer.Item(System.Int32)">
            <summary>
            Indexer.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CharBuffer.ToString">
            <summary>
            Return the current contents as a string.
            </summary>
            <returns>The new string.</returns>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizerUntermException">
            <summary>
            Exception class for unterminated tokens.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerUntermException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizerUntermQuoteException">
            <summary>
            Exception class for unterminated quotes.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerUntermQuoteException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizerUntermCommentException">
            <summary>
            Exception class for unterminated block comments.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerUntermCommentException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools_NTS.Util.CharTypeBits">
            <summary>
            Bitwise enumeration for character types.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Word">
            <summary>word characters (usually alpha, digits, and domain specific)</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Comment">
            <summary># or something for line comments</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Whitespace">
            <summary>whitespace</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Quote">
            <summary>' or " type</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Digit">
            <summary>usually 0 to 9</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.HexDigit">
            <summary>usually 0 to 9, a-f and A-F</summary>
        </member>
        <member name="F:RTools_NTS.Util.CharTypeBits.Eof">
            <summary>eof char</summary>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizerSettings">
            <summary>
            This contains the settings that control the behavior of the tokenizer.
            This is separated from the StreamTokenizer so that common settings
            are easy to package and keep together.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.CharTypes">
            <summary>
            This is the character type table.  Each byte is bitwise encoded
            with the character attributes, such as whether that character is
            word or whitespace.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.GrabWhitespace">
            <summary>
            Whether or not to return whitespace tokens.  If not, they're ignored.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.GrabEol">
            <summary>
            Whether or not to return EolTokens on end of line.  Eol tokens will not
            break up other tokens which can be multi-line.  For example block comments
            and quotes will not be broken by Eol tokens.  Therefore the number of
            Eol tokens does not give you the line count of a stream.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.SlashSlashComments">
            <summary>
            Whether or not to look for // comments
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.SlashStarComments">
            <summary>
            Whether or not to look for /* */ block comments.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.GrabComments">
            <summary>
            Whether or not to return comments.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.DoUntermCheck">
            <summary>
            Whether or not to check for unterminated quotes and block comments.
            If true, and one is encoutered, an exception is thrown of the appropriate type.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.ParseNumbers">
            <summary>
            Whether or not digits are specified as Digit type in the
            character table.
            This setting is based on the character types table, so this
            setting interacts with character type table manipulation.
            This setting may become incorrect if you modify the character
            types table directly.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizerSettings.ParseHexNumbers">
            <summary>
            Whether or not to parse Hex (0xABCD...) numbers.
            This setting is based on the character types table, so this
            setting interacts with character type table manipulation.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.#ctor(RTools_NTS.Util.StreamTokenizerSettings)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.Copy(RTools_NTS.Util.StreamTokenizerSettings)">
            <summary>
            Sets this object to be the same as the specified object.
            Note that some settings which are entirely embodied by the character
            type table.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.SetDefaults">
            <summary>
            Setup default parse behavior.
            This resets to same behavior as on construction.
            </summary>
            <returns>bool - true for success.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.SetupForCodeParse">
            <summary>
            Apply settings which are commonly used for code parsing
            C-endCapStyle code, including C++, C#, and Java.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.ResetCharTypeTable">
            <summary>
            Clear the character type settings.  This leaves them unset,
            as opposed to the default.  Use SetDefaults() for default
            settings.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.WordChar(System.Int32)">
            <summary>
            Specify that a particular character is a word character.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.WordChars(System.Int32,System.Int32)">
            <summary>
            Specify that a range of characters are word characters.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="startChar">First character.</param>
            <param name="endChar">Last character.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.WordChars(System.String)">
            <summary>
            Specify that a string of characters are word characters.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.WhitespaceChar(System.Int32)">
            <summary>
            Specify that a character is a whitespace character.
            Character table type manipulation method.
            This type is exclusive with other types.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.WhitespaceChars(System.Int32,System.Int32)">
            <summary>
            Specify that a range of characters are whitespace characters.
            Character table type manipulation method.
            This adds the characteristic to the char(s), rather
            than overwriting other characteristics.
            </summary>
            <param name="startChar">First character.</param>
            <param name="endChar">Last character.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.OrdinaryChars(System.Int32,System.Int32)">
            <summary>
            Remove other type settings from a range of characters.
            Character table type manipulation method.
            </summary>
            <param name="startChar"></param>
            <param name="endChar"></param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.OrdinaryChar(System.Int32)">
            <summary>
            Remove other type settings from a character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.CommentChar(System.Int32)">
            <summary>
            Specify that a particular character is a comment-starting character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.QuoteChar(System.Int32)">
            <summary>
            Specify that a particular character is a quote character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.CharTypeToString(System.Byte)">
            <summary>
            Return a string representation of a character type setting.
            Since the type setting is bitwise encoded, a character
            can have more than one type.
            </summary>
            <param name="ctype">The character type byte.</param>
            <returns>The string representation of the type flags.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.IsCharType(System.Byte,RTools_NTS.Util.CharTypeBits)">
            <summary>
            Check whether the specified char type byte has a
            particular type flag set.
            </summary>
            <param name="ctype">The char type byte.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.IsCharType(System.Char,RTools_NTS.Util.CharTypeBits)">
            <summary>
            Check whether the specified char has a
            particular type flag set.
            </summary>
            <param name="c">The character.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.IsCharType(System.Int32,RTools_NTS.Util.CharTypeBits)">
            <summary>
            Check whether the specified char has a
            particular type flag set.
            </summary>
            <param name="c">The character.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.Display">
            <summary>
            Display the state of this object.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizerSettings.Display(System.String)">
            <summary>
            Display the state of this object, with a per-line prefix.
            </summary>
            <param name="prefix">The pre-line prefix.</param>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizer">
            <summary>
            A StreamTokenizer similar to Java's.  This breaks an input stream
            (coming from a TextReader) into Tokens based on various settings.  The settings
            are stored in the TokenizerSettings property, which is a
            StreamTokenizerSettings instance.
            </summary>
            <remarks>
            <para>
            This is configurable in that you can modify TokenizerSettings.CharTypes[] array
            to specify which characters are which type, along with other settings
            such as whether to look for comments or not.
            </para>
            <para>
            WARNING: This is not internationalized.  This treats all characters beyond
            the 7-bit ASCII range (decimal 127) as Word characters.
            </para>
            <para>
            There are two main ways to use this: 1) Parse the entire stream at
            once and get an ArrayList of Tokens (see the Tokenize* methods),
            and 2) call NextToken() successively.
            This reads from a TextReader, which you can set directly, and this
            also provides some convenient methods to parse files and strings.
            This returns an Eof token if the end of the input is reached.
            </para>
            <para>
            Here's an example of the NextToken() endCapStyle of use:
            <code>
            StreamTokenizer tokenizer = new StreamTokenizer();
            tokenizer.GrabWhitespace = true;
            tokenizer.Verbosity = VerbosityLevel.Debug; // just for debugging
            tokenizer.TextReader = File.OpenText(fileName);
            Token token;
            while (tokenizer.NextToken(out token)) log.Info("Token = '{0}'", token);
            </code>
            </para>
            <para>
            Here's an example of the Tokenize... endCapStyle of use:
            <code>
            StreamTokenizer tokenizer = new StreamTokenizer("some string");
            ArrayList tokens = new ArrayList();
            if (!tokenizer.Tokenize(tokens))
            {
                // error handling
            }
            foreach (Token t in tokens) Console.WriteLine("t = {0}", t);
            </code>
            </para>
            <para>
            Comment delimiters are hardcoded (// and /*), not affected by char type table.
            </para>
            <para>
            This sets line numbers in the tokens it produces.  These numbers are normally
            the line on which the token starts.
            There is one known caveat, and that is that when GrabWhitespace setting
            is true, and a whitespace token contains a newline, that token's line number
            will be set to the following line rather than the line on which the token
            started.
            </para>
            </remarks>
        </member>
        <member name="F:RTools_NTS.Util.StreamTokenizer.NChars">
            <summary>
            This is the number of characters in the character table.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizer.TextReader">
            <summary>
            This is the TextReader that this object will read from.
            Set this to set the input reader for the parse.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.StreamTokenizer.Settings">
            <summary>
            The settings which govern the behavior of the tokenization.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Construct and set this object's TextReader to the one specified.
            </summary>
            <param name="sr">The TextReader to read from.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.#ctor(System.IO.TextReader,RTools_NTS.Util.StreamTokenizerSettings)">
            <summary>
            Construct and set this object's TextReader to the one specified.
            </summary>
            <param name="sr">The TextReader to read from.</param>
            <param name="tokenizerSettings">Tokenizer settings.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.#ctor(System.String)">
            <summary>
            Construct and set a string to tokenize.
            </summary>
            <param name="str">The string to tokenize.</param>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.Initialize">
            <summary>
            Utility function, things common to constructors.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.InitializeStream">
            <summary>
            Clear the stream settings.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.Display">
            <summary>
            Display the state of this object.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.Display(System.String)">
            <summary>
            Display the state of this object, with a per-line prefix.
            </summary>
            <param name="prefix">The pre-line prefix.</param>
        </member>
        <member name="T:RTools_NTS.Util.StreamTokenizer.NextTokenState">
            <summary>
            The states of the state machine.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.PickNextState(System.Byte,System.Int32)">
            <summary>
            Pick the next state given just a single character.  This is used
            at the start of a new token.
            </summary>
            <param name="ctype">The type of the character.</param>
            <param name="c">The character.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.PickNextState(System.Byte,System.Int32,RTools_NTS.Util.StreamTokenizer.NextTokenState)">
            <summary>
            Pick the next state given just a single character.  This is used
            at the start of a new token.
            </summary>
            <param name="ctype">The type of the character.</param>
            <param name="c">The character.</param>
            <param name="excludeState">Exclude this state from the possible next state.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.GetNextChar">
            <summary>
            Read the next character from the stream, or from backString
            if we backed up.
            </summary>
            <returns>The next character.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.NextToken(RTools_NTS.Util.Token@)">
            <summary>
            Get the next token.  The last token will be an EofToken unless
            there's an unterminated quote or unterminated block comment
            and Settings.DoUntermCheck is true, in which case this throws
            an exception of type StreamTokenizerUntermException or sub-class.
            </summary>
            <param name="token">The output token.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.GrabInt(RTools_NTS.Util.CharBuffer,System.Boolean,System.Char@)">
            <summary>
            Starting from current stream location, scan forward
            over an int.  Determine whether it's an integer or not.  If so,
            push the integer characters to the specified CharBuffer.
            If not, put them in backString (essentially leave the
            stream as it was) and return false.
            <para>
            If it was an int, the stream is left 1 character after the
            end of the int, and that character is output in the thisChar parameter.
            </para>
            <para>The formats for integers are: 1, +1, and -1</para>
            The + and - signs are included in the output buffer.
            </summary>
            <param name="sb">The CharBuffer to append to.</param>
            <param name="allowPlus">Whether or not to consider + to be part
            of an integer.</param>
            <param name="thisChar">The last character read by this method.</param>
            <returns>true for parsed an int, false for not an int</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.Tokenize(System.Collections.Generic.IList{RTools_NTS.Util.Token})">
            <summary>
            Parse the rest of the stream and put all the tokens
            in the input ArrayList. This resets the line number to 1.
            </summary>
            <param name="tokens">The ArrayList to append to.</param>
            <returns>bool - true for success</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.TokenizeReader(System.IO.TextReader,System.Collections.Generic.IList{RTools_NTS.Util.Token})">
            <summary>
            Parse all tokens from the specified TextReader, put
            them into the input ArrayList.
            </summary>
            <param name="tr">The TextReader to read from.</param>
            <param name="tokens">The ArrayList to append to.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.TokenizeFile(System.String,System.Collections.Generic.IList{RTools_NTS.Util.Token})">
            <summary>
            Parse all tokens from the specified file, put
            them into the input ArrayList.
            </summary>
            <param name="fileName">The file to read.</param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.TokenizeFile(System.String)">
            <summary>
            Tokenize a file completely and return the tokens in a Token[].
            </summary>
            <param name="fileName">The file to tokenize.</param>
            <returns>A Token[] with all tokens.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.TokenizeString(System.String,System.Collections.Generic.IList{RTools_NTS.Util.Token})">
            <summary>
            Parse all tokens from the specified string, put
            them into the input ArrayList.
            </summary>
            <param name="str"></param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.TokenizeStream(System.IO.Stream,System.Collections.Generic.IList{RTools_NTS.Util.Token})">
            <summary>
            Parse all tokens from the specified Stream, put
            them into the input ArrayList.
            </summary>
            <param name="s"></param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.GetEnumerator">
            <summary>
            Gibt einen Enumerator zurck, der die Auflistung durchluft.
            </summary>
            <returns>
            Ein <see cref="T:System.Collections.Generic.IEnumerator`1"/>, der zum Durchlaufen der Auflistung verwendet werden kann.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:RTools_NTS.Util.StreamTokenizer.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gibt einen Enumerator zurck, der eine Auflistung durchluft.
            </summary>
            <returns>
            Ein <see cref="T:System.Collections.IEnumerator"/>-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:RTools_NTS.Util.Token">
            <summary>
            Token class used by StreamTokenizer.
            This represents a single token in the input stream.
            This is subclassed to provide specific token types,
            such as CharToken, FloatToken, etc.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.Token._lineNumber">
            <summary>
            The line number in the input stream where this token originated.
            This is base-1.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.Token.LineNumber">
            <summary>
            The line number where this token was found.  This is base-1.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.Token.obj">
            <summary>
            A storage object for the data of this token.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.Token.Object">
            <summary>
            The Object stored by this token.  This will be
            a primitive C# type.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.Token.untermError">
            <summary>
            Backer for UntermError.
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.Token.UntermError">
            <summary>
            Whether or not there was an unterminated token problem
            when creating this token.  See UntermErrorMessage for
            a message associated with the problem.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.Token.untermErrorMsg">
            An error message associated with unterm error.
        </member>
        <member name="P:RTools_NTS.Util.Token.UntermErrorMsg">
            <summary>
            The error message if there was an unterminated token error
            creating this token.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.Token.#ctor(System.Int32)">
            <summary>
            Construct a Token with the specified line number.
            </summary>
            <param name="line">The line number where this
            token comes from.</param>
        </member>
        <member name="M:RTools_NTS.Util.Token.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>bool - true for equals, false otherwise.</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.Equals(System.String)">
            <summary>
            Equals overload.
            </summary>
            <param name="s">The string to compare to.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.Equals(System.Char)">
            <summary>
            Equals overload.
            </summary>
            <param name="c">The char to compare to.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Equality(RTools_NTS.Util.Token,System.Object)">
            <summary>
            Operator== overload.  Compare a token and an object.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="o">The other object.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Inequality(RTools_NTS.Util.Token,System.Object)">
            <summary>
            Operator!= overload.  Compare a token and an object.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="o">The other object.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Equality(RTools_NTS.Util.Token,System.Char)">
            <summary>
            Operator== overload.  Compare a token and a char.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="c">The char.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Inequality(RTools_NTS.Util.Token,System.Char)">
            <summary>
            Operator!= overload.  Compare a token and a char.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="c">The char.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Equality(RTools_NTS.Util.Token,System.String)">
            <summary>
            Operator== overload.  Compare a token and a string.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="s">The string.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.op_Inequality(RTools_NTS.Util.Token,System.String)">
            <summary>
            Operator!= overload.  Compare a token and a string.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="s">The string.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.GetHashCode">
            <summary>
            Override.  Returns the ToString().GetHashCode().
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="P:RTools_NTS.Util.Token.StringValue">
            <summary>
            Return this token's value as a string.
            </summary>
            <returns>This token's value as a string.</returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.ToLineString">
            <summary>
            Produce a string which includes the line number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.ToDebugString">
            <summary>
            Produce a string which includes the token type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools_NTS.Util.Token.ConvertToType(System.Type)">
            <summary>
            Create an object of the specified type corresponding to
            this token.
            </summary>
            <param name="t">The type of object to create.</param>
            <returns>The new object, or null for error.</returns>
        </member>
        <member name="T:RTools_NTS.Util.EolToken">
            <summary>
            Represents end-of-lines (line separator characters).
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.#ctor(System.Int32)">
            <summary>Constructor that takes line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.ToString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="P:RTools_NTS.Util.EolToken.StringValue">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EolToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="T:RTools_NTS.Util.EofToken">
            <summary>
            Represents end of file/stream.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.#ctor(System.Int32)">
            <summary>Constructor that takes line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.ToString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="P:RTools_NTS.Util.EofToken.StringValue">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.EofToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="T:RTools_NTS.Util.StringToken">
            <summary>
            Abstract base class for string tokens.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.StringToken.#ctor(System.String)">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools_NTS.Util.StringToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.StringToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.StringToken.ToString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="P:RTools_NTS.Util.StringToken.StringValue">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.StringToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="T:RTools_NTS.Util.WordToken">
            <summary>
            Token type for words, meaning sequences of word
            characters.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.WordToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.WordToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools_NTS.Util.QuoteToken">
            <summary>
            Token type for Quotes such as "this is a quote".
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.QuoteToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.QuoteToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools_NTS.Util.CommentToken">
            <summary>
            Token type for comments, including line and block
            comments.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CommentToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.CommentToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools_NTS.Util.WhitespaceToken">
            <summary>
            Token type for whitespace such as spaces and tabs.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.WhitespaceToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.WhitespaceToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools_NTS.Util.CharToken">
            <summary>
            Token type for characters, meaning non-word characters.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.#ctor(System.Char)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.#ctor(System.Char,System.Int32)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.ToString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="P:RTools_NTS.Util.CharToken.StringValue">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.CharToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="T:RTools_NTS.Util.FloatToken">
            <summary>
            Token type for floating point numbers, stored internally as a Double.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.#ctor(System.String)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.#ctor(System.Single)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.#ctor(System.Double)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructor with the specified value and line number.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor with the specified value and line number.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.ToDebugString">
            <summary>
            Override, see base <see cref="T:RTools_NTS.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.ToString">
            <summary>
            Override, see base <see cref="T:RTools_NTS.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.GetHashCode">
            <summary>
            Override, see base <see cref="T:RTools_NTS.Util.Token"/>
            </summary>
        </member>
        <member name="P:RTools_NTS.Util.FloatToken.StringValue">
            <summary>
            Override, see base <see cref="T:RTools_NTS.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.FloatToken.Equals(System.Object)">
            <summary>
            Override, see base <see cref="T:RTools_NTS.Util.Token"/>
            </summary>
        </member>
        <member name="T:RTools_NTS.Util.IntToken">
            <summary>
            Token type for integer tokens. This handles both Int32 and Int64.
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.Int32)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.Int64)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.Int32,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.#ctor(System.Int64,System.Int32)">
            <summary>
            Constructor for a 64 bit int
            </summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.ParseHex(System.String,System.Int32)">
            <summary>
            Parse a string known to be a hex string.  This is faster
            than Parse which doesn't assume the number is Hex.  This will
            throw an exception if the input number isn't hex.
            </summary>
            <param name="s">The hex number as a string.</param>
            <param name="lineNumber">The line where this token was found.</param>
            <returns>A new IntToken set to the value in the input string.</returns>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.Parse(System.String)">
            <summary>
            Convert the input string to an integer, if possible
            </summary>
            <param name="s">The string to parse.</param>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.ToString">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="P:RTools_NTS.Util.IntToken.StringValue">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="M:RTools_NTS.Util.IntToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools_NTS.Util.Token"/></summary>
        </member>
        <member name="T:RTools_NTS.Util.VerbosityLevel">
            <summary>
            This enumerates verbosity levels.
            </summary>
        </member>
        <member name="F:RTools_NTS.Util.VerbosityLevel.Error">
            <summary>For error messages.</summary>
        </member>
        <member name="F:RTools_NTS.Util.VerbosityLevel.Warn">
            <summary>For warn messages.</summary>
        </member>
        <member name="F:RTools_NTS.Util.VerbosityLevel.Info">
            <summary>For info messages.</summary>
        </member>
        <member name="F:RTools_NTS.Util.VerbosityLevel.Debug">
            <summary>For debug messages.</summary>
        </member>
    </members>
</doc>
